//////////////////////////////////////////////////1. Ders//////////////////////////////////////////

template tekrarı...

variadic template:

template <typename ...Ts> //template parameter pack
template <int ...Vals>

------------------------------------

int main()
{
using namespace std;

bitset<32> //template argümanının 32 olmasını istiyoruz
}

-----------

template <typename T, typename U = int>
class Myclass {

};

int main()
{
Myclass<double, long>
}

-----------

!! template tanımları başlık dosyalarında yapılamaz
cpp dosyasında her şey gerçekleşir

!! template kod gizlenemez

---------

template <typename T>
class Neco;

template <typename T, typename U>
void foo(T, U);

#include "bugra.hpp" //burada tanım ile içeriği birbirinden gizlemek için
böyle bir hile kullanılabilinir

-------------------------------------------------------------

fonkksiyon template (fonksiyon şablonu): derleyicinin fonksiyon kodu yazmasını sağlayan kod kalıbı 
----------------------------------------

template <typename T>
void foo(T x)
{
T y{};
T* p = &y;
T** ptr = &p;
}

------

template <typename T>
void foo(int x, int y); //bu şekilde olabilir template kullanmak zorundna değiliz

------

template <typename T>
void foo(T x, int y) //bu şekilde de olabilir
{

}

------

template <typename T>
void foo() //bu şekilde de olur tür kullanılmak zorunda değil
{

}

int main()
{
foo<int>();
}

------------------------------------------------

template argument deduction : 
-----------------------------

derleyici bir şablon söz konusu olduğunda bu şablondaki 
template parametreleri karşılığı instanci yapmak için hangi template argümanlarını kullanıcağını
koda bakarak anlıycak


!! auto ile template argument arasında 1 istisna dışında fark yoktur

-------

int main()
{
auto x = 10;

foo(10);
}

------

auto haşağıdaki şekillerde olabiliyordu

auto x = expr;
auto& x = expr;
auto && y = expr;

------
istisna :

#include <initializer_list>

int main()
{
auto x = {1, 2, 3, 4, 5};
}

--------
#include <initializer_list>

template <typename T>
void foo(T) 
{

}

int main()
{
foo({1, 2, 3, 4, 5}); //tek fark burasısıdr hata verir
}

--------

template <typename T>
void foo(T) 
{

}

int main()
{
const int ival = 4;
foo(ival); T çıkarımı int ival, const düşer
}

---------

template <typename T>
void foo(T) 
{

}

int main()
{
const int ival = 4;
int y{};
int& r = y;

foo(r); //T için yapılan çıkarım int
}

-------

template <typename T>
void foo(T) 
{

}

int main()
{
const int ival = 4;
int y{};
const int& r = y;

foo(r); //T için yapılan çıkaarım int
}

-------

template <typename T>
void foo(T) 
{

}

int main()
{
int a[5]{}

foo(a); //int için yaplan çıkarım int*
}

-------

template <typename T>
void foo(T) 
{

}

int main()
{
const int a[5]{}

foo(a); //int için yaplan çıkarım const int*
}

--------

template <typename T>
void foo(T) 
{

}

int bar(int);

int main()
{

foo(bar); //int (*)(int), function pointer type

}
//Bu söylenenlerin hepsi auto içinde geçerli

--------

template <typename T>
void foo(T) 
{

}

int main()
{
foo("bugrahan"); //const char*
}

------------------

!! Aşağıdaki yapı ile derleyicinin bize verdiği hata mesajı ile
türünü bulabiliriz

template <typename T>
class TypeTeller;

template <typename T>
void foo(T) 
{
TypeTeller<T> x;
}

int main()
{
const int x{}
foo(x); //x türü bulunur 
foo("bugrahan"); 
}

---------------------

deduction her zaman başarılı olmak zorunda değil 
fonksyion argümanında gönderilen argüman olduğu zaman çıkarımın yapılamaması

template <typename T> 
void foo();

int main()
{
foo();
}

---------

template <typename T> 
void foo(int, int);

int main()
{
foo(12, 56); //hata
}

---------

template <typename T> 
void foo(T, T);

int main()
{
foo(12, 56); //legal
foo(12, 5.8); //ambigidious hata
}

---------

template <typename T, typename U> 
void foo(T, U);

int main()
{
foo(12, 5.8); //legal
}


--------

template <typename T> 
void foo(T, T);

int main()
{
int a[10]{};
int b[234]{};
foo(a, b); //legal
}

-------

template <typename T> 
void foo(T, T);

int main()
{
int a[10]{};
double b[234]{};
foo(a, b); //hata 
}

-------

template <typename T> 
void foo(T, T);

int main()
{
foo("bugrahan", "serttas"); //legal
}

------------------

template <typename T>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int main()
{
int x = 10;
foo(x); //t iiçin yapılan int ama fonksiyon parametresi t&
}

------------

template <typename T>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int main()
{
const int x = 10; //const int
foo(x); 
}

---------------

template <typename T>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int main()
{
int a[4]{};
foo(a); //int(&)[4]
}

---------------

template <typename T>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int main()
{
const int a[4]{};
foo(a); 
}

----------------
//mülakatta sorulan bir soru

template <typename>
class TypeTeller;

template <typename T>
void foo(T&, T&) 
{

}

int main()
{
foo("can", "eda"); //legal, const char[4], const char[4]
foo("naci", "cemal"); //hata ,const char[5], const char[6]
}

-----------------

template <typename>
class TypeTeller;

template <typename T>
void foo(T&, T) 
{

}

int main()
{
int a[5]{};
foo(a, a); //illegal
}

--------------------

template <typename>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int bar(int);

int main()
{
foo(bar); //int(int)
}

--------------------

zor olan kısıma geçiruz, programcıların en çok karıştırdığı kısım

template <typename T>
void func(T &&) //universal referans  /std ==> forwarding reference
{
//bu fonksiyona yapılan bütün çağrılarla yapılan çağrılar legaldir

}

-------

class Myclass{};

void func(Myclass &&) //R value
{

}

-----------

template <typename T>
void func(T &&) 
{

}

int main()
{
int x = 10;
const double dval = 4.5;

func(x); //legal
func(45); //legal
func(dval); //legal
}

--------------

template <typename T>
void func(T &&) //Nec&, refernas collapsing. ile ilgili
{

}

class Nec{};

int main()
{
Nec mynec;
func(mynec);
}

--------------

class Nec{};

using refref = Nec&&;

int main()
{
Nec mynec;
refref& r = Nec{} //nec&
refref&& r = Nec{} //nec&&

}

-------------

template <typename>
class TypeTeller;

template <typename T>
void func(T &&) // T ==> Myclass
{
TypeTeller<T> x;
}

class Myclass {};

int main()
{
func(Myclass{});
}

--------------
!! 
template <typename T>
void func(T&&)
{
//L value gönderirsek fonksiyon parametre değişkeni L value
//R value gönderirsek fonksiyon parametre değişkeni R value
}

-------------

template <typename T>
void func(T&& X)
{

}

int main()
{
const int x{};
func(x);
}

--------------

int main()
{
int x = 5;
auto&& r = x;
}

