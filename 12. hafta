//////////////////////////////////////////////////1. Ders//////////////////////////////////////////

template tekrarı...

variadic template:

template <typename ...Ts> //template parameter pack
template <int ...Vals>

------------------------------------

int main()
{
using namespace std;

bitset<32> //template argümanının 32 olmasını istiyoruz
}

-----------

template <typename T, typename U = int>
class Myclass {

};

int main()
{
Myclass<double, long>
}

-----------

!! template tanımları başlık dosyalarında yapılamaz
cpp dosyasında her şey gerçekleşir

!! template kod gizlenemez

---------

template <typename T>
class Neco;

template <typename T, typename U>
void foo(T, U);

#include "bugra.hpp" //burada tanım ile içeriği birbirinden gizlemek için
böyle bir hile kullanılabilinir

-------------------------------------------------------------

fonkksiyon template (fonksiyon şablonu): derleyicinin fonksiyon kodu yazmasını sağlayan kod kalıbı 
----------------------------------------

template <typename T>
void foo(T x)
{
T y{};
T* p = &y;
T** ptr = &p;
}

------

template <typename T>
void foo(int x, int y); //bu şekilde olabilir template kullanmak zorundna değiliz

------

template <typename T>
void foo(T x, int y) //bu şekilde de olabilir
{

}

------

template <typename T>
void foo() //bu şekilde de olur tür kullanılmak zorunda değil
{

}

int main()
{
foo<int>();
}

------------------------------------------------

template argument deduction : 
-----------------------------

derleyici bir şablon söz konusu olduğunda bu şablondaki 
template parametreleri karşılığı instanci yapmak için hangi template argümanlarını kullanıcağını
koda bakarak anlıycak


!! auto ile template argument arasında 1 istisna dışında fark yoktur

-------

int main()
{
auto x = 10;

foo(10);
}

------

auto haşağıdaki şekillerde olabiliyordu

auto x = expr;
auto& x = expr;
auto && y = expr;

------
istisna :

#include <initializer_list>

int main()
{
auto x = {1, 2, 3, 4, 5};
}

--------
#include <initializer_list>

template <typename T>
void foo(T) 
{

}

int main()
{
foo({1, 2, 3, 4, 5}); //tek fark burasısıdr hata verir
}

--------

template <typename T>
void foo(T) 
{

}

int main()
{
const int ival = 4;
foo(ival); T çıkarımı int ival, const düşer
}

---------

template <typename T>
void foo(T) 
{

}

int main()
{
const int ival = 4;
int y{};
int& r = y;

foo(r); //T için yapılan çıkarım int
}

-------

template <typename T>
void foo(T) 
{

}

int main()
{
const int ival = 4;
int y{};
const int& r = y;

foo(r); //T için yapılan çıkaarım int
}

-------

template <typename T>
void foo(T) 
{

}

int main()
{
int a[5]{}

foo(a); //int için yaplan çıkarım int*
}

-------

template <typename T>
void foo(T) 
{

}

int main()
{
const int a[5]{}

foo(a); //int için yaplan çıkarım const int*
}

--------

template <typename T>
void foo(T) 
{

}

int bar(int);

int main()
{

foo(bar); //int (*)(int), function pointer type

}
//Bu söylenenlerin hepsi auto içinde geçerli

--------

template <typename T>
void foo(T) 
{

}

int main()
{
foo("bugrahan"); //const char*
}

------------------

!! Aşağıdaki yapı ile derleyicinin bize verdiği hata mesajı ile
türünü bulabiliriz

template <typename T>
class TypeTeller;

template <typename T>
void foo(T) 
{
TypeTeller<T> x;
}

int main()
{
const int x{}
foo(x); //x türü bulunur 
foo("bugrahan"); 
}

---------------------

deduction her zaman başarılı olmak zorunda değil 
fonksyion argümanında gönderilen argüman olduğu zaman çıkarımın yapılamaması

template <typename T> 
void foo();

int main()
{
foo();
}

---------

template <typename T> 
void foo(int, int);

int main()
{
foo(12, 56); //hata
}

---------

template <typename T> 
void foo(T, T);

int main()
{
foo(12, 56); //legal
foo(12, 5.8); //ambigidious hata
}

---------

template <typename T, typename U> 
void foo(T, U);

int main()
{
foo(12, 5.8); //legal
}


--------

template <typename T> 
void foo(T, T);

int main()
{
int a[10]{};
int b[234]{};
foo(a, b); //legal
}

-------

template <typename T> 
void foo(T, T);

int main()
{
int a[10]{};
double b[234]{};
foo(a, b); //hata 
}

-------

template <typename T> 
void foo(T, T);

int main()
{
foo("bugrahan", "serttas"); //legal
}

------------------

template <typename T>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int main()
{
int x = 10;
foo(x); //t iiçin yapılan int ama fonksiyon parametresi t&
}

------------

template <typename T>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int main()
{
const int x = 10; //const int
foo(x); 
}

---------------

template <typename T>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int main()
{
int a[4]{};
foo(a); //int(&)[4]
}

---------------

template <typename T>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int main()
{
const int a[4]{};
foo(a); 
}

----------------
//mülakatta sorulan bir soru

template <typename>
class TypeTeller;

template <typename T>
void foo(T&, T&) 
{

}

int main()
{
foo("can", "eda"); //legal, const char[4], const char[4]
foo("naci", "cemal"); //hata ,const char[5], const char[6]
}

-----------------

template <typename>
class TypeTeller;

template <typename T>
void foo(T&, T) 
{

}

int main()
{
int a[5]{};
foo(a, a); //illegal
}

--------------------

template <typename>
class TypeTeller;

template <typename T>
void foo(T&) 
{
TypeTeller<T> x;
}

int bar(int);

int main()
{
foo(bar); //int(int)
}

--------------------

zor olan kısıma geçiruz, programcıların en çok karıştırdığı kısım

template <typename T>
void func(T &&) //universal referans  /std ==> forwarding reference
{
//bu fonksiyona yapılan bütün çağrılarla yapılan çağrılar legaldir

}

-------

class Myclass{};

void func(Myclass &&) //R value
{

}

-----------

template <typename T>
void func(T &&) 
{

}

int main()
{
int x = 10;
const double dval = 4.5;

func(x); //legal
func(45); //legal
func(dval); //legal
}

--------------

template <typename T>
void func(T &&) //Nec&, refernas collapsing. ile ilgili
{

}

class Nec{};

int main()
{
Nec mynec;
func(mynec);
}

--------------

class Nec{};

using refref = Nec&&;

int main()
{
Nec mynec;
refref& r = Nec{} //nec&
refref&& r = Nec{} //nec&&

}

-------------

template <typename>
class TypeTeller;

template <typename T>
void func(T &&) // T ==> Myclass
{
TypeTeller<T> x;
}

class Myclass {};

int main()
{
func(Myclass{});
}

--------------
!! 
template <typename T>
void func(T&&)
{
//L value gönderirsek fonksiyon parametre değişkeni L value
//R value gönderirsek fonksiyon parametre değişkeni R value
}

-------------

template <typename T>
void func(T&& X)
{

}

int main()
{
const int x{};
func(x);
}

--------------

int main()
{
int x = 5;
auto&& r = x;
}

-------------

tür çıkarımı hakkında konuşmaya devam ediyoruz

template <typename T, int N>
void func(T(&r)[N])
{

}

int main()
{
int a[20]{};
double b[10]{};

func(a); //func<int, 20>(a);
func(b); //func<double, 10>(b);
func("bugra"); 
}


--------------

zor bir örnek

template <typename>
class TypeTeller;

template <typename T, typename U> //T için int, U için double çıkarımı yapılır
void func(T (*)(U)) //int (*)(double)
{

}

int foo(double);

int main()
{
func(foo);  
}

-----------------------

fonksiyon çağrısı deduction için tek yol değildir
fonksiyonun adresini alarakta yapabiliriz

template <typename T>
void func(T)
{

}

int main()
{
void (*fp1)(int) = func;
void (*fp1)(double) = func;
}

----------------

template <typename T>
void foo(T*);

template <typename T>
void func(T x)
{
foo(&x);
}

int main()
{
func(12);
}

---------------

stl en çok kullanılan fonksyion şablonu, swap

template <typename T>
void Swap(T& t1, T& t2)
{
T temp{std::move(t1)}
t1 = std::move(t2);
t2 = std::move(t1);
}

------
#include <utility>

int main()
{
int x = 24;
int y = 45;

std::swap(x, y);
std::cout << "x = " << x << '\n';
std::cout << "y = " << y << '\n';
}

-----

#include <utility>

int main()
{
std::string s1{"bugrahan"};
std::string s1{"serttas"};

std::swap(s1, s2);
std::cout << s1 << " " << s2 << "\n";
}

-------------

template <typename F>
void func(Fn f)
{
auto val = f(12);
std::cout << "val = " << val << "\n";
}

int foo(int x)
{
std::cout << "foo cagrildi x = " << x << "\n";
return x * x;
}

int main()
{
func(foo);
}

-------------

template <typename F>
void func(Fn f)
{
auto val = f(12);
std::cout << "val = " << val << "\n";
}

class Nec {
public:
int operator()(int x)const
{
std::cout << "Nec::operator()(int x) x = " << x << '\n';
return x * x * x;
}
};

int main()
{
func(Nec{});
}

--------------

C++ 20 ile geldi, kısaltılmış template standartı

template <typename T>
void func(T x)
{

}

//yukarıdaki aşağıdaki şekilde yazılabilir, çok sık kullanılıyor

void func(auto x)
{

}

------

template <typename T, typename U>
void func(T x, U y)
{

}

//

void func(auto x, auto y)
{

}

----------------------

c++ 11 ile 

// trailing return type
// auto return type
geldi 


trailing return type: normal main ile aynı anlamda aşağıdakini kullanmanın bir manası yok
---------------------
auto main() -> int
{

}


işe yaradığı yerler

int (*foo(())(int) //geri dönüş değeri türü int(*) (int)
{

}

----

int bar(int);

auto foo() -> int(*)(int)
{
return bar;
}

----

template <typename T, typename U>
auto sum(T x, U y) -> decltype(x + y) //ok'un sağında parametre değişkenlerini kullanabiliyoruz
{

}

-----------

auto return type : fonksiyonun geri dönüş değeri türünün return ifadesinden yapılması demektir

auto foo(int x)
{

return x * 1.3; //geri dönüş değeri double
}

----

auto foo(int x)
{
if (x > 10)
return 1;

return 2.3; //hata
}

-----

template <typename T>
auto foo(T x)
{

return x.bar();
}

----------------------

fonksiyon şablonu sınıfın üye fonksiyonu da olabilir

class Myclass {
public:
void foo(int);

template <typename T>
//void bar(auto x) //c++20 ile bu şekilde yazılabilinir
void bar(T x)
{

}
};

int main()
{
Myclass m;

m.bar(12); //derleyici int parametreli fonksiyon yazar
m.bar(1.2); //derleyici double parametreli fonksiyon yazar
m.bar("ali"); //derleyici const char* parametreli fonksiyon yazar
}

-----------

template <class T> //bu şekilde yazılamıycağı bir senayo vardır

class Myclass {
public:
using value_type = int;
};

template <class T>
void func(T x)
{
typename T::value_type y{};
}

----------

template <typename R, typename T, typename U> //geri dçnüş değerini template yapabilriiz (R)
R sum(const T& x, const U& y)
{
return x + y; 
}

int main()
{
sum<double>(12, 4.5); //bu şekilde olabilir

int x = 45;
float f = 3.4;
sum<double>(x, f); //bu şekilde de olabilir

auto val = sum<double>(x, f);
}

----------
#include <typeinfo>

template <typename T>
void func(T)
{
std::cout << typeid(T).name << "\n";
}

int main()
{
func(12.4); //her farklı argüman için farklı bir speciliation yazıcak
func(12.4f);
func(12);
func('A');

func<double>('A'); //Bu şekilde double olarak döndürür
}

---------------

fonksiyon şablonları aynı isimli başka fonksiyon şablonları ile aynı isimli bulunabilir 
yani bir fonksiyon şablonu ile bir fonksiyon aynı isimde ise birbirini overload ederler

--------

template <typename T>
void func(T)
{
std::cout << "function template: " << typeid(T).name() << "\n";
}

void func(int x)
{
std::cout << "harbi fonksiyon\n";
}

//void func(int) //bu çağrılır, exact match
//void func<int>(int) 

int main()
{
func(13);
}

---------------

eski bir mülakat sorusu,
öyle bir kod yaz ki int argüman ile cagrilması zorunlu

template <typename T>
void func(T) = delete;

void func(int);

int main()
{
func(12);
}

-------------

birden fazla fonksiyon şablonu da bir arada bulunabilir, overloading

template <typename T>
void func(T x)
{

}

template <typename T>
void func(T x, T y)
{

}

template <typename T>
void func(T *p)
{

}

-------------
partial ordering rules : daha spesifik daha fazla nitelenmiş parametreye sahip
template seçilir, (kısa bir değindi konu daha detaylı)


template <typename T>
void func(T x)
{
std::cout << "T x\n";
}

template <typename T>
void func(T *p)
{
std::cout << "T* p\n";
}

int main()
{
int x = 10;
func(&x);
}
------------





