///////////////////////////////////////////////// 1. Ders ////////////////////////////////////////////////

int main()
{
using namespace std;
using namespace std::chrono;

system_clock::now(); //time point döndürü

system:clock::now().time_since_epoch(); //duration döndürür

system:clock::now().time_since_epoch().count; //representatation türünden olur

duration_cast<milliseconds>(system_clokc::now().time_since_epoch()).count()  
}

-----------------

int main()
{
using namespace std;
using namespace std::chrono;

system_clock::to_time_t(); //time point ister bunu c'deki time pointe dönüştürür
system_clock::from_time_t(); //

}

----------------------

int main()
{
using namespace std;
using namespace std::chrono;

time_t tx{1'600'000'000 };
auto tp = system_clock::from_time_t(tx);
}

-----------------------

int main()
{
using namespace std;
using namespace std::chrono;

auto tp = system_clock::now;

time_t tx = system_clock::to_time_t(tp);

cout << ctime(&tx) << '\n';
}

------------------------

int main()
{
using namespace std;
using namespace std::chrono;

days ondeay{ 1 };

auto tp_today = system_clock::now();

auto tp_tomorrow = tp_today + oneday;

time_t t1 = system_clock::to_time_t(tp_today);
time_t t2 = system_clock::to_time_t(tp_tomorrow);
cout << ctime(&t1) << "\n";
cout << ctime(&t2) << "\n";
 
}

------------------------

print_time kodunu incele kod visual stdiooda

------------------------

=======================================================================

Vocabulary Types 
----------------

std::optional 
std::variant
std::any

hepsi c++ 17 ile geldi

------------------------

std::optional
--------------
Belirli bir türden ya bir değere sahip ya da değil, 
bir optional nesnesi 2 state'den birinde olabilir

A - bir değeri var
B - bir değeri yok


std::variant
------------
Bir union
Ya int tutucak ya string tutucak vs.
n tane farklı türden değer tutmak istersek variant kullanırız


std::any
--------
herhangi bir türden değer tutmak için yapılır

---------------------

#include <optional>
#include <string>
#include "date.h"

using namespace std;

int main()
{

optional<int> x;

if (x) {
std::cout << "dolu bir degere sahip\n";
}
else {
std::cout << "bos bir degere sahip \n";
}
}

----------------

using namespace std;

int main()
{
optional<int> x{ 678 };

if (x) {
std::cout << "dolu bir degere sahip\n";
}
else {
std::cout << "bos bir degere sahip degil\n";
}
}

---------------

using namespace std;

int main()
{
optional<int> x{ 678 };

cout << "x= " << (x ? "dolu" : "bos") << "\n";
}

--------------

bir contructor daha var, nullopt

int main()
{
optional<int> x{nullopt};

cout << "x = " << (x ? "dolu" : "bos") << "\n";
}

--------------

int main()
{
using namespace std;

optional<int> x = 10;
optional y = 10; //ikisi arasında fark yok ctad
}

---------------
//mülakatlarda gelir

int main()
{
using namespace std;

optional<int> x1; //bos
optional<int> x2{}; //bos
optional<int> x3{nullopt}; //bos
optional<int> x4(); //x4 optinol nesnesi değil fonksiyon bildirimi

if (!(x1 && x2 && x3)) {
std::cout << "hepimiz bombosuz\n";
}
}

----------------

int main()
{
using namespace std;

optional<int> x;

if (x){} //aynı anlamda
if (x.operator bool ()){} //aynı anlamda
if (x.has_value){} //aynı anlamda

}

----------------

int main()
{
using namespace std;

optional x(3456);

cout << *x << "\n";
*x = 6787;
cout << *x << "\n";
}

-------------------

int main()
{
using namespace std;

optional<string> osx{ "naci cemal" };

cout << *osx << '\n';

cout << "uzunluk = " << osx->lenght() << '\n';

*osx += " dagdalen";

cout << *osx << "\n";
}

-------------------

int main()
{
using namespace std;

optional<string> os;

try {
cout << *os << "\n";
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n'; //ub döndürür kod boş
}
}

---------------------

//yukarıdaki durumun önüne geçmek için

int main()
{
using namespace std;

optional<string> os;

if (os != nullopt) { //yapılır
cout << *os << "\n";
}
}

-------------------

//value fonksiyonu da kullanılabilir

int main()
{
using namespace std;

optional<string> os;

try {
cout << os.value() << "\n";
}
catch (const std::bad_optional_access& ex) {
std::cout << "exception caught: " << ex.what() << '\n'; //ub döndürür kod boş
}
}

--------------------

int main()
{
using namespace std;

optional<string> os{"bugra"};

cout << *os << "\n";
cout << os.value() << "\n";

os.value() += "sentoregil";
}

------------------
3 fonksiyonu vardır optional'ın

ox.operator*

ox.value

ox.value_or

---------------------

ilginç ve karmaşık bir fonksiyon daha var
ox.value_or

int main()
{
using namespace std;

optional<string> os{ "furkan mert" };

cout << os.value_or("noname") << "\n"; 

os = {}; //optional boş hale geldi

cout << os.value_or("noname") << "\n";  //noname yazar
}

------------------

int main()
{
using namespace std;

optional<int> os(456);

os.value_or(457) = //hata

}

--------------------

void print_e_mail(const std::optional<std::string>& op)
{

}

int main()
{
print_e_mail("necati ergin");

print_e_mail(std::nullopt);
print_e_mail({});
print_e_mail(optinal<string>{}; //hepsi  ben bir değer göndermiyorum anlamında
}

------------------

class Person {

private:

std::optional<string> m_middle_name;
};

void print_e_mail(const std::optional<std::string>& op)
{

}

int main()
{

}

---------------
//value or olmasaydı aşağıdaki yapı kulllanırdık

void print_e_mail(const std::optional<std::string>& op)
{
if (op) {

}
else {

}
}

int main()
{

}

----------------

void print_e_mail(const std::optional<std::string>& op)
{
std::cout < "e-posta adresi : " << op.value_or("yok") << "\n";
}

int main()
{

}

------------

class Record {
public:
Record(const std::string& nmake, std::optional<string>nick, std::optional<int> age) :
m_name(name), m_nick(nick), m_age(age) {}

private:
std::string m_name;
std::optional<std::string> mnic;
std::optinal<int> m_age;
};

int main()
{
Record r1{ "bugra serttas", "speedy coder", 23};
Record r1{ "bugra serttas", {}, nullopt}; //bu şekilde de olur
}

-------------

optional şöyle tarif ediyorlar 

sana bir bardak veriyorum bu bardağı boşda verebiliriim doluda

--------------
//string'İn inte dönüştürücek

stoi(s) //aldığı stringi inte dönüştürür, ancak string geçerli değil ise exception döndürür ancak ben bunu istemiyorum
//return std::nullopt;
//return {}; //bu da olur

std::optional<int>
to_int(const std::string& s)
{
try {
return stoi(s);
}
catch(...) {
return {};
}
}

--------------

//aşağıdaki şekilde de olabilirdi

std::optional<int>
to_int(const std::string& s)
{
std::optional<int> ret;

try {
return stoi(s);
}
catch(...) {
return std::nullopt;
}
}

----------------

//aşağıdaki şekilde de olabilirdi

std::optional<int>
to_int(const std::string& s)
{
std::optional<int> ret;

try {
return stoi(s);
}
catch(...) {
return ret;
}

int main()
{
using namespace std;

auto op = to_int("78788");

if (op)
cout << *op << "\n";
else 
cout << "gecersiz tam sayi";
}

------------------

// tuttupu değerlerin detroy edildiği duurumlarda var

class A {
~A() {std::cout << "~A() this: " << this << '\n'; }
A() {std::cout << "A() this: " << this << '\n'; }
A(int) {std::cout << "A(int) this: " << this << '\n'; }
A(int, int) {std::cout << "A(int, int) this: " << this << '\n'; }
A(std::string) {std::cout << "A(string) this: " << this << '\n'; }
};

int main()
{
using namespace std;

optional<A> ox;
ox.emplace(45, 67); //default ctor çağrılır
ox.emplace(78,98);
ox.emplace(45.5);
ox.emplace("furkan");
}

-----------------------

class A {
~A() {std::cout << "~A() this: " << this << '\n'; }
A() {std::cout << "A() this: " << this << '\n'; }
A(int) {std::cout << "A(int) this: " << this << '\n'; }
A(int, int) {std::cout << "A(int, int) this: " << this << '\n'; }
A(std::string) {std::cout << "A(string) this: " << this << '\n'; }
};

int main()
{
using namespace std;

optional<A> x;

x = 5; //legal

for (int i = 0; i < 10; ++i) {
x.emplace(i);
}
}

----------------

int main()
{
using namespace std;

Date mydate{3, 6, 1981};

optional<Date> ox(mydate); //copy ctor çağrılacak, move aparsam move ctor
}

--------------

int main()
{
using namespace std;

optional<Date> ox(4,5 1987); //böyle bir sey yok bu temlate'ler ile ilgili temel bir problem

//bunu aşmak için aşağıdaki hile yapılır

}

--------------

int main()
{
using namespace std;

optional<Date> ox(in_place, 4, 5, 1987);

cout << *ox << "\n";
}

---------------

int main()
{
using namespace std;

optional<Date> ox{ in_place, 10, 'A' };

cout << *ox << "\n";
ox.emplace(20, 'b');
cout << *ox << "\n";
}

------------------

int main()
{
using namespace std;

optional<string> o1(in_place, 20, 'X');
auto o2 = make_optional<string>(10, 'Y');
auto o3 = make_optional<Date>(2,5,1995);

cout << *o1 << "\n";
cout << *o2 << "\n";
cout << *o3 << "\n";

}

-------------------

class Myclass {
public:
Myclass();
Myclass(int);
Myclass(int, int);
Myclass(const Myclass&) = delete;
Myclass& operator=(const Myclass&) = delete;
};

int main()
{
using namespace std;

Myclass m1; //legal
Myclass m2(12); //legal
Myclass m3(12, 57); //lwgal

auto m4 = m1; //hata
auto m4 = move(m1); //hata
}

--------------------

class Myclass {
public:
Myclass();
Myclass(int);
Myclass(int, int);
Myclass(const Myclass&) = delete;
Myclass& operator=(const Myclass&) = delete;
};

int main()
{
using namespace std;

Myclass m1;
Myclass m2(12);

optional<Myclass> ox(in_place, 3, 5); //legal
optional<Myclass> ox(in_place); //legal

ox.emplace(34);
ox.emplace();
}

------------------------

optional<Myclass> x(in_place,1,4,5); //buradaki implace back fonksiyonunu functionu ayırıcı olarak kullanıp bundan sondan gelenleri ilgili fonksiyona koyabilirim

make_optional<Myclass>(1,4,5); //bu şekilde de yapılabilir

-----------------------

class Myclass {
int x{};
int y{};

};

int main()
{
std::cout << "sizeof(Myclass) = " << sizeof(Myclass) << "\n";
std::cout << "sizeof(optional<Myclass>) = " << sizeof(optional<Myclass>) << "\n";

}

----------------

template <std::size_t n>
struct Myclass {

char buf[n]{};
};

template <size_t n>
using otype = optional<Myclass<n>>; //alias template

int main()
{
otype<10>
std::optional<Myclass<10> //aynı anlamda alias template sayesinde
}

------------------

int main()
{
using namespace std;

string name{"mustafa"};

optional x = name;
optional x = ref(name);

(*x).get() = "salih";
x->get() = "tunahan"; //aynı anlamda

cout << "name = " << name << '\n';
}

----------------------

optional nesnelerini karşılaştırma operatörünün operandı yapabiliyoruz

int main()
{
using namespace std;

optional x = 5;
optional y = 123;

boolalpha(cout);

cout << (x == y) << "\n";
cout << (x != y) << "\n";
cout << (x < y) << "\n";
}

----------------

int main()
{
using namespace std;

optional<int> x;
optional y = 123;

boolalpha(cout);

cout << (x < y) << "\n";
cout << (x != y) << "\n";
}

--------------------

int main()
{
using namespace std;

optional<bool> x;
optional<bool> y(false);

cout << boolalpha;

cout << (x == true) << "\n";
cout << (x == false) << "\n";
cout << (x == nullopt) << "\n";
cout << (x < false) << "\n";
}


=================================================================

variant : aslında bellek alanı var o bellekte nesneyi tutacak ancak compile time'da o bellek alanında hangi argümanların tutulabileceği template argümanlarıyla belirlenecek
---------

#include <variant>

union Nec {
int x;
double dval;
//
};

int main()
{

}

---------------

using namespace std;

int main()
{
variant<int, double, long, char> x;
}

------------------

default init edilebiliyor

using namespace std;

int main()
{
variant<int, double, long, char> x;

// x'İ kullansak türü int olucak, ilk alternatifi tutar
}

----------------------
using namespace std;

int main()
{
variant<int, double, long, char> x;

cout << x.index() << "\n"; //tutuğı indexi tutar
}

-------------------

int main()
{
variant<string, double, long, char> x(4.5);

cout << x.index() << "\n"; //1 olucak
}

-------------------

int main()
{
variant<string, double, long, char> x(4.5);

x = 3.4;

cout << x.index() << "\n"; 

x = 34;

cout << x.index() << "\n"; 
}

-----------------

bir yolu daha vardır

int main()
{
variant<string, double, long, char> x;

cout << x.index() << "\n"; 

if (holds_alternative<int>(x)) { //if tutuyorsa doğru kısma giricek

}
}

------------------

int main()
{
variant<string, double, long, char> x{57}; //double yapıp dene

cout << x.index() << "\n"; 

if (holds_alternative<int>(x)) { 
cout << "evet int tutuyor\n";
}
if (x.index() == 2) { 
cout << "evet int tutuyor\n";
}
}

------------------

using namespace std;

int main()
{
using namespace std;

variant<int, double, int> x;

cout << get<0>(x) << "\n";

variant<string, double, int> y;
}

----------------------

int main()
{
variant<string, double, int> x{3.47};

cout << get<1>(x) << "\n";
get<1>(x) = 965.46;

x = "mustafa";

x += "mustafa; //hatalı

get<0>(x) += " can"; //bu şekilde olur
}

----------------------

int main()
{
variant<string, double, int> x{3.47};

get<double>(x);
}

----------------

özetlersek

variant tuttuğu değere 2 şekilde erişebilirim

get fonksiyon şablonu ama nontype parametre ile
get<0>(x)

get fonksiyon şablonu ama tür parametresi ile
get<double>(x)

----------------

int main()
{
variant<string, double, int> x{3.47}; 

get<3> x; //sentax hatası
get<long> x; //hata
}

-----------------

int main()
{
variant<string, double, int> x{3.47};  //default etmezsek seçim yapıyor

try {
auto val = get<2>(x);
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

-------------------

int main()
{
variant<int, double, long> x('A'); //hata yok char'dan inte dönüşüm var

cout << "x.index() " << x.index() << '\n';

}

----------------

int main()
{
variant<int, Date, string> x{12, 5, 1987};  //burada fonksiyo date nesnesine erişiceğini anlamaz
//bunun yerine tag nesnesi kullanmamız lazım

variant<int, Date, string> x(in_place_type<Date>, 2,5,1987);

cout << get<1>(x) << "\n";

x.emplace<string>(10, 'a');
cout << get<2>(x) << "\n";
}

---------------

class A {
public:
A(int);
};

class B {
public:
B(double);
};

class C {
public:
C(int);
};

int main()
{
using namespace std;

variant<A, B, C> vx;

//bazen variant'I hiçbir değer tutmuyor durumunda tutmak istiyouz
//bunu aşmak için monostate kullanırız

variant<monostate, int, double, long> x

cout << x.index() < "\n";

cout << boolalpha << hold_alternative<monostate> << "\n";
}

------------------

int main()
{
using namespace std;

variant<int, double, long> x(2.3);

get_if<int>(&x) //geri dönüş değeri adres ancak get tutmuyorsa nullptr

if (int *ptr = get_if<int>(&x)) {
cout << ğptr << "\n";
}
}

/////////////////////////////////////// 2. Ders /////////////////////////////

#include <variant>

ilk indextei tür alternatif yapmak istiyorsak onu default ctor yapmak gerekir
bunun için monostate kullanıyorduk

struct Data {
Data(int x) : mx{x};

int mx;
};

int main()
{
using namespace std;

variant<monostate, long, Data, int, double> vx;

vx = Data{45}; //bu şekilde dolu hale gelir
vx = {}; //bu şekilde yine boş
vx = monostate{}; //bu şekilde boş

//boşmu sorusu 

cout << "vx.index()= " << vx.index() << '\n';

// if (!vx.index());

if (holds_alternative<monostate>(vx)) {
std::cout << "evet bombos\n";
}
else {
std::cout << "ben sana bos degilim\n";
}

if (get_if<monostate>(&vx)) { //bu ifadenin türü monostate*
std::cout << "bos\n";
}
else {
std::cout << "bos_degil\n";
}
}

---------------------------

karşılaştırma operatörlerininde operandı olabiliyor

int main()
{
using namespace std;

//variant<int, double> v1;
//variant<double, int> v2;
//farklı tür ise karşılaştırılamaz, aynı tür olması lazım

variant<int, double> v1(12), v2(1.2), v3;
boolalpha(cout);

cout << (v1 == v2) << '\n';
cout << (v1 < v2) << '\n';
}

------------------------

int main()
{
using namespace std;

variant<int, double, long> vx;

auto val = get<3>(vx); //hata
}

---------------------

variant'a atama yapmak için ya bir atama, contruc etmem gerekiyor
ya da emplace fonksiyonunu çağırmak gerekiyor

-----------------

struct Data {
Data(int x) : mx{x} {}

int mx;
};

int main()
{
using namespace std;

variant<string, int, string> vx;

vx.emplace<0>("neco");
vx.emplace<string>("ali"); //hata

}

-----------------

int main()
{
using namespace std;

using age_t = int;
using gender_t = char;
using name_t = string;

enum = size_t {idx_age, idx_gender, idx_name};

variant<age_t, gender_t, name_t> p;

get<age_t>(p);
}

---------------------

ilginç bir seneryo var biraz karmaşık

struct Nec {

operator int()const
{
throw std::runtime_error{ "error error" };
return 1;
}
};

int main()
{
using namespace std;

variant<int, double> vx{4.5};

try {
vx.emplace<0>(Nec{}); //yeni değer alıcak ancak eski değer detroy edilmeli ancak burada eski destroy edilir ama yeni değer exception throw edilir
}
catch(const std::exception& ex) {
std::cout << "hata yakalandi : " << ex.what() << "\n";
cout << vx.index() << "\n"; 
cout << boolalpha << vx.valueless_by_exception() << "\n";
cout << (vx.index() == variant_npos) << "\n";
}
}

------------------------

int main()
{
using namespace std;

variant<int,Date ,string> vx{3,5,1988}; //hata
variant<int, string> vy{20 , 'm'}; //hta

}

-------------

//Yukarıdaki durumu legal kılmak için

int main()
{
using namespace std;

variant<int,Date ,string> v1{in_place_indexz<1>3,5,1988}; 
variant<int, string> v2{in_place_type<Date>,3,5,1988}; 
variant<int, Date, string> v3{in_place_index<2>, 20, 'm'};
variant<int, Date, string> v4{in_place_index<string>, 20, 'm'};
}

---------------

konunun en zor alt konusuna geçiyoruz

visit
//amaç varianttaki öğeyi kullanmak ama öğeye ney ise onu göre kullanıcağız

int main()
{
using namespace std;

variant<int, Date, string, double> vx{4.5};

if (vx.inde() == 0 {
cout << "alternative int code\n";
get<0>(vx) << "\n";
}
else if (vx (index() == 1) {
cout << "alternative Date code\n";
get<1>(vx) << "\n";
}
else if (vx (index() == 2) {
cout << "alternative string code\n";
get<2>(vx) << "\n";
}
else if (vx (index() == 3) {
cout << "alternative double code\n";
get<3>(vx) << "\n";
}
}

----------------
//burada böyle bir kod yerine hold alternative de kullanabilirdik

int main()
{
using namespace std;

variant<int, Date, string, double> vx{4.5};

if (holds_alternative<int>(vx)) {
cout << "alternative int code\n";
get<0>(vx) << "\n";
}
else if (holds_alternative<Date>(vx)) {
cout << "alternative Date code\n";
get<1>(vx) << "\n";
}
else if (holds_alternative<string>(vx)) {
cout << "alternative string code\n";
get<2>(vx) << "\n";
}
else if (holds_alternative<double>(vx)) {
cout << "alternative double code\n";
get<3>(vx) << "\n";
}
}

----------------------------
//aşağıdaki şekilde de oolabilir

int main()
{
using namespace std;

variant<int, Date, string, double> vx{4.5};

if (auto p = get_if<0>(&vx)) {
cout << "alternative int code\n";
get<0>(vx) << "\n";
}
else if (auto p = get_if<1>(&vx)) {
cout << "alternative Date code\n";
get<1>(vx) << "\n";
}
else if (auto p = get_if<2>(&vx)) {
cout << "alternative string code\n";
get<2>(vx) << "\n";
}
else if (auto p = get_if<3>(&vx)) {
cout << "alternative double code\n";
get<3>(vx) << "\n";
}
}

------------------------------

bunların yerine bize standart kütüphane  bize visit fonksiyonunu verir

int main()
{
using namespace std;

variant<int, Date, string, double> vx{Date{3,6,1998}};

visit(callable, vx) //bu callable alternative çağrılmış olur

}

--------------------

struct Visitor {

void operator()(int)const //burayı auto yapabiliriiz
{
std::cout << "int alternative code\n";
}

void operator()(Date)const
{
std::cout << "Date alternative code\n";
}

void operator()(const std::string&)const
{
std::cout << "string alternative code\n";
}

void operator()(double)const
{
std::cout << "double alternative code\n";
}
};

int main()
{
using namespace std;

variant<int,Date, string, double> vx{Date{3,6,1998}};

visit(visitor{}, vx);

}

-----------------

struct Visitor {

void operator()(auto x)const //bu şekilde olunca tüm parametreler için bu fonksiuon çağrılır
{
std::cout << x << "\n";
}

};

int main()
{
using namespace std;

variant<int,Date, string, double> vx{Date{3,6,1998}};

vx = "necati"s;

visit(visitor{}, vx);
}

----------------------
#include <type_traits>

class Visitor {
void operator()(auto x)
{
if constexpr (std::is_same_v<decltype(x), int) {

}
else if constexpr (std::is_same_v<decltype(x), double>) {

}
}
};

int main()
{
using namespace std;

variant<int,Date, string, double> vx{Date{3,6,1998}};

visit(Visitor{}, vx);
}

-------------------------------

multi lambda

necati hoca mülakatlarda soruyor dilin 6,7 özelliği bir arada bulunduğu için bu yapı

//biraz eski konuların tekrarını yapıyoruz

struct X {

};

struct Y {

};

struct Z {

};

struct A: X, Y, Z {

};

int main()
{
A a;
a.foo(2.3); //kalıtımda bu şekilde overloading hatalı olur
a.foo(23);
a.foo(56L);
}

--------------------
bunu legal (int main içinde dokunmadan) kılmak için sınıf içi using bildirimi kullanılır

struct X {

};

struct Y {

};

struct Z {

};

struct A: X, Y, Z {
using X::foo;
using Y::foo;
using Z::foo;
};

int main()
{
A a;
a.foo(2.3); //kalıtımda bu şekilde overloading hatalı olur
a.foo(23);
a.foo(56L);
}

------------------

class A {};
class B {};
class C {};

template <typename ...Args>
class Der : public Args... {

};

int main()
{
Der<A,B,C> myder;
}

---------------

class A {void foo();};
class B {void bar();};
class C {void baz();};

template <typename ...Args>
class Der : public Args... {

};

int main()
{
Der<A,B,C> myder;

myder.baz(); //hiçbiri sentax hatası değil
myder.foo();
myder.bar();
}

-----------------

struct A {void foo(int);};
struct B {void bar(long);};
struct C {void baz(double);};

template <typename ...Args>
class Der : public Args... {

};

int main()
{
Der<A,B,C> myder;

myder.foo(12); //hata olma nedeni ambgios

}

----------------

struct A {void foo(int);};
struct B {void bar(long);};
struct C {void baz(double);};

template <typename ...Args>
class Der : public Args... {
using Args::foo...; //sentax hatası kalkar
};

int main()
{
Der<A,B,C> myder;

myder.foo(12)
myder.foo(34L);
myder.foo(3.4);
}

------------------

struct A {void foo(int);};
struct B {void bar(long);};
struct C {void baz(double);};

template <typename ...Args>
class Der : public Args... {
using Args::foo...;
};

int main()
{
Der myder {A{}}; //ctad dan dolayı legal
Der d2 {A{}, B{}};
Der d3 {C{}, A{}, B{}};
}

---------------

int main()
{
auto f = [](int x) {return x* x;};

struct Nec : decltype(f1), decltype(f2),  decltype(f3) {}; //bir sınınftan bir sınıf kalıtım yolula elde ediliyor

cout << typeid(decltype(f)).name() << "\n";
}

--------------

//yukarıdaki anlatılanların hepsi multilambda idiomunda bize yardımcı olucak

template <typename ...Args>
struct MultiLambda : Args... {
using Args::operator()...; //bununla aşağıdak hata kalkar
};

struct A{};
struct B{};
struct C{};

int main()
{
MultiLambda mx{
[](int x) {return x +1; },
[](double x) {return x * 1.3;},
[](long y) {return y + 5;}
};

mx(12); //hata olmasının nedeni ambigos 3 taban sınıfında ayrı operator çağrı fonksiyonu var

auto val1 = mx(12);
auto val2 = mx(4.5);
auto val3 = mx(4L);

//illa visitor gerek yoktur bu yapı ile de kullanılabilir
}

------------------

template <typename ...Args>
struct MultiLambda : Args... {
using Args::operator()...; 
};

struct A{};
struct B{};
struct C{};

int main()
{
MultiLambda mx{
[](int x) {cout << "int\n";},
[](double x) {cout << "double\n";},
[](long y) {cout << "auto\n";}
};

mx(12); 
mx(3.1);
mx(3L);
MX(Nec{});
mx(Erg{});
mx{Tmr{});
}

--------------------
using namespace std;

template <typename ...Args>
struct Overload : Args... {
using Args::operator()...;
};

struct Nec{};
struct Erg{};
struct Tmr{};

int main()
{
using namespace std;

variant<int, double, float, Nec, Erg, Tmr> v;

auto f = Overload{
[](int) {return "int"; },
[](double) {return "double"; },
[](float) {return "float"; },
[](Nec) {return "nec"; },
[](Erg) {return "erg"; },
[](Tmr) {return "tmr"; },
};

cout << visit(f,v) << '\n';
v = 2.3f;
cout << visit(f,v) << '\n';
v = Nec{};
cout << visit(f,v) << '\n';
}

--------------------

fonksiyona birden fazla variantı argüman olarak gönderebiliriz

----------------------

using namespace std;

struct Visitor {

void operator()(const string&, int)
{
std::cout <<"string - int\n";
}

void operator()(int, double)
{
std::cout <<"int - double\n";
}

void operator()(int, float)
{
std::cout <<"int - float\n";
}

void operator()(double, int)
{
std::cout <<"double - int\n";
}

void operator()(float, double)
{
std::cout <<"float - double\n";
}

void operator()(auto x, auto y)
{
std::cout <<typeid(decltype(x)).name() << " - " << typeid(decltype(y)).name() << "\n";
}
};

sturct Nec {};

int main()
{
using namespace std;

variant<int, double, float, char> v1{4.5};
variant<float, int, char, Nec> v2{ Nec{} };

visit(Visiter{}, v1, v2);
}


--------------------------------------------
run time polymorfizi maaliyetli bir işlemdir
run time polymorifizinden kurtulmanın yolları vardır

variant kullanmak

---------------------
// burada maaliyetler var, virtual, kalırım vs.

// eğer pdf, excel gibi başka şeyler daha sonra eklemiycek isek bunlara closure hiyaraji
//genişlemeye kapalı

class Document {
public:
virtual void print() = 0;
virtual ~Document() = default;
};

class Pdf : public Document {
virtaul void print() override {std::cout << "Pdf::print()\n";}
};

class Excel : public Document {
virtaul void print() override {std::cout << "Excel::print()\n";}
};

class Word : public Document {
virtaul void print() override {std::cout << "Word::print()\n";}
};

class PowerPoint : public Document {
virtaul void print() override {std::cout << "Powerpoint::print()\n";}
};

void process(Document* p)
{
p->print();
}

int main()
{
auto *pdoc = new Excel{};

process(pdoc);
}

----------------
// 

class Document {

};

class Pdf : {

};

class Excel {

};

class Word {

};

class Word  {

};

using Document = std::variant<Pdf, Excel, Word, Powerpoint>;

struct PrintVisitor {
void operator()(Pdf x) {

}

void operator()(Excel x) {

}

void operator()(Word x) {
public:
void print
}

void operator()(Powerpoint x) {

}
};

int main()
{
Document x{Word{} };
visit(PrintVisitor{}, x);
}

=========================================================

any 
----

int main()
{
using namespace std;

any x1{23}; //int tutar
any x2{2.3}; //double tutar
any x3{"murathan"}; //const char* tutar
any x4{"murathan"s}; //std::string tutar
}

-------------------

int main()
{
using namespace std;

any x1;
any x2{};
any x3 =  {};
}

-----------------
any has_value fonksiyonu vardır
boş olup olmadığına bakılır

int main()
{
using namespace std;

any x;

if (x.has_value()) {
std::cout << "dolu\n";
}
else {
std::cout << "bos\n";
}
}

------------------
any türünden nesneye istediğim değeri atamaya type erasure deniyor

arka planda türün ne olduğunun sınanması type info ile yapılır
-----------------

//bu sınıfı nasıl implemente ederiz

any türünden nesneye istediğim değeri atamaya type erasure deniyor

int main()
{
using namespace std;

any x(10);

cout << x.type().name() << "\n";

x = 4.5;

cout << x.type().name() << "\n";

x = bitset<16>{};

cout << x.type().name() << "\n";
}

---------------

nec ise neci double ise doublı nasıl kullanırız
bunu any_cast ile yaparız

int main()
{
using namespace std;

any x(10);

cout << any_cast<int>(x) //ayn type'Ina bakar ve gerçekten o türden ise o türden değer verir tutmuyorsa exception throw eder

x =  "necati"s;

cout << ayn_cast<string>(x) << "\n";

x = bitset<16>(456u);

cout << any_cast<bitset<16>>(x) << "\n";
}

-------------------

int main()
{
using namespace std;

any x(10);

try {
cout << any_cast<double(x) << "\n";
}

castch (const std::bad_cast& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

//////////////////////////////////////// 3. Ders //////////////////////////////

any
----

any direk bir sınıftır optional ve variant sınıf şablonudur

any void pointera daha iyi bir alternatif olmak içindir

void pointer hangi türden nesne tuttuğunu bilemez ancak any herhangi bir türü tutabilir ve türü bilebilir daha akıllıdır

arka planda type info nesnesini kullanır

--------------------

int main()
{
using namespace std;

any a1;
any a2{};
any a3{"emracan"};
any a4{bitset<32>(67567u)};
any a5{vector<string>{}};
any a6 = vector<any>{};
}


------------------

int main()
{
using namespace std;

any a(45);

cout << a.type.name() << "\n";

if (a.type() == typeid(int)) { // bu şekilde sınama yapabiliriz

}
}

---------------------

int main()
{
using namespace std;

any a(45);
int& r = any_cast<int>(a); //any r value'dur burada hata olur

int& r = any_cast<int&>(a); //geçerli
}

----------------------

int main()
{
using namespace std;

any a(4.5);

try {
cout << any_cast<int>(a) << '\n'; //int yakalaması gerekir exception gönderirir
}
catch (const std::bad_any_cast& ex) {
//catch (const std::bad_cast& ex) {
//catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

-------------------

int main()
{
using namespace std;
 any a;

if (a.has_value()) { //bış ise 0 döndürecek

}
else {
std::cout << "deger tutmuyor\n";
}

a = "furkan";
}

----------------------

int main()
{
using namespace std;

any a;

if (a.type() == typeid(void)) 
std::cout << "bos\n";
else 
std::cout << "dolu\n";
}
}

-------------------------

int main()
{
using namespace std;

any a = "bugrahan serttas";

cout << (a.has_value() ? "dolu" : "bos") << '\n';

a.reset(); //boş hale getirir

cout << (a.has_value() ? "dolu" : "bos") << '\n';
}

--------------------

void* operator new(std::size_t n)
{
std::cout << "operator new called... n = " << n << '\n';
return std::malloc(n);
}

void operator delete(void* vp)
{
if (vp)
std::free(vp);
}

struct Nec {
unsigned char buffer[1024]{};
};

int main()
{
std::cout << "sizeof(any) = " << sizeof(any) << "\n";
std::cout << "sizeof(type_info) = " << sizeof(type_info) << "\n"; //buradan çıkan sonuçlar ile 28 bytle'Lık buffer kullanııyor deriz

any ax = 12;
ax = 4.5;
ax = bitset<128>{};

std::cout << "sizeof(Nec) = " << sizeof(Nec) << "\n";

ax = Nec{};
}

----------------
void* operator new(std::size_t n)
{
std::cout << "operator new called... n = " << n << '\n';
return std::malloc(n);
}

void operator delete(void* vp)
{
if (vp)
std::free(vp);
}

struct Nec {
unsigned char buffer[1024]{};
};

int main()
{
using namespace std;

int arr[10]{};

any a = arr;

std::cout << "sizeof(arr) = " << sizeof(arr) << "\n";

if (a.type() == typeid(int*)) {
std::cout << "pointer tutuyor\n";
}
else if (a.type() == typeid(int[100])) {
std::cout << "dizi tutuyor\n";
}
}

-------------------

int main()
{
using namespace std;

any a;

a = 4567;
a = Date{2,2,1982};
a.emplace<Date>(3,5,1987);
make_any<Date>(2,5,1987);
}

--------------------

using tvp = std::pair<std::string, std::any>;

int main()
{
using namespace std;

vector<tvp> vec;

vec.emplace_back("name", "bugrahan serttas"s); //emplace back consturctora gönderilecek argümanı ister
vec.emplace_back("birth_year", 1994);
vec.emplace_back("month", 13);
vec.emplace_back("price", 59.97);
vec.emplace_back("town", "mugla");
vec.emplace_back("gender", "male"s);

for (const auto&[property, value] : vec) {
if (value.type() == typeid(int)) {
cout << property << " " << any_cast<int>(value) << '\n';
}
else if (value.type() == typeid(string)) {
cout << property << " " << any_cast<string>(value) << '\n';
}
else if (value.type() == typeid(double)) {
cout << property << " " << any_cast<double>(value) << '\n';
}
}
}

------------------------

int main()
{
using namespace std;

vector<tvp> vec;

any ax{in_place_type<Date>,1,1,2024};
}

===============================================================

std::random
------------

#include <random>

true random generation : non-determenistik, ne olduğu daha önceden bilinemeyen

sudo (sözde) random generation : rastgele falan değil verdiğin inputlara bağlı algoritmak olarak üretim olur, deterministik yapıdadır 

hangi rastgele sayı üretimi olursa olsun tekrara düşücektir

en az 10-12 tan efarklı kriter var rastgele sayı üretiminde

mesela rastgele sayıların üretim hızı

--------

standart kütüphanenin random kütüphanesinde herkesin bilmesi gereken şeyle şunlar

1-birden fazla rastegele sayı üretisici veriyor
//URNG
//Uniform Random Number Generator
//1010010010111101010101010010
//0 - 4294...
//567097890

//distrubtion model

URNG bize uniform rastgele sayı veriyor ancak çok geniş bir aralıkta veriyor
çok  geniş vermesi iyi değil bu yüzden ekstra algoritmalar kullanırız

-kriptoloji tarafında standart kütüphane kullanıma uygun değil kriptoloji çok daha fazla şeyi desteklemesi gerekiyro


--------------

3 tane desteklenen algoritma vardır

-linear congruential 
-lagged fibonacci
-mersenne twister

---------------

int main()
{
using namespace std;
//çok sayıda template argümanı vardır
mersenne_twister_engine<unsigned int, 24u,1086, //bunlarla uğrasşmıyoruz

//bunlar yerine standart kütüphane tür eş bildirimleri ile bize bunları veriyor
}

--------------

int main()
{
using namespace std;

cout << typeid(mt19937).name() //bunu kullanırız mesela
}

-------------

int main()
{
using namespace std;

cout << typeid(minstd_rand).name() //bunu kullanırız mesela
}

-----------

hangi sınıfı kullanıcağımız birçok durumda önemli değildir

----------
#include <ostream>
#include <string>
#include <iomanip>
#include <random>

template<typename RG>
void print_engine_info(std::ostream& os, const std::string name)
{
os << std::left << std::setw(16) << name << " = " << typeid(RG).name() << '\n';
}

#include <iostream>

int main()
{
using namespace std;

print_engine_info<minstd_rand0>(cout, "minstd_rand0);
print_engine_info<minstd_rand>(cout, "minstd_rand);
print_engine_info<mt19937>(cout, "mt19937);
print_engine_info<mt19937_64>(cout, "mt19937_64);
print_engine_info<ranlux24>(cout, "ranlux24);
print_engine_info<ranlux24_base>(cout, "ranlux24_base);
print_engine_info<ranlux48_base>(cout, "ranlux48_base);

}

----------------

üretimde en çok kullanılan mt19937 olur

----------------

int main()
{
using namespace std;

// default_random_engine, mt19937 yerine kullanılabilir

cout << typeid(mt19937) == typeid(default_random_engine)) << '\n';

}

---------------

int main()
{
using namespace std;

mt19937 eng1; //default seed

for (int i = 0; i < 10; ++i) {
cout << eng() << "\n"; //bu değerler bir işimize yaramaz

}
}

---------------

int main()
{
using namespace std;

mt19937 eng1; //default seed

for (int i = 0; i < 10000 - 1; ++i) {
(void)eng();
}
cout << eng() << '\n'; //standart tüm kütüphanelerde bu sayı aynı olmaldıır
}

-------------------

int main()
{
using namespace std;

mt19937 eng{ 7612 };

eng.seed(8234u);
}

----------------

int main()
{
using namespace std;

mt19937 eng;

cout <<" min = " << mt19937::min() << '\n';
cout <<" max = " << mt19937::min() << '\n';
cout <<" default seed = " << mt19937::default_seed << '\n';

}

-----------------

discard fonksiyonu rastegele sayıyı döndürmeden onları atıyır

int main()
{
using namespace std;

mt19937 eng;
eng.discard(9999);
cout << eng() << "\n";
}

-----------------

int main()
{
using namespace std;

mt19937 eng{579981u};

for (int i = 0; i < 10; ++i) {
cout << enf() << "\n";
}

}

-----------------
//farklı tohum değerleri kullandığı iiçn farklı değerler gelicektir


int main()
{
using namespace std;

random_device rd;

for (int i = 0; i < 5; ++i) {
cout << rd() << '\n';
}
}

---------------

int main()
{
using namespace std;

random_device rd;

cout << rd.entropy() << "\n"; // true random generator değil ise 0 olur
//0 olsa idi deterministik olurdu
}

--------------
//mülakatlarda böyle yaz

int main()
{
using namespace std;

mt19937{random_device{}() }; 

for (int i = 0; i < 10; ++i) {
cout << eng() << "\n";
}
}

----------------

geçen zamanı tohum değeri olarak kullanmak da yaygın, geöen zamana endekslenmiş uapı

int main()
{
mt19937 eng{static_cast<unsigned>(std::chrono::steady_clock::now().time_since_epoch)().count())}; 

for (int i = 0; i < 5; ++i) {
std::cout << eng() << "\n";
}
}

------------------
mt19937 nesnelerinin kopyalanmasına izin vermemek gerekir
bu yüzden fonksiyonlara geçerken referans yapmak gerekir

void func(/**/std::mt19937 eng)
{

}

----------------

template <typename T>
void engine_test(const char *pname, T& eng)
{
	constexpr int n = 1'000'000;
	const auto tp_start = std::chrono::steady_clock::now();
	using namespace std::literals;
	int cnt{};
	while (std::chrono::steady_clock::now() - tp_start < 1s) { // 1 saniye geçinceye kadar olan döngü
		(void)eng();
		++cnt;
	}
	std::cout << pname << "    " << cnt << '\n';

}

int main()
{
	std::ranlux24 rn24;
	std::ranlux24_base rn24base;
	std::mt19937 mt19;
	std::minstd_rand mnrand;
	std::minstd_rand0 mnrand0;
	std::knuth_b knuth;

	engine_test("ranlux24", rn24);
	engine_test("ranlux24base", rn24base);
	engine_test("mt19937", mt19);
	engine_test("minstd_rand", mnrand);
	engine_test("minstd_rand0", mnrand0);
	engine_test("knuth_b", knuth);
}

----------------------

rastgele sayı üreticilerinin "state"'leri karşılaştırılabilir

int main()
{
using namespace std;

mt19937 e1(35);
mt19937 e2(35);

boolalpha(cout);

auto val = e1();
++val;

val = e2();

cout << "e1 == e2 : " << (e1 == e2) << '\n';
}

-----------------

int main()
{
	mt19937 eng{ 7654u };

	for (int i = 0; i < 10; ++i)
		cout << eng() << ' ';

	stringstream ss;
	ss << eng;

	cout << "\ndevam etmek icin bir tusa basin "; static_cast<void>(getchar());


	cout << "\n\n";

	for (int i = 0; i < 10; ++i)
		cout << eng() << ' ';

	cout << "\n\n";

	ss >> eng; //aynı state'e geri döndürdük yine aynı sayoları yazmasını bekleriz

	for (int i = 0; i < 10; ++i)
		cout << eng() << ' ';

	cout << "\n\n";
}

-----------------------

rasgele sayı üretileri bir state bilgisine sahip o state'i bir stream'e yazabiliyorum
stream'den extrac edip tekrar o state'e getebiliyorum, ve bu statei başka state'ler ile karşılaştırabiliyorum

---------------------------------

birkaç tane distrubion sınıfına bakıyourz

eğer bir tam sayı aralığında uniform dağılmış rastgele sayılar istiyorsak  uniform_int_distribution</**/> //kullanıcağız

int main()
{
using namespace std;

mt19937 eng;

uniform_int_distribution<int> dist{10, 14}; //10-14 aralığında 10 ve 14 dahil rastgele bir sayı

dist(eng)
}

------------------

int main()
{
using namespace std;

mt19937 eng;

uniform_int_distribution<> dist; //default int parametresini alır

dist(eng)
}

-------------------

int main()
{
using namespace std;

map<int, int> cmap;

mt19937 eng;
uniform_int_distribution dist{0, 20};

for (int i = 0; i < 20'000'000; ++i) {
++cmap[dist(eng)];
}

for (const auto[val, cnt] : cmap) {
cout << val << " " << cnt << '\n';
}
}

---------------------

int main()
{
using namespace std;

mt19937 eng;

uniform_real_distribution dist{5.6, 6.1};

cout << fixed << setprecision(6);

for (int i = 0; i < 100; ++i) {
cout << dist(eng) << "\n";
}

}

----------------------

int main()
{
using namespace std;

uniform_real_distribution dist{5.6, 5.8};

cout << dist.a() << "\n"; //1.
cout << dist.b() << "\n"; //2.
}

---------------------
normal dağılım

int main()
{
using namespace std;

mt19937 eng;

normal_distribution<double> dist(50, 5.);

map<int, int> cmap;

for (int = 0; i < 1'000'000; ++i) {
++cmap[static_cast<int>(round(dist(eng))];
}

std::ofstream ofs{ "out.txt"};
if (!ofs) {
std::cerr << "out.txt dosyasi olusturulmadi\n";
exit(EXIT_FAILURE);
}

ofs << left;

for (const auto [value, count] : cmap) {
ofs << setw(6) << value << string(count / 1000, '*') << '\n';
}
}

--------------------

int main()
{
using namespace std;

mt19937 eng(762143);

uniform_int_distribution dist(1000, 5000); //uniform_int_distribution için aynı sayıların çıkma garantisi yoktur

for (int i = 0; i < 10; ++i) {
cout << eng() << '\n';
}
}

----------------------

oyun programlarında çok ihtiyaç duyulan distributionlar

int main()
{
using namespace std;

mt19937 eng;
//                         0    1   2   3  4   5
discrete_disribution dist {10, 10, 10, 10,10, 11};

for (int i = 0; i < 10; ++i) {
cout << dist(eng) << '\n';
}
}

---------------

int main()
{
using namespace std;

mt19937 eng;
discrete_disribution dist {10, 10, 10, 10,10, 11};
//6. hileli
//discrete_disribution dist {0,10, 10.1, 10.2, 10.3,10.4, 10.5};
//                             . burası / hepsinin toplamı
map<int,int> cmap;

for (int i = 0; i < 6'000'000; ++i) {
++cmap[dist(eng)];
}

for (const auto [value, count] : cmap) {
cout << value << " " << count << '\n';
}
}

---------------

