///////////////////////////////////////////////// 1. Ders ////////////////////////////////////////////////

int main()
{
using namespace std;
using namespace std::chrono;

system_clock::now(); //time point döndürü

system:clock::now().time_since_epoch(); //duration döndürür

system:clock::now().time_since_epoch().count; //representatation türünden olur

duration_cast<milliseconds>(system_clokc::now().time_since_epoch()).count()  
}

-----------------

int main()
{
using namespace std;
using namespace std::chrono;

system_clock::to_time_t(); //time point ister bunu c'deki time pointe dönüştürür
system_clock::from_time_t(); //

}

----------------------

int main()
{
using namespace std;
using namespace std::chrono;

time_t tx{1'600'000'000 };
auto tp = system_clock::from_time_t(tx);
}

-----------------------

int main()
{
using namespace std;
using namespace std::chrono;

auto tp = system_clock::now;

time_t tx = system_clock::to_time_t(tp);

cout << ctime(&tx) << '\n';
}

------------------------

int main()
{
using namespace std;
using namespace std::chrono;

days ondeay{ 1 };

auto tp_today = system_clock::now();

auto tp_tomorrow = tp_today + oneday;

time_t t1 = system_clock::to_time_t(tp_today);
time_t t2 = system_clock::to_time_t(tp_tomorrow);
cout << ctime(&t1) << "\n";
cout << ctime(&t2) << "\n";
 
}

------------------------

print_time kodunu incele kod visual stdiooda

------------------------

=======================================================================

Vocabulary Types 
----------------

std::optional 
std::variant
std::any

hepsi c++ 17 ile geldi

------------------------

std::optional
--------------
Belirli bir türden ya bir değere sahip ya da değil, 
bir optional nesnesi 2 state'den birinde olabilir

A - bir değeri var
B - bir değeri yok


std::variant
------------
Bir union
Ya int tutucak ya string tutucak vs.
n tane farklı türden değer tutmak istersek variant kullanırız


std::any
--------
herhangi bir türden değer tutmak için yapılır

---------------------

#include <optional>
#include <string>
#include "date.h"

using namespace std;

int main()
{

optional<int> x;

if (x) {
std::cout << "dolu bir degere sahip\n";
}
else {
std::cout << "bos bir degere sahip \n";
}
}

----------------

using namespace std;

int main()
{
optional<int> x{ 678 };

if (x) {
std::cout << "dolu bir degere sahip\n";
}
else {
std::cout << "bos bir degere sahip degil\n";
}
}

---------------

using namespace std;

int main()
{
optional<int> x{ 678 };

cout << "x= " << (x ? "dolu" : "bos") << "\n";
}

--------------

bir contructor daha var, nullopt

int main()
{
optional<int> x{nullopt};

cout << "x = " << (x ? "dolu" : "bos") << "\n";
}

--------------

int main()
{
using namespace std;

optional<int> x = 10;
optional y = 10; //ikisi arasında fark yok ctad
}

---------------
//mülakatlarda gelir

int main()
{
using namespace std;

optional<int> x1; //bos
optional<int> x2{}; //bos
optional<int> x3{nullopt}; //bos
optional<int> x4(); //x4 optinol nesnesi değil fonksiyon bildirimi

if (!(x1 && x2 && x3)) {
std::cout << "hepimiz bombosuz\n";
}
}

----------------

int main()
{
using namespace std;

optional<int> x;

if (x){} //aynı anlamda
if (x.operator bool ()){} //aynı anlamda
if (x.has_value){} //aynı anlamda

}

----------------

int main()
{
using namespace std;

optional x(3456);

cout << *x << "\n";
*x = 6787;
cout << *x << "\n";
}

-------------------

int main()
{
using namespace std;

optional<string> osx{ "naci cemal" };

cout << *osx << '\n';

cout << "uzunluk = " << osx->lenght() << '\n';

*osx += " dagdalen";

cout << *osx << "\n";
}

-------------------

int main()
{
using namespace std;

optional<string> os;

try {
cout << *os << "\n";
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n'; //ub döndürür kod boş
}
}

---------------------

//yukarıdaki durumun önüne geçmek için

int main()
{
using namespace std;

optional<string> os;

if (os != nullopt) { //yapılır
cout << *os << "\n";
}
}

-------------------

//value fonksiyonu da kullanılabilir

int main()
{
using namespace std;

optional<string> os;

try {
cout << os.value() << "\n";
}
catch (const std::bad_optional_access& ex) {
std::cout << "exception caught: " << ex.what() << '\n'; //ub döndürür kod boş
}
}

--------------------

int main()
{
using namespace std;

optional<string> os{"bugra"};

cout << *os << "\n";
cout << os.value() << "\n";

os.value() += "sentoregil";
}

------------------
3 fonksiyonu vardır optional'ın

ox.operator*

ox.value

ox.value_or

---------------------

ilginç ve karmaşık bir fonksiyon daha var
ox.value_or

int main()
{
using namespace std;

optional<string> os{ "furkan mert" };

cout << os.value_or("noname") << "\n"; 

os = {}; //optional boş hale geldi

cout << os.value_or("noname") << "\n";  //noname yazar
}

------------------

int main()
{
using namespace std;

optional<int> os(456);

os.value_or(457) = //hata

}

--------------------

void print_e_mail(const std::optional<std::string>& op)
{

}

int main()
{
print_e_mail("necati ergin");

print_e_mail(std::nullopt);
print_e_mail({});
print_e_mail(optinal<string>{}; //hepsi  ben bir değer göndermiyorum anlamında
}

------------------

class Person {

private:

std::optional<string> m_middle_name;
};

void print_e_mail(const std::optional<std::string>& op)
{

}

int main()
{

}

---------------
//value or olmasaydı aşağıdaki yapı kulllanırdık

void print_e_mail(const std::optional<std::string>& op)
{
if (op) {

}
else {

}
}

int main()
{

}

----------------

void print_e_mail(const std::optional<std::string>& op)
{
std::cout < "e-posta adresi : " << op.value_or("yok") << "\n";
}

int main()
{

}

------------

class Record {
public:
Record(const std::string& nmake, std::optional<string>nick, std::optional<int> age) :
m_name(name), m_nick(nick), m_age(age) {}

private:
std::string m_name;
std::optional<std::string> mnic;
std::optinal<int> m_age;
};

int main()
{
Record r1{ "bugra serttas", "speedy coder", 23};
Record r1{ "bugra serttas", {}, nullopt}; //bu şekilde de olur
}

-------------

optional şöyle tarif ediyorlar 

sana bir bardak veriyorum bu bardağı boşda verebiliriim doluda

--------------
//string'İn inte dönüştürücek

stoi(s) //aldığı stringi inte dönüştürür, ancak string geçerli değil ise exception döndürür ancak ben bunu istemiyorum
//return std::nullopt;
//return {}; //bu da olur

std::optional<int>
to_int(const std::string& s)
{
try {
return stoi(s);
}
catch(...) {
return {};
}
}

--------------

//aşağıdaki şekilde de olabilirdi

std::optional<int>
to_int(const std::string& s)
{
std::optional<int> ret;

try {
return stoi(s);
}
catch(...) {
return std::nullopt;
}
}

----------------

//aşağıdaki şekilde de olabilirdi

std::optional<int>
to_int(const std::string& s)
{
std::optional<int> ret;

try {
return stoi(s);
}
catch(...) {
return ret;
}

int main()
{
using namespace std;

auto op = to_int("78788");

if (op)
cout << *op << "\n";
else 
cout << "gecersiz tam sayi";
}

------------------

// tuttupu değerlerin detroy edildiği duurumlarda var

class A {
~A() {std::cout << "~A() this: " << this << '\n'; }
A() {std::cout << "A() this: " << this << '\n'; }
A(int) {std::cout << "A(int) this: " << this << '\n'; }
A(int, int) {std::cout << "A(int, int) this: " << this << '\n'; }
A(std::string) {std::cout << "A(string) this: " << this << '\n'; }
};

int main()
{
using namespace std;

optional<A> ox;
ox.emplace(45, 67); //default ctor çağrılır
ox.emplace(78,98);
ox.emplace(45.5);
ox.emplace("furkan");
}

-----------------------

class A {
~A() {std::cout << "~A() this: " << this << '\n'; }
A() {std::cout << "A() this: " << this << '\n'; }
A(int) {std::cout << "A(int) this: " << this << '\n'; }
A(int, int) {std::cout << "A(int, int) this: " << this << '\n'; }
A(std::string) {std::cout << "A(string) this: " << this << '\n'; }
};

int main()
{
using namespace std;

optional<A> x;

x = 5; //legal

for (int i = 0; i < 10; ++i) {
x.emplace(i);
}
}

----------------

int main()
{
using namespace std;

Date mydate{3, 6, 1981};

optional<Date> ox(mydate); //copy ctor çağrılacak, move aparsam move ctor
}

--------------

int main()
{
using namespace std;

optional<Date> ox(4,5 1987); //böyle bir sey yok bu temlate'ler ile ilgili temel bir problem

//bunu aşmak için aşağıdaki hile yapılır

}

--------------

int main()
{
using namespace std;

optional<Date> ox(in_place, 4, 5, 1987);

cout << *ox << "\n";
}

---------------

int main()
{
using namespace std;

optional<Date> ox{ in_place, 10, 'A' };

cout << *ox << "\n";
ox.emplace(20, 'b');
cout << *ox << "\n";
}

------------------

int main()
{
using namespace std;

optional<string> o1(in_place, 20, 'X');
auto o2 = make_optional<string>(10, 'Y');
auto o3 = make_optional<Date>(2,5,1995);

cout << *o1 << "\n";
cout << *o2 << "\n";
cout << *o3 << "\n";

}

-------------------

class Myclass {
public:
Myclass();
Myclass(int);
Myclass(int, int);
Myclass(const Myclass&) = delete;
Myclass& operator=(const Myclass&) = delete;
};

int main()
{
using namespace std;

Myclass m1; //legal
Myclass m2(12); //legal
Myclass m3(12, 57); //lwgal

auto m4 = m1; //hata
auto m4 = move(m1); //hata
}

--------------------

class Myclass {
public:
Myclass();
Myclass(int);
Myclass(int, int);
Myclass(const Myclass&) = delete;
Myclass& operator=(const Myclass&) = delete;
};

int main()
{
using namespace std;

Myclass m1;
Myclass m2(12);

optional<Myclass> ox(in_place, 3, 5); //legal
optional<Myclass> ox(in_place); //legal

ox.emplace(34);
ox.emplace();
}

------------------------

optional<Myclass> x(in_place,1,4,5); //buradaki implace back fonksiyonunu functionu ayırıcı olarak kullanıp bundan sondan gelenleri ilgili fonksiyona koyabilirim

make_optional<Myclass>(1,4,5); //bu şekilde de yapılabilir

-----------------------

class Myclass {
int x{};
int y{};

};

int main()
{
std::cout << "sizeof(Myclass) = " << sizeof(Myclass) << "\n";
std::cout << "sizeof(optional<Myclass>) = " << sizeof(optional<Myclass>) << "\n";

}

----------------

template <std::size_t n>
struct Myclass {

char buf[n]{};
};

template <size_t n>
using otype = optional<Myclass<n>>; //alias template

int main()
{
otype<10>
std::optional<Myclass<10> //aynı anlamda alias template sayesinde
}

------------------

int main()
{
using namespace std;

string name{"mustafa"};

optional x = name;
optional x = ref(name);

(*x).get() = "salih";
x->get() = "tunahan"; //aynı anlamda

cout << "name = " << name << '\n';
}

----------------------

optional nesnelerini karşılaştırma operatörünün operandı yapabiliyoruz

int main()
{
using namespace std;

optional x = 5;
optional y = 123;

boolalpha(cout);

cout << (x == y) << "\n";
cout << (x != y) << "\n";
cout << (x < y) << "\n";
}

----------------

int main()
{
using namespace std;

optional<int> x;
optional y = 123;

boolalpha(cout);

cout << (x < y) << "\n";
cout << (x != y) << "\n";
}

--------------------

int main()
{
using namespace std;

optional<bool> x;
optional<bool> y(false);

cout << boolalpha;

cout << (x == true) << "\n";
cout << (x == false) << "\n";
cout << (x == nullopt) << "\n";
cout << (x < false) << "\n";
}


=================================================================

variant : aslında bellek alanı var o bellekte nesneyi tutacak ancak compile time'da o bellek alanında hangi argümanların tutulabileceği template argümanlarıyla belirlenecek
---------

#include <variant>

union Nec {
int x;
double dval;
//
};

int main()
{

}

---------------

using namespace std;

int main()
{
variant<int, double, long, char> x;
}

------------------

default init edilebiliyor

using namespace std;

int main()
{
variant<int, double, long, char> x;

// x'İ kullansak türü int olucak, ilk alternatifi tutar
}

----------------------
using namespace std;

int main()
{
variant<int, double, long, char> x;

cout << x.index() << "\n"; //tutuğı indexi tutar
}

-------------------

int main()
{
variant<string, double, long, char> x(4.5);

cout << x.index() << "\n"; //1 olucak
}

-------------------

int main()
{
variant<string, double, long, char> x(4.5);

x = 3.4;

cout << x.index() << "\n"; 

x = 34;

cout << x.index() << "\n"; 
}

-----------------

bir yolu daha vardır

int main()
{
variant<string, double, long, char> x;

cout << x.index() << "\n"; 

if (holds_alternative<int>(x)) { //if tutuyorsa doğru kısma giricek

}
}

------------------

int main()
{
variant<string, double, long, char> x{57}; //double yapıp dene

cout << x.index() << "\n"; 

if (holds_alternative<int>(x)) { 
cout << "evet int tutuyor\n";
}
if (x.index() == 2) { 
cout << "evet int tutuyor\n";
}
}

------------------

using namespace std;

int main()
{
using namespace std;

variant<int, double, int> x;

cout << get<0>(x) << "\n";

variant<string, double, int> y;
}

----------------------

int main()
{
variant<string, double, int> x{3.47};

cout << get<1>(x) << "\n";
get<1>(x) = 965.46;

x = "mustafa";

x += "mustafa; //hatalı

get<0>(x) += " can"; //bu şekilde olur
}

----------------------

int main()
{
variant<string, double, int> x{3.47};

get<double>(x);
}

----------------

özetlersek

variant tuttuğu değere 2 şekilde erişebilirim

get fonksiyon şablonu ama nontype parametre ile
get<0>(x)

get fonksiyon şablonu ama tür parametresi ile
get<double>(x)

----------------

int main()
{
variant<string, double, int> x{3.47}; 

get<3> x; //sentax hatası
get<long> x; //hata
}

-----------------

int main()
{
variant<string, double, int> x{3.47};  //default etmezsek seçim yapıyor

try {
auto val = get<2>(x);
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

-------------------

int main()
{
variant<int, double, long> x('A'); //hata yok char'dan inte dönüşüm var

cout << "x.index() " << x.index() << '\n';

}

----------------

int main()
{
variant<int, Date, string> x{12, 5, 1987};  //burada fonksiyo date nesnesine erişiceğini anlamaz
//bunun yerine tag nesnesi kullanmamız lazım

variant<int, Date, string> x(in_place_type<Date>, 2,5,1987);

cout << get<1>(x) << "\n";

x.emplace<string>(10, 'a');
cout << get<2>(x) << "\n";
}

---------------

class A {
public:
A(int);
};

class B {
public:
B(double);
};

class C {
public:
C(int);
};

int main()
{
using namespace std;

variant<A, B, C> vx;

//bazen variant'I hiçbir değer tutmuyor durumunda tutmak istiyouz
//bunu aşmak için monostate kullanırız

variant<monostate, int, double, long> x

cout << x.index() < "\n";

cout << boolalpha << hold_alternative<monostate> << "\n";
}

------------------

int main()
{
using namespace std;

variant<int, double, long> x(2.3);

get_if<int>(&x) //geri dönüş değeri adres ancak get tutmuyorsa nullptr

if (int *ptr = get_if<int>(&x)) {
cout << ğptr << "\n";
}
}

/////////////////////////////////////// 2. Ders /////////////////////////////


//dk.45 devam

using namespace std;

template <typename ...Args>
struct Overload : Args... {
using Args::operator()...;
};

struct Nec{};
struct Erg{};
struct Tmr{};

int main()
{
using namespace std;

variant<int, double, float, Nec, Erg, Tmr> v;

auto f = Overload{
[](int) {return "int"; },
[](double) {return "double"; },
[](float) {return "float"; },
[](Nec) {return "nec"; },
[](Erg) {return "erg"; },
[](Tmr) {return "tmr"; },
};

cout << visit(f,v) << '\n';
v = 2.3f;
cout << visit(f,v) << '\n';
v = Nec{};
cout << visit(f,v) << '\n';
}

----------------------

using namespace std;

struct Visitor {

void operator()(const string&, int)
{
std::cout <<"string - int\n";
}

void operator()(int, double)
{
std::cout <<"int - double\n";
}

void operator()(int, float)
{
std::cout <<"int - float\n";
}


void operator()(double, int)
{
std::cout <<"double - int\n";
}

void operator()(float, double)
{
std::cout <<"float - double\n";
}

void operator()(auto x, auto y)
{
std::cout <<typeid(decltype(x)).name() << " - " << typeid(decltype(y)).name() << "\n";
}
};

sturct Nec {};

int main()
{
using namespace std;

variant<int, double, float, char> v1{4.5};
variant<float, int, char, Nec> v2{ Nec{} };

visit(Visiter{}, v1, v2);
}


--------------------------------------------

run time polymorifizinden kurtulmanın yolları vardır

variant kullanmak

---------------------
// burada maaliyetler var, virtual, kalırım vs.

// eğer pdf, excel gibi başak şeyler daha sonra eklemiycek isek bunlara closure hiyaraji

class Document {
public:
virtual void print() = 0;
virtual ~Document() = default;
};

class Pdf : public Document {
virtaul void print() override {std::cout << "Pdf::print()\n";}
};

class Excel : public Document {
virtaul void print() override {std::cout << "Excel::print()\n";}
};

class Word : public Document {
virtaul void print() override {std::cout << "Word::print()\n";}
};

class Word : public Document {
virtaul void print() override {std::cout << "Powerpoint::print()\n";}
};

void process(Document* p)
{
p->print();
}

int main()
{
auto *pdoc = new Excel{};

process(pdoc);
}

----------------
// 

class Document {

};

class Pdf : {

};

class Excel {

};

class Word {

};

class Word  {

};

using Document = std::variant<Pdf, Excel, Word, Powerpoint>;

sturct PrintVisitor {
void operator()(Pdf x) {

}

void operator()(Excel x) {

}

void operator()(Word x) {
public:
void print
}

void operator()(Powerpoint x) {

}
};

int main()
{
Document x{Word{} };
visit(PrintVisitor{}, x);
}

=========================================================

any 

int main()
{
using namespace std;

any x1{23}; //int
any x2{2.3}; //double
any x3{"murathan"}; //const char* 
any x4{"murathan"s}; //std::string
}

-------------------

int main()
{
using namespace std;

any x1;
any x2{};
any x3 =  {};
}

-----------------

int main()
{
using namespace std;

any x;

if (x.has_value()) {
std::cout << "dolu\n";
}
else {
std::cout << "bos\n";
}
}

-----------------

//bu sınıfı nasıl implemente ederiz

any türünden nesneye istediğim değeri atamaya type erasure deniyor

int main()
{
using namespace std;

any x(10);

cout << x.type().name() << "\n";

x = 4.5;

cout << x.type().name() << "\n";

x = bitset<16>{};
cout << x.type().name() << "\n";
}

---------------

nec ise neci double ise doublı nasıl kullanırız

any_cast ile

int main()
{
using namespace std;

any x(10);

cout << any_cast<int>(x) //ayn type'Ina bakar ve gerçekten o tğrden ise o tğrden değer verir tutmuyorsa exception throw eder

x =  "necati"s;

cout << ayn_cast<string>(x) << "\n";

x = bitset<16>(456u);

cout << any_cast<bitset<16>>(x) << "\n";
}

-------------------

int main()
{
using namespace std;

any x(10);

try {
cout << any_cast<double(x) << "\n";
}

castch (const std::bad_cast& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}







