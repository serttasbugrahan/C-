///////////////////////////////////////////////// 1. Ders ////////////////////////////////////////////////

int main()
{
using namespace std;
using namespace std::chrono;

system_clock::now(); //time point döndürü

system:clock::now().time_since_epoch(); //duration döndürür

system:clock::now().time_since_epoch().count; //representatation türünden olur

duration_cast<milliseconds>(system_clokc::now().time_since_epoch()).count()  
}

-----------------

int main()
{
using namespace std;
using namespace std::chrono;

system_clock::to_time_t(); //time point ister bunu c'deki time pointe dönüştürür
system_clock::from_time_t(); //

}

----------------------

int main()
{
using namespace std;
using namespace std::chrono;

time_t tx{1'600'000'000 };
auto tp = system_clock::from_time_t(tx);
}

-----------------------

int main()
{
using namespace std;
using namespace std::chrono;

auto tp = system_clock::now;

time_t tx = system_clock::to_time_t(tp);

cout << ctime(&tx) << '\n';
}

------------------------

int main()
{
using namespace std;
using namespace std::chrono;

days ondeay{ 1 };

auto tp_today = system_clock::now();

auto tp_tomorrow = tp_today + oneday;

time_t t1 = system_clock::to_time_t(tp_today);
time_t t2 = system_clock::to_time_t(tp_tomorrow);
cout << ctime(&t1) << "\n";
cout << ctime(&t2) << "\n";
 
}

------------------------

print_time kodunu incele kod visual stdiooda

------------------------

=======================================================================

Vocabulary Types 
----------------

std::optional 
std::variant
std::any

hepsi c++ 17 ile geldi

------------------------

std::optional
--------------
Belirli bir türden ya bir değere sahip ya da değil, 
bir optional nesnesi 2 state'den birinde olabilir

A - bir değeri var
B - bir değeri yok


std::variant
------------
Bir union
Ya int tutucak ya string tutucak vs.
n tane farklı türden değer tutmak istersek variant kullanırız


std::any
--------
herhangi bir türden değer tutmak için yapılır

---------------------

#include <optional>
#include <string>
#include "date.h"

using namespace std;

int main()
{

optional<int> x;

if (x) {
std::cout << "dolu bir degere sahip\n";
}
else {
std::cout << "bos bir degere sahip \n";
}
}

----------------

using namespace std;

int main()
{
optional<int> x{ 678 };

if (x) {
std::cout << "dolu bir degere sahip\n";
}
else {
std::cout << "bos bir degere sahip degil\n";
}
}

---------------

using namespace std;

int main()
{
optional<int> x{ 678 };

cout << "x= " << (x ? "dolu" : "bos") << "\n";
}

--------------

bir contructor daha var, nullopt

int main()
{
optional<int> x{nullopt};

cout << "x = " << (x ? "dolu" : "bos") << "\n";
}

--------------

int main()
{
using namespace std;

optional<int> x = 10;
optional y = 10; //ikisi arasında fark yok ctad
}

---------------
//mülakatlarda gelir

int main()
{
using namespace std;

optional<int> x1; //bos
optional<int> x2{}; //bos
optional<int> x3{nullopt}; //bos
optional<int> x4(); //x4 optinol nesnesi değil fonksiyon bildirimi

if (!(x1 && x2 && x3)) {
std::cout << "hepimiz bombosuz\n";
}
}

----------------

int main()
{
using namespace std;

optional<int> x;

if (x){} //aynı anlamda
if (x.operator bool ()){} //aynı anlamda
if (x.has_value){} //aynı anlamda

}

----------------

int main()
{
using namespace std;

optional x(3456);

cout << *x << "\n";
*x = 6787;
cout << *x << "\n";
}

-------------------

int main()
{
using namespace std;

optional<string> osx{ "naci cemal" };

cout << *osx << '\n';

cout << "uzunluk = " << osx->lenght() << '\n';

*osx += " dagdalen";

cout << *osx << "\n";
}

-------------------

int main()
{
using namespace std;

optional<string> os;

try {
cout << *os << "\n";
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n'; //ub döndürür kod boş
}
}

---------------------

//yukarıdaki durumun önüne geçmek için

int main()
{
using namespace std;

optional<string> os;

if (os != nullopt) { //yapılır
cout << *os << "\n";
}
}

-------------------

//value fonksiyonu da kullanılabilir

int main()
{
using namespace std;

optional<string> os;

try {
cout << os.value() << "\n";
}
catch (const std::bad_optional_access& ex) {
std::cout << "exception caught: " << ex.what() << '\n'; //ub döndürür kod boş
}
}

--------------------

int main()
{
using namespace std;

optional<string> os{"bugra"};

cout << *os << "\n";
cout << os.value() << "\n";

os.value() += "sentoregil";
}

------------------
3 fonksiyonu vardır optional'ın

ox.operator*

ox.value

ox.value_or

---------------------

ilginç ve karmaşık bir fonksiyon daha var
ox.value_or

int main()
{
using namespace std;

optional<string> os{ "furkan mert" };

cout << os.value_or("noname") << "\n"; 

os = {}; //optional boş hale geldi

cout << os.value_or("noname") << "\n";  //noname yazar
}

------------------

int main()
{
using namespace std;

optional<int> os(456);

os.value_or(457) = //hata

}

--------------------

void print_e_mail(const std::optional<std::string>& op)
{

}

int main()
{
print_e_mail("necati ergin");

print_e_mail(std::nullopt);
print_e_mail({});
print_e_mail(optinal<string>{}; //hepsi  ben bir değer göndermiyorum anlamında
}

------------------

class Person {

private:

std::optional<string> m_middle_name;
};

void print_e_mail(const std::optional<std::string>& op)
{

}

int main()
{

}

---------------
//value or olmasaydı aşağıdaki yapı kulllanırdık

void print_e_mail(const std::optional<std::string>& op)
{
if (op) {

}
else {

}
}

int main()
{

}

----------------

void print_e_mail(const std::optional<std::string>& op)
{
std::cout < "e-posta adresi : " << op.value_or("yok") << "\n";
}

int main()
{

}

------------

class Record {
public:
Record(const std::string& nmake, std::optional<string>nick, std::optional<int> age) :
m_name(name), m_nick(nick), m_age(age) {}

private:
std::string m_name;
std::optional<std::string> mnic;
std::optinal<int> m_age;
};

int main()
{
Record r1{ "bugra serttas", "speedy coder", 23};
Record r1{ "bugra serttas", {}, nullopt}; //bu şekilde de olur
}

-------------

optional şöyle tarif ediyorlar 

sana bir bardak veriyorum bu bardağı boşda verebiliriim doluda

--------------
//string'İn inte dönüştürücek

stoi(s) //aldığı stringi inte dönüştürür, ancak string geçerli değil ise exception döndürür ancak ben bunu istemiyorum
//return std::nullopt;
//return {}; //bu da olur

std::optional<int>
to_int(const std::string& s)
{
try {
return stoi(s);
}
catch(...) {
return {};
}
}

--------------

//aşağıdaki şekilde de olabilirdi

std::optional<int>
to_int(const std::string& s)
{
std::optional<int> ret;

try {
return stoi(s);
}
catch(...) {
return std::nullopt;
}
}

----------------

//aşağıdaki şekilde de olabilirdi

std::optional<int>
to_int(const std::string& s)
{
std::optional<int> ret;

try {
return stoi(s);
}
catch(...) {
return ret;
}

int main()
{
using namespace std;

auto op = to_int("78788");

if (op)
cout << *op << "\n";
else 
cout << "gecersiz tam sayi";
}

------------------

// tuttupu değerlerin detroy edildiği duurumlarda var

class A {
~A() {std::cout << "~A() this: " << this << '\n'; }
A() {std::cout << "A() this: " << this << '\n'; }
A(int) {std::cout << "A(int) this: " << this << '\n'; }
A(int, int) {std::cout << "A(int, int) this: " << this << '\n'; }
A(std::string) {std::cout << "A(string) this: " << this << '\n'; }
};

int main()
{
using namespace std;

optional<A> ox;
ox.emplace(45, 67); //default ctor çağrılır
ox.emplace(78,98);
ox.emplace(45.5);
ox.emplace("furkan");
}

-----------------------

class A {
~A() {std::cout << "~A() this: " << this << '\n'; }
A() {std::cout << "A() this: " << this << '\n'; }
A(int) {std::cout << "A(int) this: " << this << '\n'; }
A(int, int) {std::cout << "A(int, int) this: " << this << '\n'; }
A(std::string) {std::cout << "A(string) this: " << this << '\n'; }
};

int main()
{
using namespace std;

optional<A> x;

x = 5; //legal

for (int i = 0; i < 10; ++i) {
x.emplace(i);
}
}

----------------

int main()
{
using namespace std;

Date mydate{3, 6, 1981};

optional<Date> ox(mydate); //copy ctor çağrılacak, move aparsam move ctor
}

--------------

int main()
{
using namespace std;

optional<Date> ox(4,5 1987); //böyle bir sey yok bu temlate'ler ile ilgili temel bir problem

//bunu aşmak için aşağıdaki hile yapılır

}

--------------

int main()
{
using namespace std;

optional<Date> ox(in_place, 4, 5, 1987);

cout << *ox << "\n";
}

---------------

int main()
{
using namespace std;

optional<Date> ox{ in_place, 10, 'A' };

cout << *ox << "\n";
ox.emplace(20, 'b');
cout << *ox << "\n";
}

------------------

int main()
{
using namespace std;

optional<string> o1(in_place, 20, 'X');
auto o2 = make_optional<string>(10, 'Y');
auto o3 = make_optional<Date>(2,5,1995);

cout << *o1 << "\n";
cout << *o2 << "\n";
cout << *o3 << "\n";

}

-------------------

class Myclass {
public:
Myclass();
Myclass(int);
Myclass(int, int);
Myclass(const Myclass&) = delete;
Myclass& operator=(const Myclass&) = delete;
};

int main()
{
using namespace std;

Myclass m1; //legal
Myclass m2(12); //legal
Myclass m3(12, 57); //lwgal

auto m4 = m1; //hata
auto m4 = move(m1); //hata
}

--------------------

class Myclass {
public:
Myclass();
Myclass(int);
Myclass(int, int);
Myclass(const Myclass&) = delete;
Myclass& operator=(const Myclass&) = delete;
};

int main()
{
using namespace std;

Myclass m1;
Myclass m2(12);

optional<Myclass> ox(in_place, 3, 5); //legal
optional<Myclass> ox(in_place); //legal

ox.emplace(34);
ox.emplace();
}

------------------------

optional<Myclass> x(in_place,1,4,5); //buradaki implace back fonksiyonunu functionu ayırıcı olarak kullanıp bundan sondan gelenleri ilgili fonksiyona koyabilirim

make_optional<Myclass>(1,4,5); //bu şekilde de yapılabilir

-----------------------

class Myclass {
int x{};
int y{};

};

int main()
{
std::cout << "sizeof(Myclass) = " << sizeof(Myclass) << "\n";
std::cout << "sizeof(optional<Myclass>) = " << sizeof(optional<Myclass>) << "\n";

}

----------------

template <std::size_t n>
struct Myclass {

char buf[n]{};
};

template <size_t n>
using otype = optional<Myclass<n>>; //alias template

int main()
{
otype<10>
std::optional<Myclass<10> //aynı anlamda alias template sayesinde
}

------------------

int main()
{
using namespace std;

string name{"mustafa"};

optional x = name;
optional x = ref(name);

(*x).get() = "salih";
x->get() = "tunahan"; //aynı anlamda

cout << "name = " << name << '\n';
}

----------------------

optional nesnelerini karşılaştırma operatörünün operandı yapabiliyoruz

int main()
{
using namespace std;

optional x = 5;
optional y = 123;

boolalpha(cout);

cout << (x == y) << "\n";
cout << (x != y) << "\n";
cout << (x < y) << "\n";
}

----------------

int main()
{
using namespace std;

optional<int> x;
optional y = 123;

boolalpha(cout);

cout << (x < y) << "\n";
cout << (x != y) << "\n";
}

--------------------

int main()
{
using namespace std;

optional<bool> x;
optional<bool> y(false);

cout << boolalpha;

cout << (x == true) << "\n";
cout << (x == false) << "\n";
cout << (x == nullopt) << "\n";
cout << (x < false) << "\n";
}


=================================================================

variant : aslında bellek alanı var o bellekte nesneyi tutacak ancak compile time'da o bellek alanında hangi argümanların tutulabileceği template argümanlarıyla belirlenecek
---------

#include <variant>

union Nec {
int x;
double dval;
//
};

int main()
{

}

---------------

using namespace std;

int main()
{
variant<int, double, long, char> x;
}

------------------

default init edilebiliyor

using namespace std;

int main()
{
variant<int, double, long, char> x;

// x'İ kullansak türü int olucak, ilk alternatifi tutar
}

----------------------
using namespace std;

int main()
{
variant<int, double, long, char> x;

cout << x.index() << "\n"; //tutuğı indexi tutar
}

-------------------

int main()
{
variant<string, double, long, char> x(4.5);

cout << x.index() << "\n"; //1 olucak
}

-------------------

int main()
{
variant<string, double, long, char> x(4.5);

x = 3.4;

cout << x.index() << "\n"; 

x = 34;

cout << x.index() << "\n"; 
}

-----------------

bir yolu daha vardır

int main()
{
variant<string, double, long, char> x;

cout << x.index() << "\n"; 

if (holds_alternative<int>(x)) { //if tutuyorsa doğru kısma giricek

}
}

------------------

int main()
{
variant<string, double, long, char> x{57}; //double yapıp dene

cout << x.index() << "\n"; 

if (holds_alternative<int>(x)) { 
cout << "evet int tutuyor\n";
}
if (x.index() == 2) { 
cout << "evet int tutuyor\n";
}
}

------------------

using namespace std;

int main()
{
using namespace std;

variant<int, double, int> x;

cout << get<0>(x) << "\n";

variant<string, double, int> y;
}

----------------------

int main()
{
variant<string, double, int> x{3.47};

cout << get<1>(x) << "\n";
get<1>(x) = 965.46;

x = "mustafa";

x += "mustafa; //hatalı

get<0>(x) += " can"; //bu şekilde olur
}

----------------------

int main()
{
variant<string, double, int> x{3.47};

get<double>(x);
}

----------------

özetlersek

variant tuttuğu değere 2 şekilde erişebilirim

get fonksiyon şablonu ama nontype parametre ile
get<0>(x)

get fonksiyon şablonu ama tür parametresi ile
get<double>(x)

----------------

int main()
{
variant<string, double, int> x{3.47}; 

get<3> x; //sentax hatası
get<long> x; //hata
}

-----------------

int main()
{
variant<string, double, int> x{3.47};  //default etmezsek seçim yapıyor

try {
auto val = get<2>(x);
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

-------------------

int main()
{
variant<int, double, long> x('A'); //hata yok char'dan inte dönüşüm var

cout << "x.index() " << x.index() << '\n';

}

----------------

int main()
{
variant<int, Date, string> x{12, 5, 1987};  //burada fonksiyo date nesnesine erişiceğini anlamaz
//bunun yerine tag nesnesi kullanmamız lazım

variant<int, Date, string> x(in_place_type<Date>, 2,5,1987);

cout << get<1>(x) << "\n";

x.emplace<string>(10, 'a');
cout << get<2>(x) << "\n";
}

---------------

class A {
public:
A(int);
};

class B {
public:
B(double);
};

class C {
public:
C(int);
};

int main()
{
using namespace std;

variant<A, B, C> vx;

//bazen variant'I hiçbir değer tutmuyor durumunda tutmak istiyouz
//bunu aşmak için monostate kullanırız

variant<monostate, int, double, long> x

cout << x.index() < "\n";

cout << boolalpha << hold_alternative<monostate> << "\n";
}

------------------

int main()
{
using namespace std;

variant<int, double, long> x(2.3);

get_if<int>(&x) //geri dönüş değeri adres ancak get tutmuyorsa nullptr

if (int *ptr = get_if<int>(&x)) {
cout << ğptr << "\n";
}
}

/////////////////////////////////////// 2. Ders /////////////////////////////

#include <variant>

ilk indextei tür alternatif yapmak istiyorsak onu default ctor yapmak gerekir
bunun için monostate kullanıyorduk

struct Data {
Data(int x) : mx{x};

int mx;
};

int main()
{
using namespace std;

variant<monostate, long, Data, int, double> vx;

vx = Data{45}; //bu şekilde dolu hale gelir
vx = {}; //bu şekilde yine boş
vx = monostate{}; //bu şekilde boş

//boşmu sorusu 

cout << "vx.index()= " << vx.index() << '\n';

// if (!vx.index());

if (holds_alternative<monostate>(vx)) {
std::cout << "evet bombos\n";
}
else {
std::cout << "ben sana bos degilim\n";
}

if (get_if<monostate>(&vx)) { //bu ifadenin türü monostate*
std::cout << "bos\n";
}
else {
std::cout << "bos_degil\n";
}
}

---------------------------

karşılaştırma operatörlerininde operandı olabiliyor

int main()
{
using namespace std;

//variant<int, double> v1;
//variant<double, int> v2;
//farklı tür ise karşılaştırılamaz, aynı tür olması lazım

variant<int, double> v1(12), v2(1.2), v3;
boolalpha(cout);

cout << (v1 == v2) << '\n';
cout << (v1 < v2) << '\n';
}

------------------------

int main()
{
using namespace std;

variant<int, double, long> vx;

auto val = get<3>(vx); //hata
}

---------------------

variant'a atama yapmak için ya bir atama, contruc etmem gerekiyor
ya da emplace fonksiyonunu çağırmak gerekiyor

-----------------

struct Data {
Data(int x) : mx{x} {}

int mx;
};

int main()
{
using namespace std;

variant<string, int, string> vx;

vx.emplace<0>("neco");
vx.emplace<string>("ali"); //hata

}

-----------------

int main()
{
using namespace std;

using age_t = int;
using gender_t = char;
using name_t = string;

enum = size_t {idx_age, idx_gender, idx_name};

variant<age_t, gender_t, name_t> p;

get<age_t>(p);
}

---------------------

ilginç bir seneryo var biraz karmaşık

struct Nec {

operator int()const
{
throw std::runtime_error{ "error error" };
return 1;
}
};

int main()
{
using namespace std;

variant<int, double> vx{4.5};

try {
vx.emplace<0>(Nec{}); //yeni değer alıcak ancak eski değer detroy edilmeli ancak burada eski destroy edilir ama yeni değer exception throw edilir
}
catch(const std::exception& ex) {
std::cout << "hata yakalandi : " << ex.what() << "\n";
cout << vx.index() << "\n"; 
cout << boolalpha << vx.valueless_by_exception() << "\n";
cout << (vx.index() == variant_npos) << "\n";
}
}

------------------------

int main()
{
using namespace std;

variant<int,Date ,string> vx{3,5,1988}; //hata
variant<int, string> vy{20 , 'm'}; //hta

}

-------------

//Yukarıdaki durumu legal kılmak için

int main()
{
using namespace std;

variant<int,Date ,string> v1{in_place_indexz<1>3,5,1988}; 
variant<int, string> v2{in_place_type<Date>,3,5,1988}; 
variant<int, Date, string> v3{in_place_index<2>, 20, 'm'};
variant<int, Date, string> v4{in_place_index<string>, 20, 'm'};
}

---------------

konunun en zor alt konusuna geçiyoruz

visit
//amaç varianttaki öğeyi kullanmak ama öğeye ney ise onu göre kullanıcağız

int main()
{
using namespace std;

variant<int, Date, string, double> vx{4.5};

if (vx.inde() == 0 {
cout << "alternative int code\n";
get<0>(vx) << "\n";
}
else if (vx (index() == 1) {
cout << "alternative Date code\n";
get<1>(vx) << "\n";
}
else if (vx (index() == 2) {
cout << "alternative string code\n";
get<2>(vx) << "\n";
}
else if (vx (index() == 3) {
cout << "alternative double code\n";
get<3>(vx) << "\n";
}
}

----------------
//burada böyle bir kod yerine hold alternative de kullanabilirdik

int main()
{
using namespace std;

variant<int, Date, string, double> vx{4.5};

if (holds_alternative<int>(vx)) {
cout << "alternative int code\n";
get<0>(vx) << "\n";
}
else if (holds_alternative<Date>(vx)) {
cout << "alternative Date code\n";
get<1>(vx) << "\n";
}
else if (holds_alternative<string>(vx)) {
cout << "alternative string code\n";
get<2>(vx) << "\n";
}
else if (holds_alternative<double>(vx)) {
cout << "alternative double code\n";
get<3>(vx) << "\n";
}
}

----------------------------
//aşağıdaki şekilde de oolabilir

int main()
{
using namespace std;

variant<int, Date, string, double> vx{4.5};

if (auto p = get_if<0>(&vx)) {
cout << "alternative int code\n";
get<0>(vx) << "\n";
}
else if (auto p = get_if<1>(&vx)) {
cout << "alternative Date code\n";
get<1>(vx) << "\n";
}
else if (auto p = get_if<2>(&vx)) {
cout << "alternative string code\n";
get<2>(vx) << "\n";
}
else if (auto p = get_if<3>(&vx)) {
cout << "alternative double code\n";
get<3>(vx) << "\n";
}
}

------------------------------

bunların yerine bize standart kütüphane  bize visit fonksiyonunu verir

int main()
{
using namespace std;

variant<int, Date, string, double> vx{Date{3,6,1998}};

visit(callable, vx) //bu callable alternative çağrılmış olur

}

--------------------

struct Visitor {

void operator()(int)const //burayı auto yapabiliriiz
{
std::cout << "int alternative code\n";
}

void operator()(Date)const
{
std::cout << "Date alternative code\n";
}

void operator()(const std::string&)const
{
std::cout << "string alternative code\n";
}

void operator()(double)const
{
std::cout << "double alternative code\n";
}
};

int main()
{
using namespace std;

variant<int,Date, string, double> vx{Date{3,6,1998}};

visit(visitor{}, vx);

}

-----------------

struct Visitor {

void operator()(auto x)const //bu şekilde olunca tüm parametreler için bu fonksiuon çağrılır
{
std::cout << x << "\n";
}

};

int main()
{
using namespace std;

variant<int,Date, string, double> vx{Date{3,6,1998}};

vx = "necati"s;

visit(visitor{}, vx);
}

----------------------
#include <type_traits>

class Visitor {
void operator()(auto x)
{
if constexpr (std::is_same_v<decltype(x), int) {

}
else if constexpr (std::is_same_v<decltype(x), double>) {

}
}
};

int main()
{
using namespace std;

variant<int,Date, string, double> vx{Date{3,6,1998}};

visit(Visitor{}, vx);
}

-------------------------------

multi lambda

necati hoca mülakatlarda soruyor dilin 6,7 özelliği bir arada bulunduğu için bu yapı

//biraz eski konuların tekrarını yapıyoruz

struct X {

};

struct Y {

};

struct Z {

};

struct A: X, Y, Z {

};

int main()
{
A a;
a.foo(2.3); //kalıtımda bu şekilde overloading hatalı olur
a.foo(23);
a.foo(56L);
}

--------------------
bunu legal (int main içinde dokunmadan) kılmak için sınıf içi using bildirimi kullanılır

struct X {

};

struct Y {

};

struct Z {

};

struct A: X, Y, Z {
using X::foo;
using Y::foo;
using Z::foo;
};

int main()
{
A a;
a.foo(2.3); //kalıtımda bu şekilde overloading hatalı olur
a.foo(23);
a.foo(56L);
}

------------------

class A {};
class B {};
class C {};

template <typename ...Args>
class Der : public Args... {

};

int main()
{
Der<A,B,C> myder;
}

---------------

class A {void foo();};
class B {void bar();};
class C {void baz();};

template <typename ...Args>
class Der : public Args... {

};

int main()
{
Der<A,B,C> myder;

myder.baz(); //hiçbiri sentax hatası değil
myder.foo();
myder.bar();
}

-----------------

struct A {void foo(int);};
struct B {void bar(long);};
struct C {void baz(double);};

template <typename ...Args>
class Der : public Args... {

};

int main()
{
Der<A,B,C> myder;

myder.foo(12); //hata olma nedeni ambgios

}

----------------

struct A {void foo(int);};
struct B {void bar(long);};
struct C {void baz(double);};

template <typename ...Args>
class Der : public Args... {
using Args::foo...; //sentax hatası kalkar
};

int main()
{
Der<A,B,C> myder;

myder.foo(12)
myder.foo(34L);
myder.foo(3.4);
}

------------------

struct A {void foo(int);};
struct B {void bar(long);};
struct C {void baz(double);};

template <typename ...Args>
class Der : public Args... {
using Args::foo...;
};

int main()
{
Der myder {A{}}; //ctad dan dolayı legal
Der d2 {A{}, B{}};
Der d3 {C{}, A{}, B{}};
}

---------------

int main()
{
auto f = [](int x) {return x* x;};

struct Nec : decltype(f1), decltype(f2),  decltype(f3) {}; //bir sınınftan bir sınıf kalıtım yolula elde ediliyor

cout << typeid(decltype(f)).name() << "\n";
}

--------------

//yukarıdaki anlatılanların hepsi multilambda idiomunda bize yardımcı olucak

template <typename ...Args>
struct MultiLambda : Args... {
using Args::operator()...; //bununla aşağıdak hata kalkar
};

struct A{};
struct B{};
struct C{};

int main()
{
MultiLambda mx{
[](int x) {return x +1; },
[](double x) {return x * 1.3;},
[](long y) {return y + 5;}
};

mx(12); //hata olmasının nedeni ambigos 3 taban sınıfında ayrı operator çağrı fonksiyonu var

auto val1 = mx(12);
auto val2 = mx(4.5);
auto val3 = mx(4L);

//illa visitor gerek yoktur bu yapı ile de kullanılabilir
}

------------------

template <typename ...Args>
struct MultiLambda : Args... {
using Args::operator()...; 
};

struct A{};
struct B{};
struct C{};

int main()
{
MultiLambda mx{
[](int x) {cout << "int\n";},
[](double x) {cout << "double\n";},
[](long y) {cout << "auto\n";}
};

mx(12); 
mx(3.1);
mx(3L);
MX(Nec{});
mx(Erg{});
mx{Tmr{});
}

--------------------
using namespace std;

template <typename ...Args>
struct Overload : Args... {
using Args::operator()...;
};

struct Nec{};
struct Erg{};
struct Tmr{};

int main()
{
using namespace std;

variant<int, double, float, Nec, Erg, Tmr> v;

auto f = Overload{
[](int) {return "int"; },
[](double) {return "double"; },
[](float) {return "float"; },
[](Nec) {return "nec"; },
[](Erg) {return "erg"; },
[](Tmr) {return "tmr"; },
};

cout << visit(f,v) << '\n';
v = 2.3f;
cout << visit(f,v) << '\n';
v = Nec{};
cout << visit(f,v) << '\n';
}

--------------------

fonksiyona birden fazla variantı argüman olarak gönderebiliriz

----------------------

using namespace std;

struct Visitor {

void operator()(const string&, int)
{
std::cout <<"string - int\n";
}

void operator()(int, double)
{
std::cout <<"int - double\n";
}

void operator()(int, float)
{
std::cout <<"int - float\n";
}

void operator()(double, int)
{
std::cout <<"double - int\n";
}

void operator()(float, double)
{
std::cout <<"float - double\n";
}

void operator()(auto x, auto y)
{
std::cout <<typeid(decltype(x)).name() << " - " << typeid(decltype(y)).name() << "\n";
}
};

sturct Nec {};

int main()
{
using namespace std;

variant<int, double, float, char> v1{4.5};
variant<float, int, char, Nec> v2{ Nec{} };

visit(Visiter{}, v1, v2);
}


--------------------------------------------
run time polymorfizi maaliyetli bir işlemdir
run time polymorifizinden kurtulmanın yolları vardır

variant kullanmak

---------------------
// burada maaliyetler var, virtual, kalırım vs.

// eğer pdf, excel gibi başka şeyler daha sonra eklemiycek isek bunlara closure hiyaraji
//genişlemeye kapalı

class Document {
public:
virtual void print() = 0;
virtual ~Document() = default;
};

class Pdf : public Document {
virtaul void print() override {std::cout << "Pdf::print()\n";}
};

class Excel : public Document {
virtaul void print() override {std::cout << "Excel::print()\n";}
};

class Word : public Document {
virtaul void print() override {std::cout << "Word::print()\n";}
};

class PowerPoint : public Document {
virtaul void print() override {std::cout << "Powerpoint::print()\n";}
};

void process(Document* p)
{
p->print();
}

int main()
{
auto *pdoc = new Excel{};

process(pdoc);
}

----------------
// 

class Document {

};

class Pdf : {

};

class Excel {

};

class Word {

};

class Word  {

};

using Document = std::variant<Pdf, Excel, Word, Powerpoint>;

struct PrintVisitor {
void operator()(Pdf x) {

}

void operator()(Excel x) {

}

void operator()(Word x) {
public:
void print
}

void operator()(Powerpoint x) {

}
};

int main()
{
Document x{Word{} };
visit(PrintVisitor{}, x);
}

=========================================================

any 
----

int main()
{
using namespace std;

any x1{23}; //int tutar
any x2{2.3}; //double tutar
any x3{"murathan"}; //const char* tutar
any x4{"murathan"s}; //std::string tutar
}

-------------------

int main()
{
using namespace std;

any x1;
any x2{};
any x3 =  {};
}

-----------------
any has_value fonksiyonu vardır
boş olup olmadığına bakılır

int main()
{
using namespace std;

any x;

if (x.has_value()) {
std::cout << "dolu\n";
}
else {
std::cout << "bos\n";
}
}

------------------
any türünden nesneye istediğim değeri atamaya type erasure deniyor

arka planda türün ne olduğunun sınanması type info ile yapılır
-----------------

//bu sınıfı nasıl implemente ederiz

any türünden nesneye istediğim değeri atamaya type erasure deniyor

int main()
{
using namespace std;

any x(10);

cout << x.type().name() << "\n";

x = 4.5;

cout << x.type().name() << "\n";

x = bitset<16>{};

cout << x.type().name() << "\n";
}

---------------

nec ise neci double ise doublı nasıl kullanırız
bunu any_cast ile yaparız

int main()
{
using namespace std;

any x(10);

cout << any_cast<int>(x) //ayn type'Ina bakar ve gerçekten o türden ise o türden değer verir tutmuyorsa exception throw eder

x =  "necati"s;

cout << ayn_cast<string>(x) << "\n";

x = bitset<16>(456u);

cout << any_cast<bitset<16>>(x) << "\n";
}

-------------------

int main()
{
using namespace std;

any x(10);

try {
cout << any_cast<double(x) << "\n";
}

castch (const std::bad_cast& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

//////////////////////////////////////// 3. Ders //////////////////////////////






