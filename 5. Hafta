////////////////////////////////////////////////1. Ders////////////////////////////////////////////////////////

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees& other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  ~Addrees()
  {
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu geri verildi\n";
    std::free(mp);
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};
  adx.print();
  cout << "adress uzunlugu " << adx.lenght() << '\n';

  process_address(adx);
  std::cout << "main devam ediyor\n";

  adx.print(); // dangling pointer olur
}


//bu kod doğru çalışmaz doğru çalışması için copy constructerı kendimiz yazmamız gerekir yukarıdaderleyici yazmıştır

-----------------

copy constructer yazlması:
-------------------------

hayata gelen nesne kendi kaynağını edinicek

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees& other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  ~Addrees()
  {
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu geri verildi\n";
    std::free(mp);
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};
  adx.print();
  cout << "adress uzunlugu " << adx.lenght() << '\n';

  process_address(adx);
  std::cout << "main devam ediyor\n";

  adx.print(); // dangling pointer olur
}

//diğer öğeleri yine kopyalar pointerlar ve referansları kaynkatan kaynağa kopyalar

------------
//bu sınıf bu elemanlar ile impremente ediyor olsaydık copy constructerı bizim yazmamız gerekir miydi?
//-gerekmezdi çünkü kendi kaynağını kendileri yönetir zaten aşağıdakiler
class Person {

private:
int m_id;
std::string m_name;
std::string m_address;
std::vector<int> m_grades;
};

----------------

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees& other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  ~Addrees()
  {
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu geri verildi\n";
    std::free(mp);
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};
  
  if (adx.lenght() > 10)
  {
    Addrees ady {"bahcelievler derin sokak 45 / 7 ankara"};
    ady.print();
    ady = adx;
    ady.print();
    (void)getchar();
  }
  adx.print();  
}

//hata olur

//bir sınıf nesnesine başka bir türden sınıf nesnesi atandığında (atama ile init. farklı şeyler)
bu durumda kendisine atama yapılan nesne için yine sınıfn special member function çağrılır

------------------------

copy assignment:
----------------

class Myclass {};
Myclass x, y;

x = y; //artım durum c'de olduğu gibi değil
x.copy_assignment(y);  //yukarıdaki atama her zman böyle yapılmalı

------------------

class Myclass {
public:
Myclass(const Myclass& other) : ax(other.ax), bx(other.bx), cx(other.mx) {}
Myclass& operator=(const Myclass& other) //derleyicinin yazdığı atama operatör fonksiyonu
{
ax = other.ax;
bx = other.bx;
cx = other.cx;

}
private:
A ax;
B bx;
C cx;

}

--------

a = b //bu şekilde bir atama yapıldığında
a.operator = (b).foo(); //bu şekilde yapıcağız

// pointerları var ise problem çıkıcaktır copy ctor'da olduğu gibi

---------
//copy assignment yazımı 

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees &other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  Addrees &operator=(const Addrees &other)
  {
    // genel herhangi bir sınıf için
    std::free(mp);
    mlen = other.mlen;

    mp = static_cast<char *>(std::malloc(mlen + 1));
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
    return *this;
  }

  ~Addrees()
  {
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu geri verildi\n";
    std::free(mp);
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};

  if (adx.lenght() > 10)
  {
    Addrees ady{"bahcelievler derin sokak 45 / 7 ankara"};
    ady.print();
    std::cout << "uzunluk = " << ady.lenght() << "\n";
    ady = adx;
    ady.print();
    (void)getchar();
  }
  adx.print();
}

------------------------------

eski cpp'de big three

destructor ==> release resources
copy constructor ==> deep copy
copy assignment ==> release resources -> deep copy

//bu terim artık popüler değil çünü move'lar geldi

-----------------------------

bir nesnenin kendine atanmasına self assignment denir

x = x; //bunu yapmak dangling pointıra neden olur

bunların aynı olduğunu şu şekilde kontrol ederiz ve sorunu çözeriz :

if (this == &other)
return *this; 

-----
//yukarıdaki seneryolardansa aşağıdaki seneryolar için o önlem alınır
void foo(T& t, const T *p)
{
t = *p;
}

void func(T *p1, T *p2)
{
*p1 = *p2;
}

-------------

class Date {
public:
Date() = default;
Date(int d, int m, int y) : d_{d}, m_{m}, y_{y} {}
void print()const
{
std::cout << "[" << d_ << "-" << m_ << "-" << y_ << "]\n";
}

private:
int d_{}, m_{}, y{};
};

int main()
{
Date d1, d2, d3;
Date d4{21,8,2023};

d1 = d2 = d3 = d4; //hata olmaz
//d1 = (d2= (d3 = d4)); //derleyici böyle ele alır
//d1.operator=(de.operator=(d3.operator =(d4))); //bu şekilde de yazılır fark yok

d1.print();
d2.print();
d3.print();
d4.print();
}


-----------------------------------------

copy constructor (kopyalayan kurucu işlev)
move constructor (taşıyan kurucu işlev)
copy assignment (kopyalayan atama fonksiyonu)
move assignmnet (taşıyan atama fonksiyonu)


Myclass(); //default ctor
~Myclass(); //destrucotr
Myclass(const Myclass&); // copy ctor
Myclass(Myclass&& r); //move ctor
Myclass& operator = (const Myclass &); //copy assignment
Myclass& operator = (Myclass &&); //move assignment
---------------------------------------------

steal
T x = T türünden bir başka nesne

y = T türünden bir başka nesne

sınıf türünden bir ifade eğer R value bir değer kategorisindeyse

-------

move constructor:
-----------------

class Myclass {
public:
Myclass(); //default ctor
~Myclass(); //destrucotr
Myclass(const Myclass&); // copy ctor, paramtresi L value referans, kaynağını kopyalıycak
Myclass(Myclass&&); //move ctor, parametresi R value referans, kaynağını çalıcak
Myclass& operator = (const Myclass &); //copy assignment
Myclass& operator = (Myclass &&); //move assignment
}

!! move'da  bütün hikaye diğer nesnenin kaynağını çalıp diğer nesneyi distroctıbıl ama kaynağı geri verilmeyecek bir state sokmamız gerekiyor

--------------------------------

T x = init

!! derleyici copy ctor mı çağırılıcak move ctor mu çağrılıcağını ilk değer veren ifadenin R value'mu L value'mu dilin kurallarına güvenerek
dayanarak anlıyor

class Myclass {


};

void func(const Myclass&)
{
std::cout << "const Myclass&\n";
}

void func(const Myclass&&)
{
std::cout << "const Myclass&&\n";
}

int main()
{
Myclass m;
func(m); //1. çağrılır
func(static<Myclass&&>(m)); //sağ taraf referans türrüne cast ederiz, 2.çağrılır
func(std::move(m)); //yukarıdaki gibi yazmaktan hiçbir farkı yoktur, misnomer
func(Myclass{}); //2. çağrılır, R value exp.
}

!!MOVE DOESEN'T MOVE
------------------------

//mülakat sorusu

class Myclass {
public:
Myclass() = default;
Myclass(const Myclass&)
{
std::cout<< "copy ctor\n";
}

Myclass(Myclass&&)
{
std::cout<< "move ctor\n";
}
};

void func(const Myclass&)
{
std::cout << "const Myclass&\n";
}

void func(const Myclass&& r) //burası çağrılır
{
std::cout << "const Myclass&&\n";
}

int main()
{
Myclass m;
func(std::move(m)); //hiçbir nesne çağrılmaz çünkü referans nesneye bağlanır
Myclass &&r = std::move(m);
}

---------
class Myclass {
public:
};

void func(const Myclass&)
{
std::cout << "const Myclass&\n";
}

void func(const Myclass&&) //burası çağrılır
{
std::cout << "const Myclass&&\n";
}

void foo(Myclass &&r ) 
{

func(r);
}

int main()
{
Myclass m;
foo(std::move(m));
}

-----------------------

class Myclass {
public:
Myclass() = default;
Myclass(const Myclass&)
{
std::cout<< "copy ctor\n";
}

Myclass(Myclass&&)
{
std::cout<< "move ctor\n";
}
};

void foo(const Myclass &other)
{
Myclass m(other); //copy
}

void foo(Myclass&&)
{
Myclass m(other); //copy const
Myclass m(std::move(other)); //move const

}

int main()
{
Myclass m;
//öyle bir kod yaz ki
foo(m); //böyle yazılırsa copy ctor yazısı
foo(std::move(m))); //böyle yazılırsa move
}

----------

class Myclass {
public:
Myclass() = default;
Myclass(const Myclass&)
{
std::cout<< "copy ctor\n";
}

Myclass(Myclass&&)
{
std::cout<< "move ctor\n";
}
Myclass& operator=(const &other);
Myclass& operator=(Myclass&&);
};

void foo(const Myclass &other)
{
Myclass m;
m = other;
}

void foo(Myclass&& other)
{
Myclass m; //copy const
m = std::move(other);
}

int main()
{
Myclass m;
//öyle bir kod yaz ki
foo(m); //böyle yazılırsa copy ctor yazısı
foo(std::move(m))); //böyle yazılırsa move
}

-----------------------------------

!!!! hiçbir şey aklında kalmadıysa buraya bak

Myclass &r =
Myclass &&rr =

// ister sol taraf referansı olsun ister sağ taraf referansı olsun bir referans var ise 
o referansın oluşturduğu ismin value kategorisi her zman l value expresiondur

!! data type başka value kategory başka şeylerdir

Myclass &&rr

rr bir tür
ama bu ifadenin değer kategorisi L value exp.

-------------

derleyicinin yazdığı move constructer

class Nec {

};

void func(const Nec&); //1
void func(Nec&&); //2

int main()
{
Nec nec;
func(nec); // 1 çağrılır
func(Nec{}); //2 çağrılır
}

---------

!! bir sınııfın hem copy constructerı hem move constructarı var ise

class Nec {
public:
Nec(const Nec&); //sol taraf değeri içn bu
Nec(Nec&&); //sağ taraf değeri için bu

!! ama move constructer olmaz ise sağ taraf değeride sol taraf değeride copy constrıuctea gelicek

};

-----------

int main()
{
int x = 5; //value kategorisi yok
x; //l value
std::move(x); //value kategorisi yok, value kategory değiştiricek bir ifade yazıldı
}

----------

Derleyicinin yazdığı move constructer:
---------------------------------------

Myclass(Myclass &&other) : ax(other.ax), bx(other.bx), cx(other.mx) {}
Myclass& operator=(const Myclass& other)
{
ax = other.ax;
bx = other.bx;
cx = other.cx;

return *this;
}

Myclass(Myclass &&other) :
ax(std::move(other.ax)), bx(std::move(other.bx)), cx(std::move(other.cx))
{

}

  

private:
A ax;
B bx;
C cx;
}
--------

class Person {
private:
std::string name;
std::string surname;
std::string adress;
std::vector<int> grades;
}

-----------

move ctor kodunun yazılması:
------------------------------

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees &other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  Addrees(Addrees&& other) : mlen(other.mlen), mp(other.mp)
  {
    other.mlen = 0;
    other.mp = nullptr;
  }

  Addrees &operator=(const Addrees &other)
  {
    // genel herhangi bir sınıf için
    std::free(mp);
    mlen = other.mlen;

    mp = static_cast<char *>(std::malloc(mlen + 1));
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
    return *this;
  }

  ~Addrees()
  {
    if (mp)
      std::free(mp);
    
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};
  Addrees ady{"bahcelievler derin sokak 45 / 7 ankara"};

  adx.operator=(ady).print();
}



-------------

derleyicinin yazdığı move assignment:
-------------------------------------

Myclass(const Myclass &&other) : ax(other.ax), bx(other.bx), cx(other.mx) {}
Myclass& operator=(const Myclass& other)
{
ax = other.ax;
bx = other.bx;
cx = other.cx;

return *this;
}

Myclass(Myclass &&other) :
ax(std::move(other.ax)), bx(std::move(other.bx)), cx(std::move(other.cx)),
{

}

Myclass& operator=(Myclass &&other)
{
ax = std::move(other.ax);
bx = std::move(other.bx);
cx = std::move(other.cx);

return * this
}

private:
A ax;
B bx;
C cx;
}

-----------------------------

!! ezber gerektiren bir kısım

hangi durumda derleyici sınıfn hangi özel üye fonskiyonunu yazar
------
1)
//hiçbir özel üye belirtmessek 6 özel üyeyi'de yazar
class Myclass{

};

class Myclass{
public:
Myclass() = default;
~Myclass() = default;
Myclass(const Myclass&) = default;
Myclass(Myclass&&) = default;
Myclass& operator=(const Myclass&) = default;
Myclass& operator=(Myclass&&) = default;
};

----------
2)eğer sınıfa default ctor olmayann ama special member functionda olmayan
bir ctor yazarsak default ctor olmaz diğerleir olur

class Myclass{
public:
~Myclass() = default;
Myclass(const Myclass&) = default;
Myclass(Myclass&&) = default;
Myclass& operator=(const Myclass&) = default;
Myclass& operator=(Myclass&&) = default;
};
----------
3)eğer default ctor bildirirsek yani user declareted ise 

class Myclass{
public:
Myclass();
};

class Myclass{
public:
Myclass() = default;
~Myclass() = default;
Myclass(const Myclass&) = default;
Myclass(Myclass&&) = default;
Myclass& operator=(const Myclass&) = default;
Myclass& operator=(Myclass&&) = default;
};
---------
4)sınıfa destructor bildirirsek
class Myclass{
public:
~Myclass();
};

class Myclass{
public:
Myclass() = default;
~Myclass() ;
Myclass(const Myclass&) = default; //felakte yol açar
Myclass& operator=(const Myclass&) = default; //ASLA YAPMA
//NO MOVE MEMBERS
};
--------
5)sınıfa copy ctor bildirdik
class Myclass{
public:
Myclass(const Myclass&);
};

class Myclass{
public:
//no default ctor
~Myclass() ;
Myclass(const Myclass&);
Myclass& operator=(const Myclass&) = default; //felaket
//NO MOVE MEMBERS
};
---------
6)copy assignment biz yazarsak
class Myclass{
public:
Myclass& operator=(const Myclass&);
};

class Myclass{
public:
Myclass() = default;
~Myclass() = default;
Myclass(const Myclass&) = default; //felakte yol açar
Myclass& operator=(const Myclass&); 
//NO MOVE MEMBERS
};
-------
7)
class Myclass{
public:
Myclass(Myclass&&);
};

class Myclass{
public:
~Myclass() = default;
Myclass(const Myclass&) = delete
Myclass(Myclass&&);
Myclass& operator=(const Myclass&) = delete
//NO MOVE ASSİGNMENT
};
---------
8)
class Myclass{
public:
Myclass&operator=(Myclass&&);
};

class Myclass{
public:
Myclass() = default;
~Myclass() = default ;
Myclass(const Myclass&) = delete
Myclass(Myclass&&);
Myclass& operator=(const Myclass&) = delete; //ASLA YAPMA
Myclass&operator=(Myclass&&);
//NO MOVE ctor
};

/////////////////////////////////////////////2. Ders////////////////////////////////////

//special member tablosuna göre konuşuyoruz

class Date {

private:
int md{1}, mm{1}, my{1970}; //default ctor derleyici yazmasını sağlayabilirz
};

--------

//sınıfın kopyalamaya karşı kapatılması taşımaya açılması

sıfın move memberları olucak ancak copy delete edilcek böyle sınıflara move only-type denir

class Neco {
public: 
Neco();
Neco(const Neco&) = delete;
Neco& operator=(const Neco&) = delete;
Neco(Neco&&);
Neco& operator=(Neco&&);
private:

};

-----

class Member {
public :
Member(int);
Member(int,int);
private:

};

class Nec {
public :

private:
Member mx; //hata yok
}

int main()
{
Nec mynec; //burada hata olur
}

-----

class Member {
public :
Member(int);
Member(int,int);
private:

};

class Nec {
public :
Member(int);
Member(int, int);
Member() = delete; //hata olur

private:
Member mx; //hata yok
}

int main()
{
Nec mynec; //burada hata olur
}

---------------------------

temporary objects: nesneyi isimlendirmeden kullanmaya denir. runtime'da nesne var ortalıkta nesne yok
------------------

class Myclass {
public:
Myclass()
{
std::cout << "default ctor\n";
std::cout << "this = " << this << '\n';
std::cout << "-----------------------------\n";
}

~Myclass()
{
std::cout << "destructor\n";
std::cout << "this = " << this << '\n';
std::cout << "-----------------------------\n";
}

Myclass(int x)
{
std::cout << "Myclass(int x) x = " << x << \n";
std::cout << "this = " << this << '\n';
std::cout << "-----------------------------\n";
}

};

int main()
{
Myclass m1;
Myclass m2(35);

Myclass(); //bu geçerlidir
Myclass{}; //bu da geçerlidir
Myclass(12); //bu da geçerlidir

//bir çok durumda isimlendirililmiş nesne kullanmak yerine temporary nesne kullanılır
//bunun bize faydaları vardır
}

----

int main()
{
Myclass m;
func(m); //böyle kullanmanın dezavantajları vardır
//okuyan bunun daha sonra da kullanıcağını düşünür scope'undan dolayı

func(Myclass{12}); //madotory copy elision geçici nesne kullanınca kodu okuyan niyetimizi anlar

}

 !!isimlendirilmemiş nesne işimizi görüyorsa isimlendirilmemiş nesne kullan buna temporary object denir

------

int main()
{
Myclass{}; //tempory object değer kategorisi pr value

Myclass&r = Myclass{}; //geçersiz
const Myclass&r = Myclass{}; //geçerli
Myclass&&r = Myclass{}; //geçerli
}

------

void foo(Myclass);
void bar(Myclass &);
void baz(const Myclass &);
void func(Myclass &&);

int main()
{
foo(Myclass{}); //geçerli
bar(Myclass{}); //geçersiz
baz(Myclass{}); //geçerli
func(Myclass{}); //geçerli
}

---------
//life extension kuralı : normalde bir geçici nesne oluştuğğunda hayata gelen
geçici nesneyi içine alan ifadenin yürütülmesiyle sona erer 

int main()
{
cout << "[1]\n";
{
//Myclass{}; //geçici nesne alt satıra geçmden hayatı biter
const Myclass& r = Myclass{}; //geçici nesnyee bağlar isek life extension uygulanır
std::cout << "[2]\n";
}
std::cout << "[3]\n";
}

------

Myclass foo()
{
return Myclass{};
}

int main()
{
//Myclass &r = foo(); //legal olmaz, l value ref. r value ref'e bağlanmak isteniyor
const Myclass &r = foo(); //bu şekilde hata olmaz
Myclass &&R = foo(); //geçerli
}

---------------------

move-from state (taşınmış nesne durumu):
----------------------------------------

std::string foo();

int main()
{
using namespace std;
string s;

s = foo(); //R value referans olduğu için move assignment çağrıllır, L value olsaydı copy çağrılırdı
//s için tekrar dinamik bellek alanı edinilmez sadece pointerlar kopyalanır
//ciddi verim kazanılır
s = std::string(100'000, 'A'); //move assignment çağrılı
//taşıma semantiğinin devreye girmesi için özel bir şey yapmamız gerekmiyor

}

-------------

Özel durum :

std::string foo();

int main()
{
using namespace std;
string s;

string str(200'000, 'Z');
string sx = str; //copy assignment çağrılır     
string sx = std::move(str); //böyle bir kod ile gel beni çal demek istiyoruz, move ctor oldu
s = std::move(str); //move assignment 
//burada str destructor çağrılmamıştır scope sonunda çağrılır


}

---

std::string foo();

int main()
{
using namespace std;
string sx;

{
string str(200'000, 'Z');

sx = std::move(str);
//burada str hayatta ama kaynağıda çalınmış durumda (str is moved_from state)
}
sx
}

// tipik olarak (böyle bir sorumluluk yok) move member'lar kaynağı çalınmış nesneyi
kaynağı çalınmış diğer nesneyi default contruct edilmiş şekilde state bırakır 

------

kaynağı çalınmış nesne:
a) geçerli bir durumda
in a valid state

b) it's value unkown (değeri bilinmiyor

-----

std::string foo();

int main()
{
using namespace std;
string sx;

{
string str(200'000, 'Z');

sx = std::move(str);

cout << str << "\n"; //geçerli
//moved_from state'i sadece ona yeni bir atama yaparak kullanabilirim
}

}

!! kaynağı çalınmış bir nesneyi atama yoluyla kullanabilinir duurmda bırakmamız gerekir

-------
//bu kodu şimdilik anlamaya çalışma
//necati hoca mülakatlarda bunu çok soruyor yorum istiyor
int main()
{
using namespace std;

ifstream ifs {"notlar.txt"};

string sline;
vector<string> svec;

while (getline(ifs, sline)){
cout << sline <<'\n';
svec.push_back(std::move);
//svec.push_back(std::move(sline)); böyel olmalı
}
}

-----------------------

conversion contructor (dönüştüren kurucu işlev): myclass sınıfına dönüüşüm içindir
------------------------------------------------

class Myclass {
public:
Myclass() =default;
myclass(int); //sentax hatası ortadan kalkar
};

int main()
{
Myclass mx;
mx = 5; //sağ taraf int sol taraf myclass (hata)
}

------

class Myclass {
public:
Myclass() =default;
myclass(int x)
{
std::cout << "Myclass(int x) x = " << x << "\n"; 
std::cout << "this = " << this << '\n';   
}
};

int main()
{
Myclass mx;
mx = 5;
//örtülü olarak int türden  bir nesneyi mclass sıfına dönüştürür
}

------

class Myclass {
public:
Myclass() =default;

Myclass(int x)
{
std::cout << "Myclass(int x) x = " << x << "\n"; 
std::cout << "this = " << this << '\n';   
}

Myclass& operator=(const Myclass& r)
{
std::cout << "Myclass copy asssignment this = " << this << "\n";
std::cout << "&r = " << &r << '\n';
return *this;
}

Myclass& operator=(const Myclass&& r)
{
std::cout << "Myclass move asssignment this = " << this << "\n";
std::cout << "&r = " << &r << '\n';
return *this;
}

~Myclass()
{
std::cout << "Myclass destructor this = " << this << '\n';
}
};

int main()
{
Myclass mx;
std::cout << "&mx = " << &mx << '\n';
std::cout << "main [1]\n";
//ctor
mx = 5; //buraya çağrı yapılır ve geciçi nesne oluşturulur
//dtor
std::cout << "main [2]\n";
}

-----------

class Myclass {
public:
Myclass(int);
};

void func(Myclass);

int main()
{
func(12);
}
//bu kodun geçerli olmasının nedeni user defined gerçekleştii içindir

------

class Myclass {
public:
Myclass();
Myclass(int);
};

int main()
{
Myclass m;
m = 3.2323; //legal

}

-----

class Myclass {
public:
Myclass();
Myclass(bool);
};

int main()
{
Myclass m;
int x = 10;

m =&x; //geçerli
}

-----

class Myclass {
public:
Myclass();
Myclass(int);
};

int main()
{
Myclass m;
int x = 10;
int *ptr = nullptr;
m = ptr;
}

--------------

type cast operator function:
----------------------------

eğer bir dönüşüm aşağıdaki dönüşüm sekanslarından biriyle
gerçekleştiribiliyor ise derleyici bu dönüşümü örtülü olarak yapmak zorunda

user-defined connversion + standart conversioni
standart conversion + user defined conversion

class Myclass {
public:
Myclass();
Myclass(bool);
};

int main()
{
Myclass m;
int x = 10;
int *ptr = nullptr;

m = ptr;

//pointer to int türünden bool'a standart conversion var
//bool'dan myclass'a user defined conversion var
//derleyici 'standart conversion + user defined conversion' bu şekilde dönüşümü yapar
}

------

class Myclass {
public:
Myclass();
Myclass(bool);
};

int main()
{
Myclass m;
double dval = 32.5;
m = dval;

'standart conversion + user defined conversion' derleyici bu şekilde dönüşüm yapar
}

--------

user defined conversion + user defined conversion, bunu örtülü olarak yapamaz

class A {

};

class B {
public:
B();
B(A);
};

int main()
{
A ax;
B bx;

bx = ax; //conversion constructer
}

-------

class A {
public:
A(int);
};

class B {
public:
B();
B(A);
};

int main()
{
A ax;
B bx;

bx = bx;
bx = 13; //hata bunu yapması için 2 tane user defined yapması gerekir
//inr ==> A (user defined)
A ==> B (user defined)
!! tür dönüüştürme kullanırsak geçerli olur
//bx = static_cast<A>(13);
}

----------

conversion constructer genel olarak bizim için ciddi bir risktir

class String {
public:
String(const char *);
};

int main()
{
String = "Onur Yagar"; //legal
}

-------

int main()
{
using namespace std;
vector<int> ivec(1234); //1234 tane int tutar
}

------

int main()
{
using namespace std;
int ival = 4343;
vector<int> ivec;

ivec = ival; //böyle bir senaryo geçerli olsa idi felaket olurdu
//bunun hata olması aşağıdaki konu ile alakalı
}

--------------------

explicit ctor: c++ dilinin önemli anahtar sözcüklerinden biridir
-------------

imlicit conversion : derleyicinin durumdan vazife çıkartarak dilin kuralları gereği yaptığı örtülü dönüşüm
explicit conversion : tür dönüştüme operatörü ile yapılan dönüşüm

class Myclass {

public:
Myclass();
explicit Myclass(int); //bu ctor implict dönüşüm yapmaz sadece explicit dönüşüm yapar demektir
};

---------

class Myclass {
public :
Myclass();
Myclass(int);
};

int main()
{
Myclass m;
m = 23; //legal
}

-----

class Myclass {
public :
Myclass();
emplicit Myclass(int); //kazara implicit coversion yapmasını  enggeliyoruz
};

int main()
{
Myclass m;
m = 23; //illegal
m = static_cast<Myclass>(23); //legal
}


------------

!! Bir sınıfın (özellikle) tek paramtereli ctor'larını (aksi yönde karar almanızı gerektiricek makul bir neden olmadıkça)
explicit yapınız

class Myclass {
public:
explicit Myclass(int);
};

int main()
{
Myclass m1(19);
Myclass m2{35};
Myclass m3 = 57; //copy init, sentax hatası
}

-----------
//kod anlamaya çalışma

int main()
{
using namespace std;

unique_ptr<int> p1{new int};
unique_ptr<int> p2(new int);
unique_ptr<int> p3 = new int; //sentax hatası
}

-------
//Mülakatalarda sorulan bir soru

class Myclass {
public:
explicit Myclass(double);
Myclass(int);
};

int main()
{
Myclass m = 45.98; //hata olmaz, int çağrılır
}

!! explicit ctor copy init durumunda overload sete hiç girmez

-----------

class Myclass {
public:
Myclass();
};

int main()
{
Myclass m{}; //geçerli
}

----------

class Myclass {
public:
Myclass();
};

void func(Myclass);

Myclass foo()
{
return Myclass(); //legal
return Myclass{};//legal
return {};//legal
}

int main()
{
func(Myclass());
func(Myclass{});
func({});
}

-------

class Myclass {
public:
emplicit Myclass();
};

void func(Myclass);

Myclass foo()
{
//return Myclass();
//return Myclass{};
return {};//hata
}

int main()
{
Myclass m = {}; //Hata
func(Myclass());
func(Myclass{});
func({});
}

--------







