////////////////////////////////////////////////1. Ders////////////////////////////////////////////////////////


  #include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees& other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  ~Addrees()
  {
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu geri verildi\n";
    std::free(mp);
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};
  adx.print();
  cout << "adress uzunlugu " << adx.lenght() << '\n';

  process_address(adx);
  std::cout << "main devam ediyor\n";

  adx.print(); // dangling pointer olur
}


//bu kod doğru çalışmaz doğru çalışması için copy constructerı kendimiz yazmamız gerekir yukarıdaderleyici yazmıştır

-----------------

copy constructer yazlması:
-------------------------

hayata gelen nesne kendi kaynağını edinicek

class Address {
public:
  Address(const char *p) : mlen(std::strlen(p)),
  mp{static_cast<char *>(std::malloc(mlen + 1));
  {
    if (!mp) {
      throw std::runtime_error{"not enough memory"};
    }
std::cout << static_cast<void *>(mp) << "adresindeki bellek bloğu edlindi\n";
std::strcpy(mp, p);
}

Address(const Add& other) : mlen{other.mlen}, mp(static_cast<char*>(std::malloc(mlen + 1))) 
{
  if (!mp) {
      throw std::runtime_error{"not enough memory"};
}
std::strcpy(mp, other.mp);
}
~Address()
{
std::cout << static_cast<void *>(mp) << "adresindeki bellek bloğu geri verildi\n";
std::free(mp);
}
void print()const;
{
std::cout << mp << '\n';
}
std::size_t lenght()const
{
return mlen;
}
private:
std::size_t mlen;
char *mp;
};

void process_address(Address x)
{
std::cout << "process_address fonksiyonu cagrildi\n"
x.print();
(void)getchar();
}

int main()
{
using namespace srd;

Address adx{"buyukdere mah. ozan sok. no 12 ıstanbul"};
adx.print();
cout << "adres uzunlugu" << adx.lenght() << '\n';

process_address(adx);
std::cout << "main devam ediyo\n";

adx.print(); //ub, dangling pointerdan dolayı,
}


//diğer öğeleri yine kopyalar pointerlar ve referansları kaynkatan kaynağa kopyalar

------------
//bu sınıf bu elemanlar ile impremente ediyor olsaydık copy constructerı bizim yazmamız gerekir miydi?
//-gerekmezdi çünkü kendi kaynağını kendileri yönetir zaten aşağıdakiler
class Person {

private:
int m_id;
std::string m_name;
std::string m_address;
std::vector<int> m_grades;
};

----------------

class Address {
public:
  Address(const char *p) : mlen(std::strlen(p)),
  mp{static_cast<char *>(std::malloc(mlen + 1));
  {
    if (!mp) {
      throw std::runtime_error{"not enough memory"};
    }
std::cout << static_cast<void *>(mp) << "adresindeki bellek bloğu edlindi\n";
std::strcpy(mp, p);
}

Address(const Add& other) : mlen{other.mlen}, mp(static_cast<char*>(std::malloc(mlen + 1))) 
{
  if (!mp) {
      throw std::runtime_error{"not enough memory"};
}
std::strcpy(mp, other.mp);
}
~Address()
{
std::cout << static_cast<void *>(mp) << "adresindeki bellek bloğu geri verildi\n";
std::free(mp);
}
void print()const;
{
std::cout << mp << '\n';
}
std::size_t lenght()const
{
return mlen;
}
private:
std::size_t mlen;
char *mp;
};

void process_address(Address x)
{
std::cout << "process_address fonksiyonu cagrildi\n"
x.print();
(void)getchar();
}

int main()
{
using namespace srd;

Address adx{"buyukdere mah. ozan sok. no 12 ıstanbul"};

if (adx.length() > 10) {
Address ady {"bahcelievler derin sokak 45 / 7 ankara"}
ady.print();
ady = adx;
ady.print();
(void)getchar();
}
adx.print();
}

//hata olur

//bir sınıf nesnesine başka bir türden sınıf nesnesi atandığında (atama ile init. farklı şeyler)
bu durumda kendisine atama yapılan nesne için yine sınıfn special member function çağrılır

------------------------

copy assignment:
----------------

class Myclass {};
Myclass x, y;

x = y; //artım durum c'de olduğu gibi değil
x.copy_assignment(y);  //yukarıdaki atama her zman böyle yapılmalı


class Myclass {
public:
Myclass(const Myclass& other) : ax(other.ax), bx(other.bx), cx(other.mx) {}
Myclass& operator=(const Myclass& other) //derleyicinin yazdığı atama operatör fonksiyonu
{
ax = other.ax;
bx = other.bx;
cx = other.cx;

}
private:
A ax;
B bx;
C cx;

}

--------

a = b //bu şekilde bir atama yapıldığında
a.operator = (b).foo(); //bu şekilde yapıcağız

// pointerları var ise problem çıkıcaktır copy ctor'da olduğu gibi

---------
//copy assignment yazımı 

class Address {
public:
  Address(const char *p) : mlen(std::strlen(p)),
  mp{static_cast<char *>(std::malloc(mlen + 1));
  {
    if (!mp) {
      throw std::runtime_error{"not enough memory"};
    }
std::cout << static_cast<void *>(mp) << "adresindeki bellek bloğu edlindi\n";
std::strcpy(mp, p);
}

Address(const Add& other) : mlen{other.mlen}, mp(static_cast<char*>(std::malloc(mlen + 1))) 
{
  if (!mp) {
      throw std::runtime_error{"not enough memory"};
}
std::strcpy(mp, other.mp);
}

Address& operator =(const Address& other)
{
std::free(mp);
mlen = other.mlen();
mp = static_cast<char*>(std::malloc(mlen + 1))
if (!mp) {
throw std::runtime_error{"not enough memory"};
}
str::strcpy(mp, other.mp);
return *yhis;
}
~Address()
{
std::cout << static_cast<void *>(mp) << "adresindeki bellek bloğu geri verildi\n";
std::free(mp);
}
void print()const;
{
std::cout << mp << '\n';
}
std::size_t lenght()const
{
return mlen;
}
private:
std::size_t mlen;
char *mp;
};

void process_address(Address x)
{
std::cout << "process_address fonksiyonu cagrildi\n"
x.print();
(void)getchar();
}

int main()
{
using namespace srd;

Address adx{"buyukdere mah. ozan sok. no 12 ıstanbul"};

if (adx.length() > 10) {
Address ady {"bahcelievler derin sokak 45 / 7 ankara"}
ady.print();
ady = adx;
ady.print();
(void)getchar();
}
adx.print();
}

------------------------------

eski cpp'de big three

destructor ==> release resources
copy constructor ==> deep copy
copy assignment ==> release resources -> deep copy

//bu terim artık popüler değil çünü move'lar geldi

-----------------------------

bir nesnenin kendine atanmasına self assignment denir

x = x; //bunu yapmak dangling pointıra neden olur

bunların aynı olduğunu şu şekilde kontrol ederiz ve sorunu çözeriz :

if (this == &other)
return *this; 

-----
//yukarıdaki seneryolardansa aşağıdaki seneryolar için o önlem alınır
void foo(T& t, const T *p)
{
t = *p;
}

void func(T *p1, T *p2)
{
*p1 = *p2;
}

-------------

class Date {
public:
Date() = default;
Date(int d, int m, int y) : d_{d}, m_{m}, y_{y} {}
void print()const
{
std::cout << "[" << d_ << "-" << m_ << "-" << y_ << "]\n";
}

private:
int d_{}, m_{}, y{};
};

int main()
{
Date d1, d2, d3;
Date d4{21,8,2023};

d1 = d2 = d3 = d4; //hata olmaz
//d1 = (d2= (d3 = d4)); //derleyici böyle ele alır
//d1.operator=(de.operator=(d3.operator =(d4))); //bu şekilde de yazılır fark yok

d1.print();
d2.print();
d3.print();
d4.print();
}


-----------------------------------------

copy constructor (kopyalayan kurucu işlev)
move constructor (taşıyan kurucu işlev)
copy assignment (kopyalayan atama fonksiyonu)
move assignmnet (taşıyan atama fonksiyonu)


Myclass(); //default ctor
~Myclass(); //destrucotr
Myclass(const Myclass&); // copy ctor
Myclass(Myclass&& r); //move ctor
Myclass& operator = (const Myclass &); //copy assignment
Myclass& operator = (Myclass &&); //move assignment
---------------------------------------------

steal
T x = T türünden bir başka nesne

y = T türünden bir başka nesne

sınıf türünden bir ifade eğer R value bir değer kategorisindeyse

-------

move constructor:
-----------------

class Myclass {
public:
Myclass(); //default ctor
~Myclass(); //destrucotr
Myclass(const Myclass&); // copy ctor, paramtresi L value referans, kaynağını kopyalıycak
Myclass(Myclass&&); //move ctor, parametresi R value referans, kaynağını çalıcak
Myclass& operator = (const Myclass &); //copy assignment
Myclass& operator = (Myclass &&); //move assignment
}

!! move'da  bütün hikaye diğer nesnenin kaynağını çalıp diğer nesneyi distroctıbıl ama kaynağı geri verilmeyecek bir state sokmamız gerekiyor

--------------------------------

T x = init

!! derleyici copy ctor mı çağırılıcak move ctor mu çağrılıcağını ilk değer veren ifadenin R value'mu L value'mu dilin kurallarına güvenerek
dayanarak anlıyor

class Myclass {


};

void func(const Myclass&)
{
std::cout << "const Myclass&\n";
}

void func(const Myclass&&)
{
std::cout << "const Myclass&&\n";
}

int main()
{
Myclass m;
func(m); //1. çağrılır
func(static<Myclass&&>(m)); //sağ taraf referans türrüne cast ederiz, 2.çağrılır
func(std::move(m)); //yukarıdaki gibi yazmaktan hiçbir farkı yoktur, misnomer
func(Myclass{}); //2. çağrılır, R value exp.
}

!!MOVE DOESEN'T MOVE
------------------------

//mülakat sorusu

class Myclass {
public:
Myclass() = default;
Myclass(const Myclass&)
{
std::cout<< "copy ctor\n";
}

Myclass(Myclass&& r)
{
std::cout<< "move ctor\n";
}
};

void func(const Myclass&)
{
std::cout << "const Myclass&\n";
}

void func(const Myclass&& r) //burası çağrılır
{
std::cout << "const Myclass&&\n";
}

int main()
{
Myclass m;
func(std::move(m)); //hiçbir nesne çağrılmaz çünkü referans nesneye bağlanır
Myclass &&r = std::move(m);
}

---------
class Myclass {
public:
};

void func(const Myclass&)
{
std::cout << "const Myclass&\n";
}

void func(const Myclass&&) //burası çağrılır
{
std::cout << "const Myclass&&\n";
}

void foo(Myclass &&r ) 
{

func(r);
}

int main()
{
Myclass m;
foo(std::move(m));
}

-----------------------

class Myclass {
public:
Myclass() = default;
Myclass(const Myclass&)
{
std::cout<< "copy ctor\n";
}

Myclass(Myclass&&)
{
std::cout<< "move ctor\n";
}
};

void foo(const Myclass &other)
{
Myclass m(other); //copy
}

void foo(Myclass&&)
{
Myclass m(other); //copy const
Myclass m(std::move(other)); //move const

}

int main()
{
Myclass m;
//öyle bir kod yaz ki
foo(m); //böyle yazılırsa copy ctor yazısı
foo(std::move(m))); //böyle yazılırsa move
}

----------

class Myclass {
public:
Myclass() = default;
Myclass(const Myclass&)
{
std::cout<< "copy ctor\n";
}

Myclass(Myclass&&)
{
std::cout<< "move ctor\n";
}
Myclass& operator=(const &other);
Myclass& operator=(Myclass&&);
};

void foo(const Myclass &other)
{
Myclass m;
m = other;
}

void foo(Myclass&& other)
{
Myclass m; //copy const
m = std::move(other);
}

int main()
{
Myclass m;
//öyle bir kod yaz ki
foo(m); //böyle yazılırsa copy ctor yazısı
foo(std::move(m))); //böyle yazılırsa move
}

-----------------------------------

!!!! hiçbir şey aklında kalmadıysa buraya bak

Myclass &r =
Myclass &&rr =

// ister sol taraf referansı olsun ister sağ taraf referansı olsun bir referans var ise 
o referansın oluşturduğu ismin value kategorisi her zman l value expresiondur

!! data type başka value kategory başka şeylerdir

Myclass &&rr

rr bir tür
ama bu ifadenin değer kategorisi L value exp.

-------------

derleyicinin yazdığı move constructer

class Nec {

};

void func(const Nec&); //1
void func(Nec&&); //2

int main()
{
Nec nec;
func(nec); // 1 çağrılır
func(Nec{}); //2 çağrılır
}

---------

!! bir sınııfın hem copy constructerı hem move constructarı var ise

class Nec {
public:
Nec(const Nec&); //sol taraf değeri içn bu
Nec(Nec&&); //sağ taraf değeri için bu

!! ama move constructer olmaz ise sağ taraf değeride sol taraf değeride copy constrıuctea gelicek

};

-----------

int main()
{
int x = 5; //value kategorisi yok
x; //l value
std::move(x); //value kategorisi yok, value kategory değiştiricek bir ifade yazıldı
}

----------

Derleyicinin yazdığı move constructer:
---------------------------------------

Myclass(Myclass &&other) : ax(other.ax), bx(other.bx), cx(other.mx) {}
Myclass& operator=(const Myclass& other)
{
ax = other.ax;
bx = other.bx;
cx = other.cx;

return *this;
}

Myclass(Myclass &&other) :
ax(std::move(other.ax)), bx(std::move(other.bx)), cx(std::move(other.cx))
{

}

  

private:
A ax;
B bx;
C cx;
}
--------

class Person {
private:
std::string name;
std::string surname;
std::string adress;
std::vector<int> grades;
}

-----------

move ctor kodunun yazılması:
------------------------------

class Address {
public:
  Address(const char *p) : mlen(std::strlen(p)),
  mp{static_cast<char *>(std::malloc(mlen + 1));
  {
    if (!mp) {
      throw std::runtime_error{"not enough memory"};
    }
std::cout << static_cast<void *>(mp) << "adresindeki bellek bloğu edlindi\n";
std::strcpy(mp, p);
}

//move ctor
Address(Adress&& other) : mlen(other.mlen), mp(other.mp)
{
other.mlen = 0;
other.mp = nullptr;
}

Address(const Add& other) : mlen{other.mlen}, mp(static_cast<char*>(std::malloc(mlen + 1))) 
{
  if (!mp) {
      throw std::runtime_error{"not enough memory"};
}
std::strcpy(mp, other.mp);
}

~Address()
{
std::cout << static_cast<void *>(mp) << "adresindeki bellek bloğu geri verildi\n";
std::free(mp);
}
void print()const;
{
std::cout << mp << '\n';
}
std::size_t lenght()const
{
return mlen;
}
private:
std::size_t mlen;
char *mp;
};

void process_address(Address x)
{
std::cout << "process_address fonksiyonu cagrildi\n"
x.print();
(void)getchar();
}

int main()
{
using namespace srd;

Address adx{"buyukdere mah. ozan sok. no 12 ıstanbul"};
adx.print();
cout << "adres uzunlugu" << adx.lenght() << '\n';

process_address(adx);
std::cout << "main devam ediyo\n";

adx.print(); //ub, dangling pointerdan dolayı,
}


-------------

derleyicinin yazdığı move assignment:
-------------------------------------

Myclass(const Myclass &&other) : ax(other.ax), bx(other.bx), cx(other.mx) {}
Myclass& operator=(const Myclass& other)
{
ax = other.ax;
bx = other.bx;
cx = other.cx;

return *this;
}

Myclass(Myclass &&other) :
ax(std::move(other.ax)), bx(std::move(other.bx)), cx(std::move(other.cx)),
{

}

Myclass& operator=(Myclass &&other)
{
ax = std::move(other.ax);
bx = std::move(other.bx);
cx = std::move(other.cx);

return * this
}

private:
A ax;
B bx;
C cx;
}

-----------------------------

!! ezber gerektiren bir kısım

hangi durumda derleyici sınıfn hangi özel üye fonskiyonunu yazar
------
1)
//hiçbir özel üye belirtmessek 6 özel üyeyi'de yazar
class Myclass{

};

class Myclass{
public:
Myclass() = default;
~Myclass() = default;
Myclass(const Myclass&) = default;
Myclass(Myclass&&) = default;
Myclass& operator=(const Myclass&) = default;
Myclass& operator=(Myclass&&) = default;
};

----------
2)eğer sınıfa default ctor olmayann ama special member functionda olmayan
bir ctor yazarsak default ctor olmaz diğerleir olur

class Myclass{
public:
~Myclass() = default;
Myclass(const Myclass&) = default;
Myclass(Myclass&&) = default;
Myclass& operator=(const Myclass&) = default;
Myclass& operator=(Myclass&&) = default;
};
----------
3)eğer default ctor bildirirsek yani user declareted ise 

class Myclass{
public:
Myclass();
};

class Myclass{
public:
Myclass() = default;
~Myclass() = default;
Myclass(const Myclass&) = default;
Myclass(Myclass&&) = default;
Myclass& operator=(const Myclass&) = default;
Myclass& operator=(Myclass&&) = default;
};
---------
4)sınıfa destructor bildirirsek
class Myclass{
public:
~Myclass();
};

class Myclass{
public:
Myclass() = default;
~Myclass() ;
Myclass(const Myclass&) = default; //felakte yol açar
Myclass& operator=(const Myclass&) = default; //ASLA YAPMA
//NO MOVE MEMBERS
};
--------
5)sınıfa copy ctor bildirdik
class Myclass{
public:
Myclass(const Myclass&);
};

class Myclass{
public:
//no default ctor
~Myclass() ;
Myclass(const Myclass&);
Myclass& operator=(const Myclass&) = default; //felaket
//NO MOVE MEMBERS
};
---------
6)copy assignment biz yazarsak
class Myclass{
public:
Myclass& operator=(const Myclass&);
};

class Myclass{
public:
Myclass() = default;
~Myclass() = default;
Myclass(const Myclass&) = default; //felakte yol açar
Myclass& operator=(const Myclass&); 
//NO MOVE MEMBERS
};
-------
7)
class Myclass{
public:
Myclass(Myclass&&);
};

class Myclass{
public:
~Myclass() = default;
Myclass(const Myclass&) = delete
Myclass(Myclass&&);
Myclass& operator=(const Myclass&) = delete
//NO MOVE ASSİGNMENT
};
---------
8)
class Myclass{
public:
Myclass&operator=(Myclass&&);
};

class Myclass{
public:
Myclass() = default;
~Myclass() = default ;
Myclass(const Myclass&) = delete
Myclass(Myclass&&);
Myclass& operator=(const Myclass&) = delete; //ASLA YAPMA
Myclass&operator=(Myclass&&);
//NO MOVE ctor
};



