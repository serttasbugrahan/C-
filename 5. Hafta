////////////////////////////////////////////////1. Ders////////////////////////////////////////////////////////

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees& other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  ~Addrees()
  {
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu geri verildi\n";
    std::free(mp);
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};
  adx.print();
  cout << "adress uzunlugu " << adx.lenght() << '\n';

  process_address(adx);
  std::cout << "main devam ediyor\n";

  adx.print(); // dangling pointer olur
}


//bu kod doğru çalışmaz doğru çalışması için copy constructerı kendimiz yazmamız gerekir yukarıdaderleyici yazmıştır

-----------------

copy constructer yazlması:
-------------------------

hayata gelen nesne kendi kaynağını edinicek

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees& other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  ~Addrees()
  {
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu geri verildi\n";
    std::free(mp);
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};
  adx.print();
  cout << "adress uzunlugu " << adx.lenght() << '\n';

  process_address(adx);
  std::cout << "main devam ediyor\n";

  adx.print(); // dangling pointer olur
}

//diğer öğeleri yine kopyalar pointerlar ve referansları kaynkatan kaynağa kopyalar

------------
//bu sınıf bu elemanlar ile impremente ediyor olsaydık copy constructerı bizim yazmamız gerekir miydi?
//-gerekmezdi çünkü kendi kaynağını kendileri yönetir zaten aşağıdakiler
class Person {

private:
int m_id;
std::string m_name;
std::string m_address;
std::vector<int> m_grades;
};

----------------

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees& other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  ~Addrees()
  {
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu geri verildi\n";
    std::free(mp);
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};
  
  if (adx.lenght() > 10)
  {
    Addrees ady {"bahcelievler derin sokak 45 / 7 ankara"};
    ady.print();
    ady = adx;
    ady.print();
    (void)getchar();
  }
  adx.print();  
}

//hata olur

//bir sınıf nesnesine başka bir türden sınıf nesnesi atandığında (atama ile init. farklı şeyler)
bu durumda kendisine atama yapılan nesne için yine sınıfn special member function çağrılır

------------------------

copy assignment:
----------------

class Myclass {};
Myclass x, y;

x = y; //artım durum c'de olduğu gibi değil
x.copy_assignment(y);  //yukarıdaki atama her zman böyle yapılmalı

------------------

class Myclass {
public:
Myclass(const Myclass& other) : ax(other.ax), bx(other.bx), cx(other.mx) {}
Myclass& operator=(const Myclass& other) //derleyicinin yazdığı atama operatör fonksiyonu
{
ax = other.ax;
bx = other.bx;
cx = other.cx;

}
private:
A ax;
B bx;
C cx;

}

--------

a = b //bu şekilde bir atama yapıldığında
a.operator = (b).foo(); //bu şekilde yapıcağız

// pointerları var ise problem çıkıcaktır copy ctor'da olduğu gibi

---------
//copy assignment yazımı 

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees &other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  Addrees &operator=(const Addrees &other)
  {
    // genel herhangi bir sınıf için
    std::free(mp);
    mlen = other.mlen;

    mp = static_cast<char *>(std::malloc(mlen + 1));
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
    return *this;
  }

  ~Addrees()
  {
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu geri verildi\n";
    std::free(mp);
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};

  if (adx.lenght() > 10)
  {
    Addrees ady{"bahcelievler derin sokak 45 / 7 ankara"};
    ady.print();
    std::cout << "uzunluk = " << ady.lenght() << "\n";
    ady = adx;
    ady.print();
    (void)getchar();
  }
  adx.print();
}

------------------------------

eski cpp'de big three

destructor ==> release resources
copy constructor ==> deep copy
copy assignment ==> release resources -> deep copy

//bu terim artık popüler değil çünü move'lar geldi

-----------------------------

bir nesnenin kendine atanmasına self assignment denir

x = x; //bunu yapmak dangling pointıra neden olur

bunların aynı olduğunu şu şekilde kontrol ederiz ve sorunu çözeriz :

if (this == &other)
return *this; 

-----
//yukarıdaki seneryolardansa aşağıdaki seneryolar için o önlem alınır
void foo(T& t, const T *p)
{
t = *p;
}

void func(T *p1, T *p2)
{
*p1 = *p2;
}

-------------

class Date {
public:
Date() = default;
Date(int d, int m, int y) : d_{d}, m_{m}, y_{y} {}
void print()const
{
std::cout << "[" << d_ << "-" << m_ << "-" << y_ << "]\n";
}

private:
int d_{}, m_{}, y{};
};

int main()
{
Date d1, d2, d3;
Date d4{21,8,2023};

d1 = d2 = d3 = d4; //hata olmaz
//d1 = (d2= (d3 = d4)); //derleyici böyle ele alır
//d1.operator=(de.operator=(d3.operator =(d4))); //bu şekilde de yazılır fark yok

d1.print();
d2.print();
d3.print();
d4.print();
}


-----------------------------------------

copy constructor (kopyalayan kurucu işlev)
move constructor (taşıyan kurucu işlev)
copy assignment (kopyalayan atama fonksiyonu)
move assignmnet (taşıyan atama fonksiyonu)


Myclass(); //default ctor
~Myclass(); //destrucotr
Myclass(const Myclass&); // copy ctor
Myclass(Myclass&& r); //move ctor
Myclass& operator = (const Myclass &); //copy assignment
Myclass& operator = (Myclass &&); //move assignment
---------------------------------------------

steal
T x = T türünden bir başka nesne

y = T türünden bir başka nesne

sınıf türünden bir ifade eğer R value bir değer kategorisindeyse

-------

move constructor:
-----------------

class Myclass {
public:
Myclass(); //default ctor
~Myclass(); //destrucotr
Myclass(const Myclass&); // copy ctor, paramtresi L value referans, kaynağını kopyalıycak
Myclass(Myclass&&); //move ctor, parametresi R value referans, kaynağını çalıcak
Myclass& operator = (const Myclass &); //copy assignment
Myclass& operator = (Myclass &&); //move assignment
}

!! move'da  bütün hikaye diğer nesnenin kaynağını çalıp diğer nesneyi distroctıbıl ama kaynağı geri verilmeyecek bir state sokmamız gerekiyor

--------------------------------

T x = init

!! derleyici copy ctor mı çağırılıcak move ctor mu çağrılıcağını ilk değer veren ifadenin R value'mu L value'mu dilin kurallarına güvenerek
dayanarak anlıyor

class Myclass {


};

void func(const Myclass&)
{
std::cout << "const Myclass&\n";
}

void func(const Myclass&&)
{
std::cout << "const Myclass&&\n";
}

int main()
{
Myclass m;
func(m); //1. çağrılır
func(static<Myclass&&>(m)); //sağ taraf referans türrüne cast ederiz, 2.çağrılır
func(std::move(m)); //yukarıdaki gibi yazmaktan hiçbir farkı yoktur, misnomer
func(Myclass{}); //2. çağrılır, R value exp.
}

!!MOVE DOESEN'T MOVE
------------------------

//mülakat sorusu

class Myclass {
public:
Myclass() = default;
Myclass(const Myclass&)
{
std::cout<< "copy ctor\n";
}

Myclass(Myclass&&)
{
std::cout<< "move ctor\n";
}
};

void func(const Myclass&)
{
std::cout << "const Myclass&\n";
}

void func(const Myclass&& r) //burası çağrılır
{
std::cout << "const Myclass&&\n";
}

int main()
{
Myclass m;
func(std::move(m)); //hiçbir nesne çağrılmaz çünkü referans nesneye bağlanır
Myclass &&r = std::move(m);
}

---------
class Myclass {
public:
};

void func(const Myclass&)
{
std::cout << "const Myclass&\n";
}

void func(const Myclass&&) //burası çağrılır
{
std::cout << "const Myclass&&\n";
}

void foo(Myclass &&r ) 
{

func(r);
}

int main()
{
Myclass m;
foo(std::move(m));
}

-----------------------

class Myclass {
public:
Myclass() = default;
Myclass(const Myclass&)
{
std::cout<< "copy ctor\n";
}

Myclass(Myclass&&)
{
std::cout<< "move ctor\n";
}
};

void foo(const Myclass &other)
{
Myclass m(other); //copy
}

void foo(Myclass&&)
{
Myclass m(other); //copy const
Myclass m(std::move(other)); //move const

}

int main()
{
Myclass m;
//öyle bir kod yaz ki
foo(m); //böyle yazılırsa copy ctor yazısı
foo(std::move(m))); //böyle yazılırsa move
}

----------

class Myclass {
public:
Myclass() = default;
Myclass(const Myclass&)
{
std::cout<< "copy ctor\n";
}

Myclass(Myclass&&)
{
std::cout<< "move ctor\n";
}
Myclass& operator=(const &other);
Myclass& operator=(Myclass&&);
};

void foo(const Myclass &other)
{
Myclass m;
m = other;
}

void foo(Myclass&& other)
{
Myclass m; //copy const
m = std::move(other);
}

int main()
{
Myclass m;
//öyle bir kod yaz ki
foo(m); //böyle yazılırsa copy ctor yazısı
foo(std::move(m))); //böyle yazılırsa move
}

-----------------------------------

!!!! hiçbir şey aklında kalmadıysa buraya bak

Myclass &r =
Myclass &&rr =

// ister sol taraf referansı olsun ister sağ taraf referansı olsun bir referans var ise 
o referansın oluşturduğu ismin value kategorisi her zman l value expresiondur

!! data type başka value kategory başka şeylerdir

Myclass &&rr

rr bir tür
ama bu ifadenin değer kategorisi L value exp.

-------------

derleyicinin yazdığı move constructer

class Nec {

};

void func(const Nec&); //1
void func(Nec&&); //2

int main()
{
Nec nec;
func(nec); // 1 çağrılır
func(Nec{}); //2 çağrılır
}

---------

!! bir sınııfın hem copy constructerı hem move constructarı var ise

class Nec {
public:
Nec(const Nec&); //sol taraf değeri içn bu
Nec(Nec&&); //sağ taraf değeri için bu

!! ama move constructer olmaz ise sağ taraf değeride sol taraf değeride copy constrıuctea gelicek

};

-----------

int main()
{
int x = 5; //value kategorisi yok
x; //l value
std::move(x); //value kategorisi yok, value kategory değiştiricek bir ifade yazıldı
}

----------

Derleyicinin yazdığı move constructer:
---------------------------------------

Myclass(Myclass &&other) : ax(other.ax), bx(other.bx), cx(other.mx) {}
Myclass& operator=(const Myclass& other)
{
ax = other.ax;
bx = other.bx;
cx = other.cx;

return *this;
}

Myclass(Myclass &&other) :
ax(std::move(other.ax)), bx(std::move(other.bx)), cx(std::move(other.cx))
{

}

  

private:
A ax;
B bx;
C cx;
}
--------

class Person {
private:
std::string name;
std::string surname;
std::string adress;
std::vector<int> grades;
}

-----------

move ctor kodunun yazılması:
------------------------------

#include <iostream>
#include <string>
#include <cstring>

class Addrees
{
public:
  Addrees(const char *p) : mlen(std::strlen(p)), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::cout << static_cast<void *>(mp) << "adresindeki bellek blogu edinildi\n"; // yazının tutulduğu adresi yazdırır
    std::strcpy(mp, p);
  }

  Addrees(const Addrees &other) : mlen(other.mlen), mp{static_cast<char *>(std::malloc(mlen + 1))}
  {
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
  }

  Addrees(Addrees&& other) : mlen(other.mlen), mp(other.mp)
  {
    other.mlen = 0;
    other.mp = nullptr;
  }

  Addrees &operator=(const Addrees &other)
  {
    // genel herhangi bir sınıf için
    std::free(mp);
    mlen = other.mlen;

    mp = static_cast<char *>(std::malloc(mlen + 1));
    if (!mp)
    {
      throw std::runtime_error{"not enough memory"};
    }
    std::strcpy(mp, other.mp);
    return *this;
  }

  ~Addrees()
  {
    if (mp)
      std::free(mp);
    
  }
  void print() const
  {
    std::cout << mp << '\n';
  }
  std::size_t lenght() const
  {
    return mlen;
  }

private:
  std::size_t mlen;
  char *mp;
};

void process_address(Addrees x)
{
  std::cout << "process_address fonsksiyonu cagrildi\n";
  x.print();
  (void)getchar();
}

int main()
{
  using namespace std;

  Addrees adx{"buyukdere mah. ozan sokak. no 12 istanbul"};
  Addrees ady{"bahcelievler derin sokak 45 / 7 ankara"};

  adx.operator=(ady).print();
}



-------------

derleyicinin yazdığı move assignment:
-------------------------------------

Myclass(const Myclass &&other) : ax(other.ax), bx(other.bx), cx(other.mx) {}
Myclass& operator=(const Myclass& other)
{
ax = other.ax;
bx = other.bx;
cx = other.cx;

return *this;
}

Myclass(Myclass &&other) :
ax(std::move(other.ax)), bx(std::move(other.bx)), cx(std::move(other.cx)),
{

}

Myclass& operator=(Myclass &&other)
{
ax = std::move(other.ax);
bx = std::move(other.bx);
cx = std::move(other.cx);

return * this
}

private:
A ax;
B bx;
C cx;
}

-----------------------------

!! ezber gerektiren bir kısım

hangi durumda derleyici sınıfn hangi özel üye fonskiyonunu yazar
------
!!! BU KISIM İÇİN PC'DE TABLO VAR ONU KULLAN
1)
//hiçbir özel üye belirtmessek 6 özel üyeyi'de yazar
class Myclass{

};

class Myclass{
public:
Myclass() = default;
~Myclass() = default;
Myclass(const Myclass&) = default;
Myclass(Myclass&&) = default;
Myclass& operator=(const Myclass&) = default;
Myclass& operator=(Myclass&&) = default;
};

----------
2)eğer sınıfa default ctor olmayann ama special member functionda olmayan
bir ctor yazarsak default ctor olmaz diğerleir olur

class Myclass{
public:
~Myclass() = default;
Myclass(const Myclass&) = default;
Myclass(Myclass&&) = default;
Myclass& operator=(const Myclass&) = default;
Myclass& operator=(Myclass&&) = default;
};
----------
3)eğer default ctor bildirirsek yani user declareted ise 

class Myclass{
public:
Myclass();
};

class Myclass{
public:
Myclass() = default;
~Myclass() = default;
Myclass(const Myclass&) = default;
Myclass(Myclass&&) = default;
Myclass& operator=(const Myclass&) = default;
Myclass& operator=(Myclass&&) = default;
};
---------
4)sınıfa destructor bildirirsek
class Myclass{
public:
~Myclass();
};

class Myclass{
public:
Myclass() = default;
~Myclass() ;
Myclass(const Myclass&) = default; //felakte yol açar
Myclass& operator=(const Myclass&) = default; //ASLA YAPMA
//NO MOVE MEMBERS
};
--------
5)sınıfa copy ctor bildirdik
class Myclass{
public:
Myclass(const Myclass&);
};

class Myclass{
public:
//no default ctor
~Myclass() ;
Myclass(const Myclass&);
Myclass& operator=(const Myclass&) = default; //felaket
//NO MOVE MEMBERS
};
---------
6)copy assignment biz yazarsak
class Myclass{
public:
Myclass& operator=(const Myclass&);
};

class Myclass{
public:
Myclass() = default;
~Myclass() = default;
Myclass(const Myclass&) = default; //felakte yol açar
Myclass& operator=(const Myclass&); 
//NO MOVE MEMBERS
};
-------
7)
class Myclass{
public:
Myclass(Myclass&&);
};

class Myclass{
public:
~Myclass() = default;
Myclass(const Myclass&) = delete
Myclass(Myclass&&);
Myclass& operator=(const Myclass&) = delete
//NO MOVE ASSİGNMENT
};
---------
8)
class Myclass{
public:
Myclass&operator=(Myclass&&);
};

class Myclass{
public:
Myclass() = default;
~Myclass() = default ;
Myclass(const Myclass&) = delete
Myclass(Myclass&&);
Myclass& operator=(const Myclass&) = delete; //ASLA YAPMA
Myclass&operator=(Myclass&&);
//NO MOVE ctor
};

/////////////////////////////////////////////2. Ders////////////////////////////////////

//special member tablosuna göre konuşuyoruz

class Date {

private:
int md{1}, mm{1}, my{1970}; //default ctor derleyici yazmasını sağlayabilirz
};

--------

//sınıfın kopyalamaya karşı kapatılması taşımaya açılması

sıfın move memberları olucak ancak copy delete edilcek böyle sınıflara move only-type denir

!! asla move memberları delete etme

class Neco {
public: 
Neco();
Neco(const Neco&) = delete;
Neco& operator=(const Neco&) = delete;
Neco(Neco&&);
Neco& operator=(Neco&&);
private:

};

-----

class Member {
public :
Member(int);
Member(int,int);
private:

};

class Nec {
public :

private:
Member mx; //hata yok
}

int main()
{
Nec mynec; //burada hata olur
}

-----

class Member {
public :
Member(int);
Member(int,int);
private:

};

class Nec {
public :
Member(int);
Member(int, int);
Member() = delete; 

private:
Member mx; //hata yok
}

int main()
{
Nec mynec; //burada hata olur
}

---------------------------

temporary objects: nesneyi isimlendirmeden kullanmaya denir. runtime'da nesne var ortalıkta nesne yok
------------------

class Myclass {
public:
Myclass()
{
std::cout << "default ctor\n";
std::cout << "this = " << this << '\n';
std::cout << "-----------------------------\n";
}

~Myclass()
{
std::cout << "destructor\n";
std::cout << "this = " << this << '\n';
std::cout << "-----------------------------\n";
}

Myclass(int x)
{
std::cout << "Myclass(int x) x = " << x << '\n';
std::cout << "this = " << this << '\n';
std::cout << "-----------------------------\n";
}

};

int main()
{
Myclass m1;
Myclass m2(35);

Myclass(); //bu geçerlidir
Myclass{}; //bu da geçerlidir
Myclass(12); //bu da geçerlidir

//bir çok durumda isimlendirililmiş nesne kullanmak yerine temporary nesne kullanılır
//bunun bize faydaları vardır
}

----

int main()
{
Myclass m;
func(m); //böyle kullanmanın dezavantajları vardır
//okuyan bunun daha sonra da kullanıcağını düşünür scope'undan dolayı

func(Myclass{12}); //madotory copy elision geçici nesne kullanınca kodu okuyan niyetimizi anlar

}

 !!isimlendirilmemiş nesne işimizi görüyorsa isimlendirilmemiş nesne kullan buna temporary object denir

------

int main()
{
Myclass{}; //tempory object değer kategorisi pr value

Myclass&r = Myclass{}; //geçersiz
const Myclass&r = Myclass{}; //geçerli
Myclass&&r = Myclass{}; //geçerli
}

------

void foo(Myclass);
void bar(Myclass &);
void baz(const Myclass &);
void func(Myclass &&);

int main()
{
foo(Myclass{}); //geçerli
bar(Myclass{}); //geçersiz
baz(Myclass{}); //geçerli
func(Myclass{}); //geçerli
}

---------
//life extension kuralı : normalde bir geçici nesne oluştuğğunda hayata gelen
geçici nesneyi içine alan ifadenin yürütülmesiyle sona erer 

int main()
{
std::cout << "[1]\n";
{
//Myclass{}; //geçici nesne alt satıra geçmden hayatı biter
const Myclass& r = Myclass{}; //geçici nesnyee bağlar isek life extension uygulanır
std::cout << "[2]\n";
}
std::cout << "[3]\n";
}

------

Myclass foo()
{
return Myclass{};
}

int main()
{
//Myclass &r = foo(); //legal olmaz, l value ref. r value ref'e bağlanmak isteniyor
const Myclass &r = foo(); //bu şekilde hata olmaz
Myclass &&R = foo(); //geçerli
}

---------------------

move-from state (taşınmış nesne durumu):
----------------------------------------

std::string foo();

int main()
{
using namespace std;
string s;

s = foo(); //R value referans olduğu için move assignment çağrıllır, L value olsaydı copy çağrılırdı
//s için tekrar dinamik bellek alanı edinilmez sadece pointerlar kopyalanır
//ciddi verim kazanılır
s = std::string(100'000, 'A'); //move assignment çağrılı
//taşıma semantiğinin devreye girmesi için özel bir şey yapmamız gerekmiyor

}

-------------

Özel durum :

std::string foo();

int main()
{
using namespace std;
string s;

string str(200'000, 'Z');
string sx = str; //copy assignment çağrılır     
string sx = std::move(str); //böyle bir kod ile gel beni çal demek istiyoruz, move ctor oldu
s = std::move(str); //move assignment 
//burada str destructor çağrılmamıştır scope sonunda çağrılır

}

---

std::string foo();

int main()
{
using namespace std;
string sx;

{
string str(200'000, 'Z');

sx = std::move(str);
//burada str hayatta ama kaynağıda çalınmış durumda (str is moved_from state)
}
sx
}

// tipik olarak (böyle bir sorumluluk yok) move member'lar kaynağı çalınmış nesneyi
kaynağı çalınmış diğer nesneyi default contruct edilmiş şekilde state bırakır 

------

kaynağı çalınmış nesne:
a) geçerli bir durumda
in a valid state

b) it's value unkown (değeri bilinmiyor

-----

std::string foo();

int main()
{
using namespace std;
string sx;

{
string str(200'000, 'Z');

sx = std::move(str);

cout << str << "\n"; //geçerli
//moved_from state'i sadece ona yeni bir atama yaparak kullanabilirim
}

}

!! kaynağı çalınmış bir nesneyi atama yoluyla kullanabilinir duurmda bırakmamız gerekir

-------
//bu kodu şimdilik anlamaya çalışma
//necati hoca mülakatlarda bunu çok soruyor yorum istiyor
int main()
{
using namespace std;

ifstream ifs {"notlar.txt"};

string sline;
vector<string> svec;

while (getline(ifs, sline)){
cout << sline <<'\n';
svec.push_back(std::move);
//svec.push_back(std::move(sline)); böyel olmalı
}
}

-----------------------

conversion contructor (dönüştüren kurucu işlev): myclass sınıfına dönüüşüm içindir
------------------------------------------------

class Myclass {
public:
Myclass() =default;
Myclass(int); //sentax hatası ortadan kalkar
};

int main()
{
Myclass mx;
mx = 5; //sağ taraf int sol taraf myclass (hata)
}

------

class Myclass {
public:
Myclass() =default;
Myclass(int x)
{
std::cout << "Myclass(int x) x = " << x << "\n"; 
std::cout << "this = " << this << '\n';   
}
};

int main()
{
Myclass mx;
mx = 5;
//örtülü olarak int türden  bir nesneyi mclass sıfına dönüştürür
}

------

class Myclass {
public:
Myclass() =default;

Myclass(int x)
{
std::cout << "Myclass(int x) x = " << x << "\n"; 
std::cout << "this = " << this << '\n';   
}

Myclass& operator=(const Myclass& r)
{
std::cout << "Myclass copy asssignment this = " << this << "\n";
std::cout << "&r = " << &r << '\n';
return *this;
}

Myclass& operator=(const Myclass&& r)
{
std::cout << "Myclass move asssignment this = " << this << "\n";
std::cout << "&r = " << &r << '\n';
return *this;
}

~Myclass()
{
std::cout << "Myclass destructor this = " << this << '\n';
}
};

int main()
{
Myclass mx;
std::cout << "&mx = " << &mx << '\n';
std::cout << "main [1]\n";
//ctor
mx = 5; //buraya çağrı yapılır ve geciçi nesne oluşturulur
//dtor
std::cout << "main [2]\n";
}

-----------

class Myclass {
public:
Myclass(int);
};

void func(Myclass);

int main()
{
func(12);
}
//bu kodun geçerli olmasının nedeni user defined gerçekleştii içindir

------

class Myclass {
public:
Myclass();
Myclass(int);
};

int main()
{
Myclass m;
m = 3.2323; //legal

}

-----

class Myclass {
public:
Myclass();
Myclass(bool);
};

int main()
{
Myclass m;
int x = 10;

m =&x; //geçerli
}

-----

class Myclass {
public:
Myclass();
Myclass(int);
};

int main()
{
Myclass m;
int x = 10;
int *ptr = nullptr;
m = ptr;
}

--------------

type cast operator function:
----------------------------

eğer bir dönüşüm aşağıdaki dönüşüm sekanslarından biriyle
gerçekleştiribiliyor ise derleyici bu dönüşümü örtülü olarak yapmak zorunda

user-defined connversion + standart conversioni
standart conversion + user defined conversion

class Myclass {
public:
Myclass();
Myclass(bool);
};

int main()
{
Myclass m;
int x = 10;
int *ptr = nullptr;

m = ptr;

//pointer to int türünden bool'a standart conversion var
//bool'dan myclass'a user defined conversion var
//derleyici 'standart conversion + user defined conversion' bu şekilde dönüşümü yapar
}

------

class Myclass {
public:
Myclass();
Myclass(bool);
};

int main()
{
Myclass m;
double dval = 32.5;
m = dval;

'standart conversion + user defined conversion' derleyici bu şekilde dönüşüm yapar
}

--------

user defined conversion + user defined conversion, bunu örtülü olarak yapamaz

class A {

};

class B {
public:
B();
B(A);
};

int main()
{
A ax;
B bx;

bx = ax; //conversion constructer
}

-------

class A {
public:
A(int);
};

class B {
public:
B();
B(A);
};

int main()
{
A ax;
B bx;

bx = bx;
bx = 13; //hata bunu yapması için 2 tane user defined yapması gerekir
//inr ==> A (user defined)
A ==> B (user defined)
!! tür dönüüştürme kullanırsak geçerli olur
//bx = static_cast<A>(13);
}

----------

conversion constructer genel olarak bizim için ciddi bir risktir

class String {
public:
String(const char *);
};

int main()
{
String = "Onur Yagar"; //legal
}

-------

int main()
{
using namespace std;
vector<int> ivec(1234); //1234 tane int tutar
}

------

int main()
{
using namespace std;
int ival = 4343;
vector<int> ivec;

ivec = ival; //böyle bir senaryo geçerli olsa idi felaket olurdu
//bunun hata olması aşağıdaki konu ile alakalı
}

--------------------

explicit ctor: c++ dilinin önemli anahtar sözcüklerinden biridir
-------------

imlicit conversion : derleyicinin durumdan vazife çıkartarak dilin kuralları gereği yaptığı örtülü dönüşüm
explicit conversion : tür dönüştüme operatörü ile yapılan dönüşüm

class Myclass {

public:
Myclass();
explicit Myclass(int); //bu ctor implict dönüşüm yapmaz sadece explicit dönüşüm yapar demektir
};

---------

class Myclass {
public :
Myclass();
Myclass(int);
};

int main()
{
Myclass m;
m = 23; //legal
}

-----

class Myclass {
public :
Myclass();
emplicit Myclass(int); //kazara implicit coversion yapmasını  enggeliyoruz
};

int main()
{
Myclass m;
m = 23; //illegal
m = static_cast<Myclass>(23); //legal
}


------------

!! Bir sınıfın (özellikle) tek paramtereli ctor'larını (aksi yönde karar almanızı gerektiricek makul bir neden olmadıkça)
explicit yapınız

class Myclass {
public:
explicit Myclass(int);
};

int main()
{
Myclass m1(19);
Myclass m2{35};
Myclass m3 = 57; //copy init, sentax hatası
}

-----------
//kod anlamaya çalışma

int main()
{
using namespace std;

unique_ptr<int> p1{new int};
unique_ptr<int> p2(new int);
unique_ptr<int> p3 = new int; //sentax hatası
}

-------
//Mülakatalarda sorulan bir soru

class Myclass {
public:
explicit Myclass(double);
Myclass(int);
};

int main()
{
Myclass m = 45.98; //hata olmaz, int çağrılır
}

!! explicit ctor copy init durumunda overload sete hiç girmez

-----------

class Myclass {
public:
Myclass();
};

int main()
{
Myclass m{}; //geçerli
}

----------

class Myclass {
public:
Myclass();
};

void func(Myclass);

Myclass foo()
{
return Myclass(); //legal
return Myclass{};//legal
return {};//legal
}

int main()
{
func(Myclass());
func(Myclass{});
func({});
}

-------

class Myclass {
public:
emplicit Myclass();
};

void func(Myclass);

Myclass foo()
{
//return Myclass();
//return Myclass{};
return {};//hata
}

int main()
{
Myclass m = {}; //Hata
func(Myclass());
func(Myclass{});
func({});
}

--------

iki parametreli ctor

class Myclass {
public:
Myclass(int, int); //legaldir ancak exlicit yaparsak hepsi hata oolur
};

void foo(Myclass);

Myclass bar()
{
return {56, 21};
}

int main()
{
Myclass m = {12, 67};
foo({347, 871});   
}

//////////////////////////////////////////////3. Ders/////////////////////////////////////////

copy elision
C++17 (mandotory copy eln)
RVO
NRVO

dinamik ömürlü ifadeler
new ifadeleri
delete ifadeleri
operator new fonksiyonları
operator delete fonksiyonları


-----------------

copy elision (kopyalamamanın yapılmaması):
------------------------------------------
-maaliyetin yüksek olduğu zamanlar için önem taşır

-copy elision kopyalama yerine move demek değildir

-ne copy çağırılıcak ne move çağırılıcak
 
------
!! move ctor yok ise copy ctor çağrılır

------

class Myclass
{
public:
  Myclass() // default ctor
  {
    std::cout << "default ctor\n";
  }
  ~Myclass() // dtor
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(int)
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(const Myclass &)
  {
    std::cout << "copy ctor\n";
  }
  Myclass(Myclass &&)
  {
    std::cout << "copy ctor\n";
  }
  Myclass &operator=(const Myclass &)
  {
    std::cout << "copy assignment\n";
    return *this;
  }
  /*Myclass &operator=(Myclass &&)
  {
    std::cout << "move assignment\n";
    return *this;
  }*/
};

void foo(Myclass x)
{
std::cout << "foo()\n";
}

int main()
{
foo(Myclass{}); //geçici nesne
}
//normalde beklenti aşağıdaki gibi çalışmasıdır ancak o şekilde olmaz
default ctor, copy ctor, dtor, dtor sırayıyla çıkmasıdır
//copy ctor çağrılmadı

----------

class Myclass
{
public:
  Myclass() // default ctor
  {
    std::cout << "default ctor\n";
  }
  ~Myclass() // dtor
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(int)
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(const Myclass &) = delete
};

void foo(Myclass x)
{
std::cout << "foo()\n";
}

int main()
{
foo(Myclass{}); //cpp 17 öncesinde hata verir
}

---------
!! bir fonksiyonun paramteresini sınıf türünden yaparsak ve fonksiyonu pr value exp ile çağırırsak
c++17 öncesinde derleyiciler opt. yaparak önce gecici nesnyei oluşturmak yerine doğrudan paramtere değişkeni yerine oluşturuyolar


c++17 öncesinde 'Myclass{}' nesne statüsündeydi

modern c++ pr value exp olan ifadeler doğrudan bir sınıf nesnesi değil, sınıf nesnesi haline glmesi için bazı seneryoların gerçekleşmesi gerekiyor
bu seneryolara temporary materialization denir.

temporary materialization : geçici nesne oluşturma

---------
class Myclass
{
public:
  Myclass() // default ctor
  {
    std::cout << "default ctor\n";
  }
  ~Myclass() // dtor
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(int)
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(const Myclass &) = delete
};

void foo(Myclass x)
{
std::cout << "foo()\n";
}

//temporary materialization 

int main()
{
Myclass{};
}

--------
temporary materialization hangi durumlarda olabilir :

1)

class Myclass
{
public:
  Myclass() // default ctor
  {
    std::cout << "default ctor\n";
  }
  ~Myclass() // dtor
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(int)
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(const Myclass &) = delete
};

void foo(Myclass x)
{
std::cout << "foo()\n";
}

int main()
{
//standarta göre copy olmadığı için hata olmaz

Myclass x = Myclass{}; //geçici nesne bir başka değere atanıyor
const Myclass &x = Myclass{}; //referansa bağlanabilir
foo(Myclass{Myclass{Myclass{}}}); //bir kere default ctor çağrılır
}

çıkan sonuçlar :
-kağıt üstünde bir kopyalama olmaz
-kopyalama olmadığı için derleyicinin opt. switchleri ile oynasakta kopyalama olmıycak
-delete edilmesi halinde de sentax hatası olmıycak


-------------

class Myclass
{
public:
  Myclass() // default ctor
  {
    std::cout << "default ctor\n";
  }
  ~Myclass() // dtor
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(int)
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(const Myclass &) = delete
};

void foo(Myclass x)
{

}

int main()
{
foo(Myclass{46}); //int parametreli ctor çağrılır
}

---------

!! ÇOK ÖENMLİ

2. seneryo : RVO(return value opt.)
----------

class Myclass
{
public:
  Myclass() // default ctor
  {
    std::cout << "default ctor\n";
  }
  ~Myclass() // dtor
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(int)
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(const Myclass&) = delete;
};

Myclass foo(int n)
{
//code

return Myclass{n};
}

int main()
{
Myclass m = foo(13); //eskiden derleyicinin yaptığı opt. göre 1-2 kere copy çağırıloyordu
//şimdi mandotory copy söz konusu delete edilmesine rağmen sentax hatası olmaz
}

// fonksiyonun return ifadesi pr value ifadesi ise mandotory copy elision olucak

//eskiden RVO opt. du şimdi dilin kuralı oldu
--------

std::string foo() //fonksiyonun geri dönüş değeri sınıf türünden yapılır
{
return 
}

------------

NRVO (named return value optimization)
-------------------------------------

NRVO : Mondotory değildir

std::string foo()
{
std::string str(1000, 'A');

str += "xxxxxx";

return str;
}

int main()
{
std::string s = foo();

//normalde move ctor çağrılıcıak string kütüphanesinin move ctor'u yoksa (var) vopy ctor çağrılıcak
}

-----------

class Myclass
{
public:
  Myclass() // default ctor
  {
    std::cout << "default ctor\n";
  }
  ~Myclass() // dtor
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(int)
  {
    std::cout << "Myclass(int)\n";
  }
  Myclass(const Myclass &)
  {
    std::cout << "copy ctor\n";
  }
  Myclass(Myclass &&)
  {
    std::cout << "copy ctor\n";
  }
  Myclass &operator=(const Myclass &)
  {
    std::cout << "copy assignment\n";
    return *this;
  }
  Myclass &operator=(Myclass &&)
  {
    std::cout << "move assignment\n";
    return *this;
  }

  void foo() {}
  void bar() {}
  void baz() {}
};

Myclass func()
{
Myclass m(365);
std::cout << "&m = " << &m << '\n';

m.foo();
m.baz();
m.bar();

return m;
}

int main()
{
Myclass nec = func();
std::cout << "&nec = " << &nec << '\n';
//aynı adres çıkar
}

-----------

class Myclass {

public :
std::string m_str;
std::vector<int>m_vec;
};

Myclass foo();

int main()
{
Myclass m;

m = foo();
}

//bu kod move assignment değilde copy assignment olsaydı çok maaliyetli olurdu

-------

class Myclass {

public :
std::string m_str;
std::vector<int>m_vec;
};

Myclass foo();

int main()
{
Myclass m = foo();
}

//ne copy ne move çağırılır mandortory copy elision olucak

----------

-copy ctor
-move ctor
-copy elision

en maaliyetliden maaliyetsize
copy ctor > move ctor > copy elision 

----------

class Date {
int d, m, y;
};

class Myclass {
Date mdate;
int a[1000];
};

Myclass foo();

int main()
{
Myclass m = foo();

m = foo();
}

//move ctor çağrılıcak ancak faydası yoktur
copy ile farkı olmaz bu durumda

--------

int main()
{
Myclass m; //default ctor
m = foo(); //move ctor

//c++ dilinde yukarıdaki ve aşağıdaki arasında büyük fark vardır

Myclass m2 = foo(); //gecici bir nesne ise mandortory, otomatik bir nesne ise NRVO olur

}

-------------------
copy elision
----------
1) temporary object passing (mandotory), copy ctor delete edilmiş olsa dahi sentax hatası olmaz
2) returning a temporary object (mandotory), copy ctor delete edilmiş olsa dahi sentax hatası olmaz
3) returning an object of automatic storage class (optimizat, on)

----------------

factory function
---------------

class Point {
public:
Point(int, int, int);
private:
};

Point MakePoint(int x)
{
return Point{x, x, x};
}

int main()
{
auto p = MakePoint(3);
Point p {3,3,3}; //assembly tarafında aynı anlama gelir
}

----------

class MoveOnly {
public:
  MoveOnly() = default;
  MoceOnly(const MoveOnly&) = delete; //copy'leri delete etmesekde movelar onları delete edicek, ancak anlaşılır olması nedeni ile böyle yazılrı
  MoveOnly& operator(const MoveOnly&) = delete;
  MoveOnly(MoveOnly&&);
  MoveOnly&operator=(MoveOnly&&);
};

MoveOnly foo()
{
MoveOnly x;
return x; //buras l value olduğu için normalde copt ctor çağrılması gerekir 
//copy ctor çağrıldığı içinde sentax hatası olması gerekir
//ancak geri dönüş değerini otomatik bir nesneye atadığımız zaman derleyici L value to x value dönüşümü yapar ve hata olmaz
//return std::move(x); //pessimistic move, bunu yapma bunu yaparsan copy elision devre dışı kalır
}

int main()
{
MoveOnly x;
x = foo(); 
}

----------------------------------------------------

Dinamik Ömürlü Nesneler:
------------------------

1) automatic storage class 
  a) global nesneler
  b) static yerel nesneler
  c) sınıfların static veri elemanlar (static data members)
2) static storage class
  a) parameters
  b) local variabler
3) dynamic storage class
  a) new
  b) delete
4) thread-local storage class

--------------

new expression/operator
-----------------------

dinamik ömürlü bir nesne hayata getirmek için new kullanmak gerekir

new mMyclass
new int
new double


new operatoründe c dilinde farklı olarak c dilinde malloc çağrılırdı
new operatöründe operator new çağrılır

new Fighter
void* operator new(std::size_t)

static_cast<Fighter *>(operator new(sizeof(Fighter)))->Fighter()
//ifadenin türü fighter *

derleyici önce
-operatör new fonksiyonunu çağırır
-operatör new fonksiyonuna türün sizeof değerini çağırır
-operator new başarısız olursa exension trow ediyror başarılı olursa  elde edilen adresi döndürüyor

---------

class Myclass {
public:
Myclass()
{
std::cout << "default ctor this = " << this << '\n';
}

~Myclass()
{
std::cout << "destructor ctor this = " << this << '\n';
}

void foo() {}
void bar() {}
};



int main()
{
Myclass * p1 = new Myclass;
auto p1 = new Myclass; //aynı anlamda 3'ü
auto * p3 = new Myclass;

std::cout << "p = " << p << '\n';

(*p).foo();
(*p).bar();
p->foo();
p->bar();

//ctor ve new çağrılıcıak dtor çağrılmıycak nesnein hayatının bitmesi içn delete kullanmamız gerekicek
}

----------

class Myclass {
public:
Myclass()
{
std::cout << "default ctor this = " << this << '\n';
}

Myclass(int x, int y)
{
std::cout << "Myclass(int x, int y) x = " << x << " y = << y << '\n';
}

~Myclass()
{
std::cout << "destructor ctor this = " << this << '\n';
}

void foo() {}
void bar() {}
};


int main()
{
Myclass *p1 = new Myclass; //default ctor bu şekilde ve aşağıdaki 2 şekilde çağrılır
Myclass *p2 = new Myclass();
Myclass *p3 = new Myclass{};

Myclass *p3 = new Myclass(2,6);

}


-------

new operator = operatörün ismine denir
operator new = fonksiyonun ismine denir

--------

nesnenin hayatını bitirmek için delete anahtar kelimesini kullanırız

delete p
p-> ~Myclass()

-----

void* malloc(size_t n);
void free(void *);

void* operator new(size_t n);
void operator delete(void *);

-----

class Myclass {
public:
Myclass()
{
std::cout << "default ctor this = " << this << '\n';
}

Myclass(int x, int y)
{
std::cout << "Myclass(int x, int y) x = " << x << " y = << y << '\n';
}

~Myclass()
{
std::cout << "destructor ctor this = " << this << '\n';
}

void foo() {
std::cout << "Myclass::foo() this = " << this << '\n';
}
void bar() {
std::cout << "Myclass::bar() this = " << this << '\n';

}
};

int main()
{
using namespace std;

std::cout << "main [1]\n";
auto p = new Myclass(3, 7);
p->bar();
p->foo();
delete p;
std::cout << "main [2]\n";
}

delete etmemek dtor çağrılmaz dtor çağrılmassa kaynaklar geri verilmez
-----------

!! modern cpp de artık new çok nadir kullanılır buna daha sonra değineceğiz

üretime bu şekilde yazılır
--------------------------

class Myclass {
public:
Myclass()
{
std::cout << "default ctor this = " << this << '\n';
}

Myclass(int x, int y)
{
std::cout << "Myclass(int x, int y) x = " << x << " y = << y << '\n';
}

~Myclass()
{
std::cout << "destructor ctor this = " << this << '\n';
}

void foo() {
std::cout << "Myclass::foo() this = " << this << '\n';
}
void bar() {
std::cout << "Myclass::bar() this = " << this << '\n';

}
};

int main()
{
using namespace std;

std::cout << "main [1]\n";
{
auto p = make_unique<Myclass>();
p->bar();
p->foo();
}

std::cout << "main [2]\n";
}

--------------------

raw pointer/naked pointer c'den gelen pointer

smart pointer : gerçekte sınıf nesnesi ancak pointer gibi davranır
  raw pointer
  naked pointer

------------------

class Myclass {
public:
Myclass()
{
std::cout << "default ctor this = " << this << '\n';
}

Myclass(int x, int y)
{
std::cout << "Myclass(int x, int y) x = " << x << " y = << y << '\n';
}

~Myclass()
{
std::cout << "destructor ctor this = " << this << '\n';
}

void foo() {
std::cout << "Myclass::foo() this = " << this << '\n';
}
void bar() {
std::cout << "Myclass::bar() this = " << this << '\n';

}
};

void* operator new(std::size_t sz)
{
std::cout << "operator new called for the size of : " << sz << "\n";

if (sz == 0)
++sz;
if (void* ptr = std::malloc(sz))
return ptr;
throw std::bad_alloc{};
}

void operator delete(void* ptr) noexcept
{
std::cout << "operator delete called for the address of : " << ptr << "\n";
std::free(ptr);  
}

------
Derleyicinin new ve delete için yazdığı kod:

class Myclass {
public:
Myclass()
{
std::cout << "default ctor this = " << this << '\n';
}

Myclass(int x, int y)
{
std::cout << "Myclass(int x, int y) x = " << x << " y = << y << '\n';
}

~Myclass()
{
std::cout << "destructor ctor this = " << this << '\n';
}

void foo() {
std::cout << "Myclass::foo() this = " << this << '\n';
}
void bar() {
std::cout << "Myclass::bar() this = " << this << '\n';

}
};


void* operator new(std::size_t sz)
{
std::cout << "operator new called for the size of : " << sz << "\n";
auto vp = std::malloc(sz);
if (!vp) {
throw std::bad_alloc{}
}
std::cout << "the address of allocated block is << vp << '\n';
return vp;
}

void operator delte(void* vp)
{
std::cout << "operator delete called vp = " << vp << '\n';
std::free(vp);
}

int main()
{
using namespcae std;

cout << "sizeof(Myclass) = " << sizeof(Myclass) << '\n';
Myclass *p = new Myclass;
p->foo();
delete p;

std::cout << "main devam ediyor\n";
}

-----------

!! operator new fonksiyonu allocated ettiğim new fonksiyonunu free fonksiyonu ile geri veremeyiz

int main()
{
Myclass *p = new Myclass;
free(p); //ub
}

----------------

array new: aaray oluşturuyor
---------

new int[expr]; //expr kaç ise o kadar sayı da nesneye sahip bir dinamik dizi oluşturur


int main()
{
std::cout << "kac tam sayı: ";
std::size_t n;

std::cin >> n;
int *p = new int[n];
for (std::size_t i{} < n; ++i){
p[i] = i;
}
for (std::size_t i{}; i < n; ++i) {
std::cout << p[i] << '';
}

delete[] p;
}

------------------

class Myclass {
public:
Myclass()
{
std::cout << "default ctor this = " << this << '\n';
}

~Myclass()
{
std::cout << "destructor ctor this = " << this << '\n';
}

char buf[256] {};
};

int main()
{
std::cout << "sizeof(Myclass) = " << sizeof(Myclass) << "\n";
Myclass *p = new Myclass[10];
delete p; //ub
delete[] p; //bu şekilde olmalı
}

!!
array new ise array delete
new ise delete kullan

----------------------------------------------------

sınıfların static veri elemanları
sınıfların static üye fonksiyonları

operator overloading

namespace


--------------------------------------------------

sınıfların static veri elemanları:
----------------------------------

class Nec{
int mx;
void foo();
double d1, d2;
char s[36];
};

int main()
{
std::cout << "sizeof(Nec) = " << sizeof(Nec) << "\n";
}

//veri elemanı eklendikçe sizeof artar

----------

class Nec {
static int mx; //derleyici yer ayrımaz
};

//sınıfların static veri elemanları static anahtar sözcüğü ile bildiriliyor
//bu (tanımlama olmayan) (non-defined declaration)

--------
Aşağıdaki gibi tanımlanmalı

//nec.h
class Nec {
static int mx;
};

//nec.cpp

int Nec::mx;

----------


//assembly tarafında global değişkenlerden hiçbir farkı yoktur
//dil katmanında farklılık vardır

-----------

class Nec{
public:
static int mx;
};

int main()
{
Nec::mx; //sınıf dışında kullanırken bu şekilde kullanmalıyoz
}

-------

class Nec{
public:
static int mx;
};

int main()
{
Nec n1, n2;

n1.mx = 10;
n2.mx = 56;
auto p = &n1;
p-> mx = 854;
}
