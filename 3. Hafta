///////////////////////////////////////////////////////1. Ders///////////////////////////////////////////////

enum class TrafficLight {Red, Yellow, Green};
!! c++ da bu enum türündeki hataları ortadan kaldırmak için class kullanılmıştır           
!! enum class is not a class

enum Pos : int {On, Off, Hold, Standby};
enum Pos : long {On, Off, Hold, Standby};

// bu şekilde bellek ihtiyacını ayarlayabiliyoruz

enum Class Pos : int{On, Off, Hold, Standby};

------------------------------------

//sıralaması:
önce isim arama gerçekleşir bulunamassa sentaks hatası, daha sonra o ismin dilin kurallarını çiğneyip çiğnemediği kontrol edilir en sonda bağlam kontrolü yapılır

name lookup 
context control (sen
access control


int main()
{
int printf = 10;
printf("merhaba"); //sentaks hatası olur isim aramadan dolayı, 
isim 1 kere aranır
}

----------------------------------------------------

:: // scope resolution operator (çözünürlük operatörü)
binary ve unary şekilde kullanılır

int main()
{
int printf = 10;
::printf("merhaba"); //bu şekilde isim global isim alanında aranıcak
isim 1 kere aranır
}

----------

int g = 56;

int main()
{
int g = 10;

std::cout << "g = " << g << '\n'; //10
std::cout << "g = " << ::g << '\n'; //56
}

-----------

void func(int x)
{
int func = 40;
::func(func); //recursive fonksiyon çağrısı, fınc fonksiyonunu func değeri ile çağırırıyorum 
}

-------------

!! ::x //global isim alaında x yok ise hata olur
--------------
isimlerin kullanımı şu şekilde olur

unqualified name :
a

qualified name :
x::a
::b
x.y
c->y

------------------------------------------------------

enum class Color {blue, red, purple, white, black};
enum class TrafficLight {yellow,white, black};
!! class sayesinde isimler aynı olmasına rağmen çakışma olmaz

int main()
{
Color :: blue; //bu isimleri bu şekilde kullanırız
}

enum türlerinin 3. defosu : enum türlerinden aritmetik türlere örtülü dönüşüm vardı

int main()
{
Color mycolor{ Color:: Red};
int ival = mycolor; //Hata olur           
}

!! zorunda kalmadıkça uncscope enum kullanma, scope enum kullan

------------

enum class Color {blue, red, purple, white, black};

void func()
{
using enum Color; //c++20  nitelemeden kullanmamızı sağlar

Color c1 = Red; 
c1 = White;
Color c2 = Black
}

using Color :: Blue;

Color c1 = Blue;
Color c2 = Red; // hata sadece Blue nitelemden kullanılını

==============================================================

int getval();

int main()
{
if (int x = getval()) { //c dilinde gçerli değil c++'da bu şekilde kullanılabilinir
//scope leekage engellenir
}

x = 5; //hata olur

while (int x = getval()) {
}

switch (int z = getval()){ 
}

--------

int *getptr();

int main()
{
if (int* ptr = getptr()){ //getptr NULL değil ise if deyimine girer
}
}

-------------------------

if with initializing :
----------------------

//c'de bu şekilde kullanılır
int foo();

int main()
{
int x = foo();

if (x != -1){
//may use x
}
else {
//may use x
}
}

//if with initializing ile yazımı

if (int x = foo(); x != -1){ //auto kullanılabilinir
}

------

int * get_ptr();

int main()
{
if (int * p = get_ptr()){
}

if (int * p = get_ptr(); p){
}

if (int * p = get_ptr(); p != nullptr){
}

}

===================================================

Tür dönüştürme operatörleri :

C dilinde 1 tane dönüştürme operatörü vardır

(target type)expr

(int)dval

(char *)iptr

(double)ival

!! bu yapı c++'da da var ancak bunu çok kullanma birazdan anlatılacak yapıyı kullan

----------

//const - cast
char  * Strchr(const char* p, int ch)
{
while (*p) {
if (*p == ch)
return (char *)p;
++p;
}
if (ch == '\0')
return (char *)p;
return nullptr;
}

int main()
{
double dval = 3.77;
char * p = &dval; //cpp de legal değildir
char * p = (char *) &dval; //bu şekilde yazmak gerekir

for (size_t i = 0; i < sizeof(d);
//*p++
}

--------------------

int main()
{
int x = 497;
unsigned int * p = (unsigned *) &x; //bu şekilde yapılmalı
}

---------------------------------

cpp de c deki tür dönüşümlerine ek olarak yeni tür dönüşümlerinin eklenmesinin nedeni :
farklı amaçlarla yapılan tür dönüşümlerinin niyetini kod belli etsin diye.

tür dönüştürme operatörleri :

-static_cast
-const_cast 
-reinterpret_cast
-dynamic_cast

------------------------------

xxxx_cast<type>(expr)

-static_cast: Tam sayı türleri ile gerçek sayı türleri arasında, numaralandırma ile tam sayı türleri arasında

static_cast<int> dval


int main()
{
int x = 10;
int y = 30;

double dval = static_cast<double>(x) / y;
!! c deki gibi tür dönüşümü yapar isek c style cast denir
}

------

int main()
{
double dval{ 456.783};
int ival = static_cast<int>(dval);
}

-----
enum color {Blue, black, green};

int main()
{
int ival = 2;
Color mycolor{ black };
mycolor = static_cast<Color>(ival);
ival = static_cast<int>(mycolor);
}

------

enum color {blue, black, green, white};
const char* const pcolors[] = {"blue", "black", "green", "white"};

int main()
{
Color mycolor{ Color::green };
std::cout << pcolors[static_cast<int>(mycolor)] << "\n";
}

-----------------------

const_cast

int main()
{
int x{56};
const int* cp = &x;

int* iptr = const_cast<int *>(cp); //bu şekilde asla yapma kendisi const nesneye bu uygulanmaz
}

-------

int main()
{
int x = 120;
const int & cr{ x };

int & r = const_cast<int&>(cr); 
}

-----

char  * Strchr(const char* p, int ch)
{
while (*p) {
if (*p == ch)
return const_cast<char *>(p);
++p;
}
if (ch == '\0')
return const_cast<char *>(p);
return nullptr;
}

----

int main()
{
int ival = 221;

auto x = static_cast<double>(ival);
}

-----

bool isprime(int val);
int foo();

// to discard the return value (geri dönüş değerini kullanmamaya denir
int main()
{
int x = foo();
isprime(x); //hata 
}

!! eğer bildirdiğiniz bir fonksiyonun geri dönüş değerinn kullanılması lojik bir 
zorunluluk ise [[nodiscard]] kullanılır.

[[nodiscard]] bool isprime(int val); //attritube denir 

bool isprime(int val);

-----------------------

reinterpret_cast : bir nesneyi farklı türden bir nesne gibi kullanmaya denir

int main()
{
double dval{4343.232};

}

char * p = reinterpret_cast<char *>(& dval);

------

int main()
{
using namespace std;

double dval;
const double* dptr = &dval;

char *p = reinterpret_cast<char*>(dptr); //hata çünkü constlukta var

auto cp1 = const_cast<char*>(reinterpret_cast<const char*>(dptr)); //bu şekilde yapılabilinir
auto cp1 = reinterpret_cast<char*>(const_cast<double*>(dptr)); //bu şekilde yapılabilinir
}

--------

int main()
{
using namespace std;

int x = 10;
void* vp = &x;

int* ip1 = static_cast<int *>(vp);
}


=========================================================================

Function Overloading: aynı isme sahip birden fazla fonksiyonun tanımlanabilmesini ifade eder.
---------------------
Fonksiyonların yüklenmesi

!! dilin en faydalı araçlarından biridir

i1 + i2
d1 + d2

function overloading çalışma zamanına ek maaliyeti yoktur

a) compile-time  
  sttaic binding
  early binding

b) runtime
  dynamic binding
  late binding

function overloading var mı yok mu?
-----------------------------------

signature (imza)
int foo(int, int); //burada imza parametre değişkenlerine denir

function overloading sağlanması için gerekli şart
-aynı scope'da olması 

---------------------
C++ scope kategorisi :
namespace scope
block scope
class scope
function prototype scope
function scope

C scope kategorisi :
file scope
block scope
function prototype scope
function scope
-----------------

int foo(int, int);

int main()
{
int foo(int); //function overloading yok farklı scopedalar
foo(12,23); //hata olur
::foo(12,23); //bu şekilde hata aşılır
}

----------------

-imzaları farklı olucak

-eğer kapsam aynı ise imzaları ve geri dönüş değeri aynı ise function overloading yok.

-function redeclaration: imzaları ve gdd türleri aynı ise

int foo(int, int); //funtion redeclaration
int foo(int, int);

int foo(int);
int foo(const int); //funtion redeclaration

void func(int * ptr);
void func(const int* ptr); //function overloading

void func(int * ptr);
void func(int* const ptr); //function redeclaration

-imzalar aynı ama gdd türleri farklı ise sentax hatası

-----------------

void func(int*); //funtion redeclaration
void func(int[]); 

void func(int(int)); //funtion redeclaration
void func(int(*)(int))); 

void func(int(*)[10]; //funtion overloading
void func(int(*)[29); 

void func(int(&)[10]; //funtion overloading
void func(int(&)[29]; 

void func(int(*)[10]; //funtion redeclaration
void func(int[][10]; 

typedef int Nec;
void func(int); //funtion redeclaration
void func(Nec);

void func(int); //funtion overloading
void func(int32_t);

void func(char); //3 tane funtion overloading var
void func(signed char); 
void func(unsigned char);

void func(int); //funtion overloading
void func(int &);

void func(int &); //funtion overloading 4 tane
void func(int &&);
void func(const int &);
void func(const int &&);

void func(int *); //funtion overloading 
void func(int&);

int foo(int); // funtion overloading 2 tane 
int foo(int);
int foo(int);
int foo(int, int);
int foo(int, int);
int foo(int, int);
int foo(int, int);

-------------------------

void func(long double); funtion overloading 
void func(char); 

int main()
{
func(12.5); //hata verir, long double'dan dolayı
}


-------------

23 //int
23l //long 
23LL //long long
23u//unsigned int
23ul//unsigned long
23lu//unsigned long
23llu//unsigned long long
23. //double

-------------------------------------------------
function overloading süreçleri:

1. süreç
  aday fonskiyonların saptanması

2. süreç
 viable functions (uygun fonksiyon) 

void func(int); //viable functions
//void func(int *);
void func(double); //viable functions
//void func(std::string);
//void func(std::string, int);

-----

void func(void *); //viable
void func(int *); //viable
void func(double); //viable değil

int main()
{
int x{ 5 };
func(&x);
}

-------

void func(void *);
void func(int *);
void func(int, int);

int main()
{
func(56);
}

---------------------
2 türlü dönüşüm vardır:

1-standart conversion (standart dönüşümler), dillin kuralları ile alakalı (int ==> double vb.)
2-user defined conversion (de

sturct Data {
Data();
Data(int);
};

int main()
{
Data mydata;

mydata = 5;
//int ==> Data, data türünden int türüne örtülü dönüşüm yoktur
}

------------
3. süreç
-exact match (tam uyum) 
-promotion (terfi - yükseltme)
-conversion (dönüşüm)


-exact match : argüman olan ifadenin türü ile parametre türünün aynı olması
----------
aşağıdaki durumlarda kullanılır:

L value  ==> R value
const conversion
array decay (array to pointer conversion)
function to pointer conversion
----

void func(int);
void func(long);
void func(float);
void func(double);

int main()
{
func(1); //int çağrılır, intten inte exact match var
func(2L); //long çağrılır
func(3.4f); //float çağrılır
func(4.); //double çağrılır
}

exact match detayları:

void func(int*);
int main()
{
int a[5]{};
func(a); //array to pointer conversion
//array decay 
//exact match
}

----

void func(int (*)(int));

int foo(int);
int main()
{
func(foo); //(int(int)
//func(&foo);
}

----

- promotion 
  integral promotion (innten küçük türlerin inte dönüştürülmesi)
  char ==> int
  bool ==> int
  short ==> int
  float ==> double

----

void func(int);
void func(double);
void func(long);
void func(long double);

int main()
{
func(12) //exact match int kazanır
func('A'); //int kazanır chardan inte
func(2.3F) //double kazanır 
}

-------

void func(unsigned int);
void func(char);

int main()
{
int ival{};
func(ival); //hata, embugi
}

------------------

özel durumlar
-------------
const overloading

void func(int *)
{
std::cout << "int *\n";
}

void func(const int *)
{
std::cout << "const int *\n";
}

int main()
{
const int x = 5;
func(&x); //const int* çağrılır 
}

-------

class Myclass {};

void foo(Myclass*);
void foo(const Myclass*); 

----

class Myclass {};

void foo(Myclass&)
{
std::cout << "Myclass &\n";
}

void foo(const Myclass&)
{
std::cout << "const Myclass &\n";
}

int main()
{
Myclass m;
foo(m);
}

-----

void func(int, int = 10);
void func(int);

int main()
{
//func(3); hata olur ambigous
}

----

void func(int&);
void func(int);

int main()
{
int x = 67;
func(x); //ambigous
func(23); //hata olmaz func(int) çağrılır
}

----

void func(const int&);
void func(int);

int main()
{
func(12);
}

----

void func(int*);

int main()
{
func(nullptr); //hata olmaz
}

---

#include <cstddef>

void func(int*);
void func(double *);
void func(std::nullptr_t);

int main()
{
func(nullptr); //hata olmaz
}

-----

T is a type 

void func(const T &); //
void func(T &); //function overloading 3 tane
void func(T &&);

-----

void foo(int&)
{
std::cout << "L VALUE REF";
}

void foo(int&&)
{
std::cout << "R VALUE REF";
}

int main()
{
int x = 10;

foo(x); //L çağrılır
foo(56); //R çağrılır
}

-----

void foo(const int&)
{
std::cout << "L VALUE REF";
}

void foo(int&&)
{
std::cout << "R VALUE REF";
}

int main()
{
foo(12); //sağ tarafa üstünlüğü verir
}

-----
//ierlede karşımıza çok çıkıcak bir yapı
//sağ taraf değeri için ayrı sol taraf değeri için ayrı bir muamele yapmamızı sağlar

void func(const T&);
void func(T&&);

-------

void foo(int&)
{
std::cout << "L VALUE REF";
}

void foo(const int&)
{
std::cout << "CONST L VALUE REF";
}

void foo(int&&)
{
std::cout << "R VALUE REF";
}

int main()
{
int x{25}; //L value yazar
const int cx{25};
foo(x);
foo(cx);
foo(12);
}

------

//bir istisna

void func(bool){
std::cout<<"bool\n";
}

void func(bool){
std::cout<<"void *\n";
}

int main()
{
int x{562};
func(&x); //void * çağrılır, void * bool'a üstünlüğü var  
}

------

void foo(int, double, long);
void foo(bool, float, int);
void foo(long, double, float);

bu fonksiyonlardan birinin seçilmesi için:
en az bir argüman için o paramterede diğerlerine üstünlük kuracak 
diğer argümanlarda da daha kötü olmayacak

int main()
{
foo(12u, 4.5L, true); //2. çağrılır true üstünlük sağlar(int) 
}

