///////////////////////////////////////////////////////1. Ders///////////////////////////////////////////////

enum class TrafficLight {Red, Yellow, Green};
!! c++ da bu enum türündeki hataları ortadan kaldırmak için class kullanılmıştır           
!! enum class is not a class

enum Pos : int {On, Off, Hold, Standby};
enum Pos : long {On, Off, Hold, Standby};

// bu şekilde bellek ihtiyacını ayarlayabiliyoruz

enum Class Pos : int{On, Off, Hold, Standby};

------------------------------------

//sıralaması:
önce isim arama gerçekleşir bulunamassa sentaks hatası, daha sonra o ismin dilin kurallarını çiğneyip çiğnemediği kontrol edilir en sonda bağlam kontrolü yapılır

name lookup 
context control (sen
access control


int main()
{
int printf = 10;
printf("merhaba"); //sentaks hatası olur isim aramadan dolayı, 
isim 1 kere aranır
}

----------------------------------------------------

:: // scope resolution operator (çözünürlük operatörü)
binary ve unary şekilde kullanılır

int main()
{
int printf = 10;
::printf("merhaba"); //bu şekilde isim global isim alanında aranıcak
isim 1 kere aranır
}

----------

int g = 56;

int main()
{
int g = 10;

std::cout << "g = " << g << '\n'; //10
std::cout << "g = " << ::g << '\n'; //56
}

-----------

void func(int x)
{
int func = 40;
::func(func); //recursive fonksiyon çağrısı, fınc fonksiyonunu func değeri ile çağırırıyorum 
}

-------------

!! ::x //global isim alaında x yok ise hata olur
--------------
isimlerin kullanımı şu şekilde olur

unqualified name :
a

qualified name :
x::a
::b
x.y
c->y

------------------------------------------------------

enum class Color {blue, red, purple, white, black};
enum class TrafficLight {yellow,white, black};
!! class sayesinde isimler aynı olmasına rağmen çakışma olmaz

int main()
{
Color :: blue; //bu isimleri bu şekilde kullanırız
}

enum türlerinin 3. defosu : enum türlerinden aritmetik türlere örtülü dönüşüm vardı

int main()
{
Color mycolor{ Color:: Red};
int ival = mycolor; //Hata olur           
}

!! zorunda kalmadıkça uncscope enum kullanma, scope enum kullan

------------

enum class Color {blue, red, purple, white, black};

void func()
{
using enum Color; //c++20  nitelemeden kullanmamızı sağlar

Color c1 = Red; 
c1 = White;
Color c2 = Black
}

using Color :: Blue;

Color c1 = Blue;
Color c2 = Red; // hata sadece Blue nitelemden kullanılını

==============================================================

int getval();

int main()
{
if (int x = getval()) { //c dilinde gçerli değil c++'da bu şekilde kullanılabilinir
//scope leekage engellenir
}

x = 5; //hata olur

while (int x = getval()) {
}

switch (int z = getval()){ 
}

--------

int *getptr();

int main()
{
if (int* ptr = getptr()){ //getptr NULL değil ise if deyimine girer
}
}

-------------------------

if with initializing :
----------------------

//c'de bu şekilde kullanılır
int foo();

int main()
{
int x = foo();

if (x != -1){
//may use x
}
else {
//may use x
}
}

//if with initializing ile yazımı

if (int x = foo(); x != -1){ //auto kullanılabilinir
}

------

int * get_ptr();

int main()
{
if (int * p = get_ptr()){
}

if (int * p = get_ptr(); p){
}

if (int * p = get_ptr(); p != nullptr){
}

}

===================================================

Tür dönüştürme operatörleri :

C dilinde 1 tane dönüştürme operatörü vardır

(target type)expr

(int)dval

(char *)iptr

(double)ival

!! bu yapı c++'da da var ancak bunu çok kullanma birazdan anlatılacak yapıyı kullan

----------

//const - cast
char  * Strchr(const char* p, int ch)
{
while (*p) {
if (*p == ch)
return (char *)p;
++p;
}
if (ch == '\0')
return (char *)p;
return nullptr;
}

int main()
{
double dval = 3.77;
char * p = &dval; //cpp de legal değildir
char * p = (char *) &dval; //bu şekilde yazmak gerekir

for (size_t i = 0; i < sizeof(d);
//*p++
}

--------------------

int main()
{
int x = 497;
unsigned int * p = (unsigned *) &x; //bu şekilde yapılmalı
}

---------------------------------

cpp de c deki tür dönüşümlerine ek olarak yeni tür dönüşümlerinin eklenmesinin nedeni :
farklı amaçlarla yapılan tür dönüşümlerinin niyetini kod belli etsin diye.

tür dönüştürme operatörleri :

-static_cast
-const_cast 
-reinterpret_cast
-dynamic_cast

------------------------------

xxxx_cast<type>(expr)

-static_cast: Tam sayı türleri ile gerçek sayı türleri arasında, numaralandırma ile tam sayı türleri arasında

static_cast<int> dval


int main()
{
int x = 10;
int y = 30;

double dval = static_cast<double>(x) / y;
!! c deki gibi tür dönüşümü yapar isek c style cast denir
}

------

int main()
{
double dval{ 456.783};
int ival = static_cast<int>(dval);
}

-----
enum color {Blue, black, green};

int main()
{
int ival = 2;
Color mycolor{ black };
mycolor = static_cast<Color>(ival);
ival = static_cast<int>(mycolor);
}

------

enum color {blue, black, green, white};
const char* const pcolors[] = {"blue", "black", "green", "white"};

int main()
{
Color mycolor{ Color::green };
std::cout << pcolors[static_cast<int>(mycolor)] << "\n";
}

-----------------------

const_cast

int main()
{
int x{56};
const int* cp = &x;

int* iptr = const_cast<int *>(cp); //bu şekilde asla yapma kendisi const nesneye bu uygulanmaz
}

-------

int main()
{
int x = 120;
const int & cr{ x };

int & r = const_cast<int&>(cr); 
}

-----

char  * Strchr(const char* p, int ch)
{
while (*p) {
if (*p == ch)
return const_cast<char *>(p);
++p;
}
if (ch == '\0')
return const_cast<char *>(p);
return nullptr;
}

----

int main()
{
int ival = 221;

auto x = static_cast<double>(ival);
}

-----

bool isprime(int val);
int foo();

// to discard the return value (geri dönüş değerini kullanmamaya denir
int main()
{
int x = foo();
isprime(x); //hata 
}

!! eğer bildirdiğiniz bir fonksiyonun geri dönüş değerinn kullanılması lojik bir 
zorunluluk ise [[nodiscard]] kullanılır.

[[nodiscard]] bool isprime(int val); //attritube denir 

bool isprime(int val);

-----------------------

reinterpret_cast : bir nesneyi farklı türden bir nesne gibi kullanmaya denir

int main()
{
double dval{4343.232};

}

char * p = reinterpret_cast<char *>(& dval);

------

int main()
{
using namespace std;

double dval;
const double* dptr = &dval;

char *p = reinterpret_cast<char*>(dptr); //hata çünkü constlukta var

auto cp1 = const_cast<char*>(reinterpret_cast<const char*>(dptr)); //bu şekilde yapılabilinir
auto cp1 = reinterpret_cast<char*>(const_cast<double*>(dptr)); //bu şekilde yapılabilinir
}

--------

int main()
{
using namespace std;

int x = 10;
void* vp = &x;

int* ip1 = static_cast<int *>(vp);
}


=========================================================================

Function Overloading:
---------------------
Fonksiyonların yüklenmesi

!! dilin en faydalı araçlarından biridir











