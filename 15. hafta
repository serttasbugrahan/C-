///////////////////////////////////////////////// 1. Ders ////////////////////////////////////////////

std::vector devam ediyoruz...

tekrar...

bir vektörün size arttırmak için ya bir insert fonksiyonu ya da emplace fonksiyonunu

insert fonk. 2 tane overloadı var

const T& //kopyasını çıkarır
T&& //taşır


emplace : cont. tutulcak öğeyi istemiyor onun ctor gönderilecek argümanı istiyor

-------------------------------------------

silme işlemi yapan fonksiyonlar
--------------------------------

//iterator
//range
//pop_back : son öğeyi siler
//clear

int main()
{
using namespace std;

vector<string> svec;

rfill(svec, 10, rname);

while (!svec.empty()) {
print(svec);
svec.pop_back(); //son öğeyi siler
(void)getchar();
}
}

-----------------

using namespace std;

int main()
{
using namespace std;

vector<string> svec;

rfill(svec, 10, rname);

while (!svec.empty()) {
print(svec);
svec.erase(svec.begin()); //istediğimiz öğeyi silebiliriz
(void)getchar();
}
}

----------------

insert fonksiyonları geri dönüş değeri insert edilen öğenin konumunu

erase fonk. silinmiş öğe ya da öğelerden sonraki ilk öğeyi döndürür

------------------

using namespace std;

int main()
{
using namespace std;

vector<string> svec;

rfill(svec, 5, rname);

print(svec);
auto iter = svec.erase(svec.begin());
(void)getchar();
cout << *iter << '\n';
}

-----------------
//mülakatlarda sorulan bir soru

int main()
{
using namespace std;

vector<string> svec;

rfill(svec, 5, rname);
print(svec);

string name;
cout << "silincek ismi girin: ";
cin >> name;

//find ile arama yapılır
//scope leake kaçın bunun için if with init kullanılır

if (const auto iter = find(svec.begin(), svec.end(), name); iter != svec.end()) {
svec.erase(iter);
cout << "bulundu ve silindi\n";
print(svec);
}
else {
std::cout << "bulunamadi\n";
}
}

--------------

int main()
{
using namespace std;

vector<string> svec;

rfill(svec, 5, rname);
print(svec);

cout << "icinde hangi harf olan ilk oge silinsin : ";
char c;
cin >> name;

//find_if ile arama yapılır
if (const auto iter = find_if(svec.begin(), svec.end(), [c](const string& s); iter != svec.end()) { return s.contains(c);});
iter != svec.end()) {
svec.erase(iter);
cout << "bulundu ve silindi\n";
print(svec);
}
else {
std::cout << "bulunamadi\n";
}
}

-----------------------

//çok tuzak bir soru, mülakatlarda soruluyor

int main()
{
using namespace std;

vector<string> svec;

rfill(ivec, 30, Irand{0, 4});
print(svec);

cout << "silinecek deger: "; 
int ival{};
cin >> ival;

//contanierda belirli bir değere sahip son öğeyi silmek

if (const auto iter = find(ivec.rbegin(), ivec.rend(), ival); iter != ivec.rend()) {
ivec.erase(iter.base() - 1); //-1 olma nedeni erase 1 sonraki konumu tutar
cout << "bulundu ve silindi\n";
print(ivec);
}
else {
cout << "bulunamadi\n";
}
}

--------------------

range arrayse : iteratör range'indeki tüm öğeleri siler, silien öğelerden 1 sonraki konumu döndürür

int main()
{
using namepsace std;

vector<string> svec{"nuri", "huriye", "selda", "yaren", "nazife", "kurthan"};

print(svec);
//ilk 3 öğeyi silmek isteseydik

svec.erase(svec.begin(), svec.end(), 3);
//svec.erase(prev(svec.begin(), svec.end(), 3));
svec.erase(svec.begin() + 1, svec.end() -1);

print(svec);
}

---------------

int main()
{
using namespace std;

vector<string> svec{ "nuri", "huriye", "selda", "yaren", "nazife", "kurthan" };

cout << "svec.size() = " << svec.size() << '\n';
svec.clear(); //tamamen siler
//svec.resize(0); //tamamen siler
//svec.resize(svec.begin(), svec.end()); //tamamını siler
//svec = {} ; //tamanını siler
//svec.assign({});
//svec = vector<string>{};

cout << "svec.size() = " << svec.size() << '\n';

}

---------------
//aşağıdaki örnek birçok yerde karşımıza çıkıcak

using namespace std;

template <typename T>
void foo(T, T y)
{
cout << y.lenght();
}

int main()
{
using namespace std;

string s{"necati"};
foo(s, {});
}

--------------
//copy alg. ile range streame verilir
//anlamaya çalışma

int main()
{
using namespace std;

vector<int> ivec(20, 5);

copy(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, " "});
}

--------------

range' e okuma yaparak aldığımız değerler ile işlem yapma

int main()
{
using namespace std;

vector<int> ivec{istream_iterator<int>{cin}, {}};
//vector<int> ivec{istream_iterator<int>{cin}, istream_iterator<int>{} }; 

copy(begin(ivec), end(ivec), ostream_iterator<int>{cout, "\n"})
}

----------------
shring to fit : kapasiteyi size'a büzüştürür
--------------

int main()
{
using namespace std;

vector<int> ivec(100'000, 7);

cout << format("size = {}, capacity = {}\n", ivec.capacity(), ivec.size()); //dhaa sonra görücez

ivec.erase(ivec.begin() + 5, ivec.end());

//shring to fit yok iken swap-trick kullanılırdı

vector<int>{ivec}.swap(ivec); 

cout << format("size = {1}, capacity = {0}\n", ivec.capacity(), ivec.size()) << '\n';
}

-----------------

// contanierların default karşılaştırma kriteri lexicographical compare ile yapılır

a) 1 4 56 12 6 2

b) 1 4 91 

// b daha büyüktür (91 > 56)

a) 1 4 56 12 6 2

b) 1 4 91 12 6 2 6

//b daha büyük


------------------
data() fonksiyonu adres döndürür

void array_print(const int* p, size_t size)
{
while(size--)
printf("%d ", *p++);

printf("\n");
}

void make_double(int* p, size_t size)
{
while(size--) {
*p *= 2;
++p;
}
}


int main()
{
using namespace std;

vector<int> ivec{3, 6, 7, 9, 1, 2};

array_print(ivec.data(), ivec.size());
make_double(ivec.data(), ivec.size());
array_print(ivec.data(), ivec.size());

}

---------------

//mülakat klasik sorusu

//vektördeki ilk öğenin adresini almak isteseydik bunu hangi yollarla yapabilirdik

void array_print(const int* p, size_t size)
{
while(size--)
printf("%d ", *p++);

printf("\n");
}

void make_double(int* p, size_t size)
{
while(size--) {
*p *= 2;
++p;
}
}


int main()
{
using namespace std;

vector<int> ivec{3, 6, 7, 9, 1,2};

int *p1 = ivec.data(); //data vektördeki ilk öğenin adresini döndürür
int *p2 = &ivec[0];
int *p3 = &*ivec.begin();

array_print(p1, ivec.size());
array_print(p2, ivec.size());
array_print(p3, ivec.size());

}

-------------------
//2 cont. swap ederken kesinlikle swap fonksiyonu çağırın aşağıdaki şekilde kod yazma
//linnera complexity de oluyor, algoritmalar constant complexity'dedir

int main()
{
vector<string> s1(100'000);
vector<string> s2(100'000);

auto temp = s1;
s1 = s2;
s2 = temp;

}

-----------------------------

// mülakatlarda yazlış cevaplanan bir soru
//diğer derste cevabı verilecek

int main()
{
vector<string> svec;
rfill(svec, 30, rname);
print(svec);

//your code
//uzunluğu 6 olanlardan bir tane daha ekleyecek
//uzunluğu 5 olanları silecek
//diğerlerine dokunmayacak
//contanier 1 kere dolaşılacak (for, while)

print(svec);
}

------------

//mülakatlarda sorarlar
vector<bool> //bool değil, contanier değil

vectörün bool açılımında tutulan öğeler aslında bool değil
mesela 8 tane bool'u 1 byte'ın bitlerinde tutuyor

int main()
{
vector<bool> myvec(20);

auto b = myvec[0];

bool b = myvec[4]; 
}


=======================================================

STL silme algoritmaları

stl'de silme algoritması olamaz çünkü algoritmaların parametreleri iterator
ve iterator yoluyla o iterator konumuna sahip contanier nesnesine erişemeyiz
eğer bir iteratör gönderirsek o nesneye erişirz sadece o nesneden öncesine ve sonrasına erişemeyiz
bu nedenle o range'e öğe eklemesi ve silme işlemi yapamayız

---------

using namespace std;

template<typename Iter, typename T>
void Remove(Iter beg, Iter end, const T& val);

int main()
{
using namespace std;

vector<int> ivec{2, 5, 7,,2,2,4};

Remove(ivec.begin(), ivec.end(), 2) //Bu mümkün değildir

ivec.size(); 
}

-----------------
silme işlemi yapan algoritmalar

remove 
remove_if
unique : ardışık aynı değerdeki sayıları 1'e indirir

remove
------
silme algoritmaları genelde lojik and döndürür

template <typename Iter, typename T>
Iter remove(Iter beg, Iter end, const T& val);

-----------
//örneği tekrardan dikkatli incele

int main()
{
vector<string> svec {"ali", "can", "can", "eda", "naz", "gul", "ata", "nur", "can" };

cout << "size = " << svec.size() << '\n';
auto logic_end_iter = remove(svec.begin(), svec.end(), "can");
cout << "size = " << svec.size() << '\n';

cout << "silinmemis oge sayisi: " << distance(svec.begin(), logic_end_iter) << '\n';
cout << "silinmis oge sayisi: " << distance(logic_end_iter, svec.end()) << '\n';
cout << "silinmemis ogeler\n";

print(svec); 

svec.erase(logic_end_iter, svec.end());

cout << "size = " << svec.size() << '\n';
}

----------------

mülakatların en klasik sorusu remove arrays/remove idioumu

int main()
{
vector<string> svec {"ali", "can", "can", "eda", "naz", "gul", "ata", "nur", "can" };

//svec.erase(remove(svec.begin(), svec.end(), "can"), svec.end());
auto n = erase(svec, "can"); // c++ 20 ile bu şekilde olur

cout << n << "tane oge silindi\n";
cout << "size = " << svec.size() << '\n';

for (const auto& s : svec)
cout << s << '\n';
}

--------------

int main()
{
vector<string> svec {"ali", "can", "can", "eda", "naz", "gul", "ata", "nur", "can" };

std::cout << "uzunlugu kac olanlar silinsin: ";
size_t len;
cin >> len;

svec.erase(remove_if(svec.begin(), svec.end(), [len](const string& s) {return s.size() == len; }), svec.end());
//auto n = erase_if(svec, [len](const string& s) {return s.size() == len; }); //c++ 20 ile 

std::cout << n << "eleman silindi\n";
cout << "size = " << svec.size() << '\n';
}

------------------
bu şekilde function object/function class oluşturarak işimizi kolaylaştırabiliriz

standart function object
------------------------
template <typename T>
struct Less {
bool operator()(const T&lhs, const T& rhs) const
{
return lhs < rhs;
}
};

template <typename T>
struct Plus {
bool operator()(const T&lhs, const T& rhs) const
{
return lhs + rhs;
}
};

template <typename T>
struct Multiplies {
bool operator()(const T&lhs, const T& rhs) const
{
return lhs * rhs;
}
};

int main()
{
using namespace std;

boolalpha(cout);

Less<int>{}(12, 5  )
}

----------------

int main()
{
vector<int> ivec {455, 4, 8, 981, 13, 7, 145, 4444,23,1,129};

sort(ivec.begin(), ivec.end());
sort(ivec.begin(), ivec.end(), less<int>{});
sort(ivec.begin(), ivec.end(), less{}); //küçükten büyüğe sıralama yapar
sort(ivec.begin(), ivec.end(), greater{}); //büyükten küçüğe sıralama yapar

print(ivec);
}

-------------

int main()
{
vector<int> y{455, 4, 8, 981, 145, 4444,23};
vector<int> x{455, 4, 8, 981, 13, 7, 145};

vector<int> z;
//karşılık öğeleri topla, z' ye yaz

transform(x.begin(), x.end(), y.begin(), back_inserter(z), plus{});

//transform(x.begin(), x.end(), y.begin(), back_inserter(z),
[int a, int b) {return a + b; }); //lambda ile yapımı

print(x);
print(y);
print(z);

}

----------------

int main()
{
vector<int> x{1,4,7,2,3,2,32,3,2};

print(x);
transform(x.begin(), x.end(), x.begin(), negate{});
print(x);

//negate : -lisini yazar
}

--------------------------------------

silme algoritmalarına devam ediyoruz

int main()
{
vector vec {2, 5, 5,5,3,3,3,9,9,8,5,5,6,6,7,1,1};

print(vec);
vec.erase(unique(vec.begin(), vec.end()), vec.end());
print(vec);
}

----------------

//mülakatlarda sorulan bir soru

int main()
{
string str;

cout << "bir yazi girin: ";

getline(cin, str);

cout << "[" << str << "]\n";

//boşlukların sayısını 1'e indiren kodu yaz

str.erase(unique(str.begin(), str.end(), [](char c1, char c2) {return isspace(c1) && isspace(c2); }), str.end());

cout << "[" << str << "]\n";
}

---------------

std::ostream_iterator
----------------------

//yazma işlemi yapan bir algoritmayı
//yazacağı öğeyi bir stream'e insert etmesini sağlamak

copy alg. yazoyoruz

template<typename InIter, typename OutIter>
OutIter Copy(InIter beg, InIter end, OutIter destbeg)
{
while (beg != end) {
*destbeg++ = *beg++;
}
return destbeg;
}


template <typename T>
class OstreamIterator {
public:
OstreamIterator(std::stream &os, const char *p = "") : mos(os) , msep {p} {}
OstreamIterator& operator*(){return *this; }
OstreamIterator& operator*(){return *this; }
OstreamIterator& operator++(){return *this; }
OstreamIterator& operator++(int){return *this; }
OstreamIterator& operator=(const T& val){
mos << val;
return *this; 
}


private:
std::ostream& mos;
const char* msep;
};

int main()
{
vector<int> ivec{4,2,3,4,3,4,4,3,2};

copy(ivec.begin(), ivec.end(), OstreamIterator<int>{cout, " "});
}

-----------

yukaradakilerin yazılmışı vardır

int main()
{
using namespace std;

vector<int> ivec{2, 5, 7, 9, 1, 3, 6, 4};

copy(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"});
}

////////////////////////////////////////// 2. Ders /////////////////////////////////////////

silme algoritmaları lojik silme işlemi yaparlar 
algoritma aslında contanierdan öğe silemez
contanierdan silme ve ekleme işlemleri için contanier knedisine ihtiyacımız var
ancak iteratörler o nesneye erişemez
bu fonksiyonlar öğeler değişmiş gibi öğelerin yerini değiştiriyolar
silinmemiş öğelerin end konumu döndürülür

---------------

ostream 
-------


int main()
{
using namespace std;

vector<Date> dvec;
rfill(dvec, 100000, Date::random);

copy(dvec.begin(), dvec.end(), ostream_iterator<Date>{cout, "\n"}); //ekrana yazıdır

cout << "yilin kacinci ayi: ";
int month;

cin >> month;
copy_if(dvec.begin(), dvec.end(), ostream_iterator<Date>{cout, "\n"}
[month](const Date &d) {
return d.month() == month; })
}; 

}

----------------
//geçen derste verilen ödeve bakıyoruz

int main()
{
vector<string> svec;
rfill(svec, 30, rname);
print(svec);

//your code
//uzunluğu 6 olanlardan bir tane daha ekleyecek
//uzunluğu 5 olanları silecek
//diğerlerine dokunmayacak
//contanier 1 kere dolaşılacak (for, while)

for (auto iter = svec.begin(); iter != svec.end(); ++iter) {
if (iter -> lengt() == 5) {
svec.erase(iter);
}
else if (iter->lenght() == 6) {
svec.insert(iter, *iter);
}
}
print(svec);
}

---------------

//yukarıdaki şekilde yazılmamalı, burada iter invalid hale geliyror
iterator geçersiz olması durumunda ne iterator konumundaki öğeye erişmeliyiz
nede o iteratörü manüpüle eden bir fonksiyona çağrı yapmalıyız
ancak onu yeni değeri ile kullanabiliriz

silme işlemi yapan fonksiyonlar silinen öğeden sonraki ilk 
silinmemiş öğenin konumunu döndürüyor

ekleme işlemi yapanlarda eklenmiş öğenin konumunu döndürüyor

iterator invalidation'dan kaçmanın tek yolu, silme veya ekleme yaptığımız zmana kullandığımız iteratore
tekrar insert veya erase işleminin geri dönüş değerini atamamız gerekiyor

---------------
//çok meşhur bir sorudur

int main()
{
vector<string> svec;
rfill(svec, 30, rname);
print(svec);

//your code
//uzunluğu 6 olanlardan bir tane daha ekleyecek
//uzunluğu 5 olanları silecek
//diğerlerine dokunmayacak
//contanier 1 kere dolaşılacak (for, while)

auto iter = svec.begin();
while (iter != svec.end()) {
if (iter->lenght() == 5) {
iter = svec.erase(iter); //0 arttırma işlemi yaparız erase 1 sonraki konumu tutar
}
else if (iter->lenght() == 6) {
iter = next(svec.insert(iter, *iter), 2); // 2 arttırma işlemi yaparız
}
else
++iter; //bir sonraki öğeye bakmamızı sağlar
}
print(svec);

}  

==========================================================

deque :
------

amaç sadece sondan yapılan ekleme ve silme işlemlerini değil
baştan yapılanlarıda complexitysini constant time'a çekmek index erişiminide constant time a çekmek

vector sondan ekleme yapılması durumdunda constant time
diğerleri linear complexity

vector'ün reallocation problemi var

deque ne zmaan kullanılır :

1- ekleme ve silme her 2 uçtan yapılacak ise ve index ile erişim contant time olucak

2- reallocation maaliyetinden kaçınmak olabilir

3- c api' leri ile beraber kullanılacak ise continious memmory kullanmıyor çünkü ayrı ayrı chart'lar var

--------------

#include <deque>

template <typename T, typename A = std::allocator<t
class Deque {

};

-------------

inerface büyük ölçüde aynıdır

int main()
{
using namespace std;

deque<string> sd;

sd.
}

-----------

emplace_back : vecktördeki push_back karşılığı
emplace_front : vecktördeki push_front karşılığı

-------------

int main()
{
using namespace std;

Irand myrand{0, 9999};

for (int i = 0; i < 100; ++i) {
int ival = myrand();
if (val % 2 == 0)
id.push_back(val);
else
id.push_front(val);
}

for (const auto val : id) {
cout << val << " ";
}
}

---------------

int main()
{
using namespace std;

deque<string> sd;

rfill(sd, 20, [] {return rname() + ' ' + rfname(); });

int cnt = 0;

while (!sd.empty()) {
print(sd.empty());
if (cnt % 2 == 0) {
sd.pop_back();
}
else {
sd.pop_front();
}
++cnt;
(void)getchar();
system("cls");
}
}

-------------

stackleme işlemlerinde ekleme işlemleri 2 uçtan yapılırsa
o 2 uçtaki öğeleri gösteren pointerlar invalid hale gelmiyor

--------------
bu kodda tanımsız davranış yoktur

int main()
{
using namespace std;

deque<string> sd;

rfill(sd, 10, [] {return rname() + ' ' + rfname(); });

auto& elem = sd[7];
cout << elem << '\n';
auto iter = next(sd.begin() + 7);

sd.push_back("mustafa aksoy")
cout << elem << '\n';
}

--------------

bu kodda tanımsız davranış var

int main()
{
using namespace std;

deque<string> sd;

rfill(sd, 10, [] {return rname() + ' ' + rfname(); });

auto iter = next(sd.begin() + 7);
cout << *iter << '\n';

sd.push_back("mustafa aksoy");

cout << *iter << '\n';
}

-------------

bu kodda tanımsız davranış var

int main()
{
using namespace std;

deque<string> sd;

rfill(sd, 10, [] {return rname() + ' ' + rfname(); });

auto& elem = sd[7];

cout << elem << "\n";
sd.insert(sd.begin() + 3, "furkan mert");

cout << elem << "\n";

===========================================================

sıralamaya ilişkin algoritmalar:
--------------------------------

1. overload : default olarak küçükten büyüğe bir sıralama yapar

2. overload : sizden ilave bir karşılaştırma parametresi alarak farklı şekilde sıralama yapar

--------------------
aşağıdaki algoritmaları bilmemiz gerekiyor

sort : belli bir kritere göre sıralar
partial_sort : belli bir bölümü sıralar
stable sort :sıralamanın stable olup olmaması aynı anahtar değerindekilerin sıralamadan önceki izafi konumları korunmuş olucak ile ilgilidir eğer ilk parametreye göre sıralama yaparken ikinci bir parametreye (stable değil ise) göre sıralama değişir
nth element : n. eleman yerine koyulur ona göre sıralama gerçekleşir, medyan
partition : kritere göre bölümleme yapmak demektir, o kriteri sağlayanlar başta sağlamaynalar sonda. erkekler başa kadınlar sonda

-------------------

int main()
{
using namespace std;

vector<string> svec;

rfill(svec, 1'000'000, rname);

sort(svec..begin(), svec.end());
sort(svec..begin(), svec.end(), greater{}); //büyükten küçüğe sıralar

}

-----------------
int main()
{
using namespace std;

vector<string> svec;


rfill(svec, 1'000'000, rname);

auto fcmp = [](const string& s1, const string& s2) {
return s1.lenght() < s2.lenght() || (s1.lenght() == s2.lenght() && s1 < s2);
}

sort(svec..begin(), svec.end());
sort(svec..begin(), svec.end(), fcmp);
}

--------------------

using sipair = std::pair<std::string, int>;

int main()
{
using namespace std;

vector<sipair> svec;

rfill(svec, 20'000, []{return make_pair(rname(), Irand{20, 70}());})

std:ofstream ofs{"out.txt"};
if (!ofs) {
std::cerr << "out.txt dosyasi olusturulamadi\n";
exit(EXIT_FAILURE);
}
//isme göre sırlaama yapıyoruz

sort(svec.begin(), svec.end(), [](const sipair&x, const sipair& y) {return x.first < y.first;});
//sort(svec.begin(), svec.end(), [](const sipair&x, const sipair& y) {return x.second < y.second;}); // stable olmadığı için sıralama bozuldu
stable_sort(svec.begin(), svec.end(), [](const sipair&x, const sipair& y) {return x.first < y.first;}); //bu şekilde olmalı

print(svec, "\n", ofs);

}

------------------,

partial_sort : sıralama kriterine göre ilk n tane öğeyi yerine koymak için

using sipair = std::pair<std::string, int>;

int main()
{
using namespace std;

vector<sipair> svec;

rfill(svec, 20'000, Date::random);

cout << "ilk kac tarih isteniyor: ";
int n;
cin >> n;

partial_sort(dvec.begin(), dvec.begin() + n,dvec.end());

sort(dvec.begin(), dvec.end());
if (!ofs) {
std::cerr <<  "out.txt dosyasi olusuturulmadi\n";
exit(EXIT_FAILURE);
}
print(dvec, "\n", ofs);

}

-------------------

partial_sort_copy : sıralanmış şekilde olanları başka bir range'e yazıyor

int main()
{
using namespace std;

rfill(dvec, 20'000, Date::random);

cout << "ilk kac tarih isteniyor: ";
int n;
cin >> n;

vector<Date> dest_vec(n);

partial_sort_copy(dvec.begin(), dvec.end(), dest_vec.begin(), dest.vec.end());

copy(dest_vec.begin(), dest_vec.end(), ostream_iterator<Date>{cout, "\n"});

}

-------------

nth_element:

int main()
{
using namespace std;

vector<Date> dest_vec(n);

rfill(dvec, 20'000, Date::random);

cout << "ilk kac tarih isteniyor: ";
int n;
cin >> n;

nth_element(dvec.begin(), dvec.begin() + n, dvec.end());

std::ostream ofs{ "out.txt" };
if (!ofs) {
std::cerr <<  "out.txt dosyasi olusuturulmadi\n";
exit(EXIT_FAILURE);
}

copy(dest_vec.begin(), dest_vec.end(), ostream_iterator<Date>{ofs, "\n"});
}

-------------

int get_median(const std::vector<int> vec) //Burada ref kullanmak yerine bu şekilde yazmak maaliyeti düşürür
{
std::nth_element(vec.begin(), next(vec.begin(), vec.size() / 2), vec.end());

return vec[vec.size() / 2];
}

int main()
{
using namespace std;

vector ivec {5, 7, 1, 4, 9,3,23,12,8,6,15,-1,9,97};

cout << "median is " << get_median(ivec);
}

----------------

partial point : koşulu sağlamayanlardan ilkinin konumu

int main()
{
using namespace std;

vector<string> svec;
rfill(svec, 100, rname);

char c;

std::cout << "bir harf girin: ";
cin >> c;

auto iter_par_point = partition(svec.begin(), svec.end(), [c](), [c](const string& s) {
return s.find(c) != string::npos;
});

print(svec, "\n");
std::cout << "partisyon indeksi: " << iter_par_point - svec.begin() << '\n';
if (iter_par_point != sve.end()) {
std::cout << "kosulu saglamayan ilk oge : " << *iter_par_point << "\n";
}
}

-------------

sadece koşulu sağlayanların yazılması

int main()
{
using namespace std;

vector<string> svec;
rfill(svec, 100, rname);

char c;

std::cout << "bir harf girin: ";
cin >> c;

auto iter_par_point = stable_partition(svec.begin(), svec.end(), [c](), [c](const string& s) {
return s.find(c) != string::npos;
});

std::cout << "kosulu saglayanlar\n";
copy(svec.begin(), iter, ostream_iterator<string>{cout, "\n"});
std::cout << "kosulu saglamayanlar\n";
copy(iter, svec.end(), ostream_iterator<string>{cout, "\n"});

-----------------

patition_copy : bir kaynak range ister 2 tane hedef range , koşulu sağlayanların 1 range, sağlmaaynları 2. range yazar

int main()
{
using namespace std;

vector<string> svec;
rfill(svec, 20, rname);
print(svec);
char c;

std::cout << "bir harf girin: ";
cin >> c,

deque<string> ok(20);
list<string> not_ok(20);

auto ip = partition_copy(svec.begin(), svec.end(), ok.begin(), not_ok.begin(), 
[c](const string &s) {return s.contains(c); });

std::cout << "kosulu saglayan ogeler\n";
print(ok.begin(), ip.first);
std::cout << "kosulu saglamayan ogeler\n";
print(not_ok.begin(), ip.second);
}








