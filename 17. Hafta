////////////////////////////////////////////////////////////////////// 1. Ders ////////////////////////////////////////////////////////////

int foo(int x, int y, int z)
{
std::print("x = {} y = {} z = {}\n", x, y, z);
}

int main()
{
using namespace std;
using namespace placeholders;

auto f = bind(foo, 20, _1, _2);

f(333,999); //20 333 999
}

------------------

struct Functor {
void operator()(int a, int b)
{
std::cout << "a = " << a << " b = " << b << "\n";
}
};

int main()
{
using namespace std;
//using namespace kullanmadığımız için aşağıda o şekilde yaptık  

auto fn = bind(Functor{}, placeholders::_1, 6512);

fn(35);

}

------------------
//lambda olabilir

struct Functor {
void operator()(int a, int b)
{
std::cout << "a = " << a << " b = " << b << "\n";
}
};

int main()
{
using namespace std;
using namespace placeholders;

auto fn = bind([](int a, int b, int c) {
return a + b + c;
}, 99, _1, _1);

auto val = fn(35);

cout << "val = " << val << '\n';
}

---------------

class Nec {
public:
void func()const 
{
std::cout << "Nec::func()\n";
}

void bar(int a)const 
{
std::cout << "Nec::bar(int a) a=  "<< a '\n';
}

};


int main()
{
using namespace placeholders;

Nec mynec;

auto f1 = std::bind(&Nec::func, _1);

f1(mynec);
auto f2 = std::bind(&Nec::bar, _1, 89);

f2(mynec);
}

-----------

void func(int& x, int &y, int& z)
{
x += 10;
y += 10;
z += 10;
}

int main()
{
using namespace std;

int a = 72;
int b = 82;
int c = 92;

auto f1 = std::bind(func, a, b, c); //kopyasını yolluyor

f1();

cout << a << " " << b << " " << c << "\n"; 
}

-----------------
//refferance wrapper kullanmamız lazım

void func(int& x, int &y, int& z)
{
x += 10;
y += 10;
z += 10;
}

int main()
{
using namespace std;

int a = 72;
int b = 82;
int c = 92;

auto f1 = std::bind(func, ref(a), ref(b), ref(c)); //kopyasını yolluyor

f1();

cout << a << " " << b << " " << c << "\n"; 
}

--------------
//biraz farklı örnekleri inceliyoruz

#include <algorihm>
#include <csdlib>

int main()
{
using namespace std;
using namespace std::placeholders;

vector<int> ivec(100);

generate(ivec.begin(), ivec.end(), []{return rand() % 1000;});

int val;

cout << "kactan buyuk olanlar sayilsin: ";
cin >> val;

//cout << count_if(ivec.begin(), ivec.end(), [val](int i) {return i > val; }) << "\n";
cout << count_if(ivec.begin(), ivec.end(), bind(greater{}, _1, val) << '\n'; //900 den büyük olanlar yazar
cout << count_if(ivec.begin(), ivec.end(), bind(greater{}, val, _1) << '\n'; //900 kaç tanesinde büyük sorusunun cevabıdır
}

-----------------

//mülakatlarda bu soru banko soruluyor

void increment(int& x)
{
++x;
}

int main()
{
using namespace std;

int ival{ 35 };

auto fn1 = bind(increment, ival);
auto fn2 = bind(increment, ref(ival));

fn1();

cout << "ival = " << ival << '\n';
fn2();
cout << "ival = " << ival << '\n';

}
 
---------------------------------------

//std::function : aldığı argümanlar ile sarmaladığı collable çağırır 
yani function pointer gibi davranır

std::function neden kullanılır, function pointer fonksiyon tutar, std::function herhngi bir collable tutabilir


int foo(int x)
{
std::cout << "foo(int) cagrildi\n";
}

int main()
{
using namespace std;

//template param. olarak bir callable'in cagrilmaya aday fonksiyon türünü
//kullanmamız gerekiyor

//foo'nun türü ne? - int(int)

//&foo'nun türü ne? - int (*)(int)
function<int(int)> f;
}

---------------

int foo(int x)
{
std::cout << "foo(int) cagrildi\n";

return x * 19;

}

int bar(int x)
{
std::cout << "bar(int) cagrildi\n";

return x * x;
}

int main()
{
using namespace std;

//function<int(int)> f(foo);
//function<int(int)> f{foo}; //bu işlemler yapılabilir
function<int(int)> f = foo;

auto ret = f(90);
cout << "ret = " << ret << '\n';

f = bar;
ret = f(90);
cout << "ret = " << ret << '\n';
}

-------------------

//ctad olur

int foo(int x)
{
std::cout << "foo(int) cagrildi\n";

return x * 19;

}

int bar(int x)
{
std::cout << "bar(int) cagrildi\n";

return x * x;
}

int main()
{
using namespace std;

function f = foo;

}

-------------------

class Nec {
public:
Nec(int x) : mx(x) {}
void print_sum(int a) const
{
std::cout << mx << " + " << a << " = " << mx + a << '\n';
}

private:
int mx;
};

void print_int(int x)
{
std::cout << "[" << x << "]\n";
}

int main()
{
using namespace std;

function<void(int)> f(print_int);

f(23);

f = [](int x) {
cout << "x = " << x << "\n";
}

f(45);
}

-------------

class Nec {
public:
Nec(int x) : mx(x) {}
void print_sum(int a) const
{
std::cout << mx << " + " << a << " = " << mx + a << '\n';
}

private:
int mx;
};

void print_int(int x)
{
std::cout << "[" << x << "]\n";
}

int main()
{
using namespace std;

function<void(const Nec&, int)> f = &Nec::print_sum;
Nec mynec(666);

f(mynec, 222);
}

---------------

int foo(int);
double bar(double);
void baz(int, int);

int main()
{
using namespace std;

function f1 = foo();
//function<int(int)> f1 = foo(); //aynı anlamda
function f2 = bar();
//function<double(double)> f2 = bar(); //aynı anlamda
function f3 = baz();
//function<void, int, int> f3 = baz(); //aynı anlamda
}

--------------

int main()
{
using namespace std;

function<int(int)> f; //şuanda bir fonksiyonu tutmaz

try
{
auto val = f(45); //exception throw eder
}
catch(const std::exception& e)
{
    std::cout << "exception caught: "<< e.what() << '\n';
}
}

!! std::function boş iken onu fonksiyon çağrı operatörünün operandı yaparsak
exeception throw eder

------------
//sınıf boş ise çağırıp çağırmamayı seçme, operator bool ile yapılır

int foo(int x)
{
return x * 6;
}

int main()
{
using namespace std;

function<int(int)> f;

//f.operator bool 
if (f) {
std::cout << "ben sana bos degilim\n";
}
else {
std::cout << "kendimi bombos hissediyorum"\n;
}

f = foo;

if (f) {
std::cout << "ben sana bos degilim\n";
}
else {
std::cout << "kendimi bombos hissediyorum"\n;
}
}

//operator bool ile fonksiyonu kontrol edebiliyoruz

---------------------------

std::function en tipik kullanım seneryoları

call back : bir fonksiyonun bir fonksiyona çağırmak

void foo(int (*fp)(int)) //bu yapıda sadece fonksiyon adresi gönderebiliriz
{
auto val = fp(12); 
}

//std::function yaparsak hertürlü callable kabul edilir

void foo(int (*fp)(int)); //sadece function callable alır

void bar(std::function<int(int)>); //her türlü callable alabilir

------------------

void bar(std::function<int(int)>);

int f(int);

struct Nec {
static int foo(int);

};

struct Erg {
bool operator()(int)const;
};

int main()
{
auto fn = [](int x) {return x * x};

bar(f);
bar(Nec::foo);
bar(Erg{});
bar(fn);

auto fb = bind(func, _1, _1, _1);
bar(fb);
}

------------------------

callable kullanılan tipik seneryolar :

using fntype = std::function<int(int, int)> //bu şekilde yazılabilir, kolaylık sağlar

int main()
{
fntype f;
}

-----------

class Myclass {
public:
void foo()
{
auto val = mf(12);
}

private:
std::function<int(int)> mf;
};

---------

contanierlarda tutmak :

int f1(int);
int f2(int);
int f3(int);
int f4(int);
int f5(int);


int main()
{
using namespace std;

vector<int (*)(int)> myvec{f1, f2, f3, f4, f5};
}

-----------

int foo(int);
int bar(int, int, int);

struct Functor{
int operator()(int)const;
};

using fntype = std::function<int(int, int)>

int main()
{
using namespace std;

vector<fntype> vec;

vec.push_back(foo);
vec.push_back([](int x) {return x * 5; });
vec.push_back(Functor{});
vec.push_back(bind(bar, _1, 10, 20));

for (auto & f : vec) {
auto val = f(12);
}
}

------------
//template olduğu için bir çok yapıya izin verir

class Myclass {
public:
int foo(int);
int bar(int)const;

};

int main()
{
using namespace std;

Myclass m;

function<int(Myclass&, int)> f1{&Myclass::foo };
function<int(const Myclass&, int)> f2{&Myclass::foo};
function<int(const Myclass*, int)> f2{&Myclass::bar};

}

-----------------------------------

mem_fn ve not_fn adaptörleri

mem_fn : sınıfın üye fonksiyonunu alır ve direk çağrılabilir hale getirir
-------

class Myclass {
public:
void func()const
{
std::cout << "Myclass:func()\n";
}

void foo(int x)const
{
std::cout << "Myclass:foo(int x) x = "<< x << "\n";
}
};

int main()
{
using namespace std;

auto f1 = mem_fn(&Myclass::func);

Myclass mx;
Myclass * ptr = &mx;

//f1(mx);
f1(ptr);
auto f2 = mem_fn(&Myclass::foo);
f2(ptr, 778);
}

-----------------
mem_fn algoritmalarda kullanılır

int main()
{
using namespace std;

vector<string> svec;
rfill(svec,20, []{return rname() + ' ' + rfname(); });

print(svec, "\n");

vector<size_t> lenvec(svec.size()); 
//string uzunluk değerlerini lenvec'e aktarmak istiyoruz

//2 yolu var
//1- lambda ile yapmak

/*transform(svec.begin(), svec.end(), lenvec.begin(), [](const string& s) {
return s.size();
});*/

//2- mem_fn ile yapımı
transform(svec.begin(), svec.end(), lenvec.begin(), mem_fn(&string::size));

print(lenvec);
}

---------

class Nec {
public:
Nec(int val) : mval(val) {}
void print()const
{
std::cout << "[" << mval << "]\n";
}
private:
int mval
};

int main()
{
using namespace std;

vector<Nec> nvec;
for (int i = 0; i < 20; ++i) {
nvec.emplace_back(i);
}

for_each(nvec.begin(), nvec.end(), [](const Nec& nec) {
nec.print();
});

for_each(nvec.begin(), nvec.end(), mem_fn(&Nec::print));

}


--------------------

not_fn: callable alır cağıırır geri dönüş değerini değil lojik değerini döndürür
//çok ihtiyaç duyulmaz

int main()
{
using namespace std;
auto f = not_fn(isprime);

int x;

cout << "bir sayi girin: ";

cin >> x;

boolalpha(cout);
cout << "is_prime "<< x << "=" << is_prime(x) << '\n';x  
cout << "is_prime "<< x << "=" << f(x) << '\n';x  

}


-------------

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'00});

//asal olanları yazdır

//copy_if
                                                                //global bir fonksiyon olduğu için 'isprime' şeklinde de yazılabilir 
copy_if(ivec.begin(), ivec.end(), ostrram_iterator<int>{cout, "\n"}, &isprime);

}

-------------

//asal olmayanların yazılması

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'00});

copy_if(ivec.begin(), ivec.end(), ostrram_iterator<int>{cout, "\n"}, [](int x) {
return !is_prime(x); });

copy_if(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"},  not_fn(isprime)); //aynı etkiyi yapar


});

-------------

struct Pred {
bool operator()(int x) const 
{
return x % 7 == 0;
}
};

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'000});

copy_if(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"}, not_fn(Pred{}));

}

---------
//lambda ile yapılması

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'000});

std::cout << "bir tam sayi girin: ";
int x{};
cin >> x;
auto f = [](int i) {return i % x == 0; };

copy_if(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"}, not_fn(fn);

}

=======================================================

std::array :  c dizilerinin sarmalayan rupper sınıf
------------

//basitleştirilmiş hali

template<typename T, std::size_t n>
struct Array {
T ar[n];
};

int main()
{
using namespace std;

Array<int, 10> x;
Array<string, 20> y;

}

--------------

c++ da aggregate type denilen yapı var ve bu yapının ilave özellikleri vardır

struct Nec {
int x, y, z;
};

int main()
{
Nec mynec = {2, 5, 8} ; //aggregate özelliği
}

----------

struct Nec {
int a[5];
};

int main()
{
Nec mynec = {2, 5, 8} ; //aggregate özelliği
}

----------

template<typename T, std::size_t n>
struct Array {
T ar[n];
};

int main()
{
using namespace std;

Array<int, 10> x = {3,5,6,8,9};

}

---------------

std::array bir aggregate'dır.

---------------

struct Nec {
int a, b, c;
};

int main()
{
Nec mynec;

std::cout << mynec.a << mynec.b << mynec.c << "\n"; //ub, ilk değer verilmediği için garbage value
}

----------

struct Nec {
int a, b, c;
};

int main()
{
Nec mynec{}; //ub kalkar, 0 olur değeler

std::cout << mynec.a << mynec.b << mynec.c << "\n"

----------

//mülakatlarda necati hoca çok soruyor

int main()
{
array<int, 5> ar; //ub

cout << ar[0] << '\n'; 
}

---------

int main()
{
array<int, 5> ar{}; //o olma garantisi vardır

cout << ar[0] << '\n'; 
}

-----------

array sıfır maaliyetlidir

------------

neden c değilde std::array kullanalım?

!! çok özel durumlarun dışında std::array kullanmak iyidir

-STL uyumludur

-interface vardır

- .at exception throw eder

- array decay tehlikesi ortandan kalkar hiçbir şekilde ilk öğeye erişme olmaz(array decay ile), aynı maaliyetle array decayden arındırmış oluruz

- c ve c++ 'da fonksiyonlar ve geri dönüş değerleri dizi olamaz, ancak fonksiyon parametresi std::array olabilir

- std::array'de nesne yine stack'de


-----------

//interface

int main()
{
using namespace std;

array<int, 5> ar;

ar. //fonksiyonları incele
}

-----------

int main()
{
using namespace std;

int a[0]; //dizi boyutu sıfır olamaz, hata

//std::array bir sınıf şablonudur, arayde sentax hatası olmaz

}

-----------

int main()
{
using namespace std;

array<int, 0> ax;

boolalpha(cout);

cout << "ax.size() = " << ax.size() << '\n';
cout << << ax.empty() << "\n";


}

-----------

//temel özellikleri

-range base for loop ile kullanılabilir

int main()
{
using namespace std;

array<int, 5> ax{};
array<int, 5> ax; //garbage value olur

for (auto i : ax)
cout << i << ' ';
}

----------
//stad'dan faydalanabilinir

int main()
{
using namespace std;

array x = {1,2,3,4,5,6,7}; //legal ancak bütün tülerin aynı olması lazmım
array x = {1,2,3,4,5,6,7u}; //Hata

array x<int>; //geçerli değil, nedenini hoca açıklamadı
array x<>; //geçerli değil, nedenini hoca açıklamadı

}

----------

std::aray<int, 3> foo(int a, int b, int c)
{
//aşağıdaki yapıların heps geçerli

//return std::array<int, 3> {a, b,c};
//return std::array {a,b,c};
return {a,b,c};
}

//mülakatlarda sorulabilir

int main()
{
using namespace std;

int a[] = {1, 3, 4, 7, 2, 5, 7,13};

array ar = {begin(a), end(a)};
}

------------

std::aray<int, 3> foo(int a, int b, int c)
{

return {a,b,c};
}

int main()
{
using namespace std;

array<double, 5> ax{};
array<int, 5> ay{};

ax = ay; //hata

copy(ay.begin(), ay.end(), ax.begin());
}

-----------
//array inseteri yok

template <typename T, std::size_t n>
std::ostream& operatot << (std::ostream&os, const std::array<T, n>&ar)
{
os << '[';
for (std::size_t i{}; i < ar.size(); ++i)[
os << ar[i] << " , ";
}

return os << ar.back()) << "]";
}

int main()
{
using namespace std;

array<int, 3> ax{2, 5, 7};

cout << ax << "\n";
}

---------------
//literal operator

template <typename T, std::size_t n>
std::ostream& operatot << (std::ostream&os, const std::array<T, n>&ar)
{
os << '[';
for (std::size_t i{}; i < ar.size(); ++i)[
os << ar[i] << " , ";
}

return os << ar.back()) << "]";
}

int main()
{
using namespace std;

array a = {"naci"s, "cemal"s, "dagdalen"s};


}

--------------

template <typename T, std::size_t n>
std::ostream& operatot << (std::ostream&os, const std::array<T, n>&ar)
{
os << '[';
for (std::size_t i{}; i < ar.size(); ++i)[
os << ar[i] << " , ";
}

return os << ar.back()) << "]";
}

int main()
{
using namespace std;

array<array<int, 3>, 4> ar {{2,2,2}, {3,3,3}, {5,5,5}, {7,7,7}//bu şekilde yapılabilir

cout << ar << "\n";
}

/////////////////////////////////////////////// 2. Ders ////////////////////////////////////////////

//mülakatlarda neden array kullanıyoruz sorusu sorulur?

-sıfır maaliyetli 

-array'in sunduğu interface vardır

-array decay yok

int main()
{
using namespace std;

array a{1, 3, 5, ,7, 8};
//int *p1 = a; //olmaz

int* p2 = a.data();
int* p3 = &a[0];
int* p4 = &a.at(0);
int* p5 = &*a.begin();
}

---------------

//şaşırtmalı bir soru

int main()
{
using namespace std;

int a[5]{};

3[a]++; //legal
}

---------------
//c tekrar

p[2] //aynı anlamda

*(p + 2) //aynı anlamda

2[p] //aynı anlamda

----------------
//c tekrar
int main()
{
using namespace std;

constexpr auto val = 2["elma] - 1["elma"]; //2. indisten 1. indis çıkar 1 kalır
}

------------------

int main()
{
using namespace std;

array<int, 5> a{};

3[a]++; //geçerli değil bu bir sınıf nesnesi
}

==================================================

tuple :pair'in çoklusudur
-----

int main()
{
using namespace std;

//aşağıdaki şekillerde olabilir
std::tuple<> t0
std::tuple<int> t1;
std::tuple<int, double> t2;
std::tuple<int, double, long> t3;

}

-----------

int main()
{
std::tuple<int, double, long, Date> f1;
//4 öğe var tp bir arada tutuyor
//ilk 3 öğe value init edilir sıfır ile hayata gelir
//date için default ctor getirili

}

-----------

//öğelere erişmek için get kullanılır
//c++ 17 öncesinde non-type'dı artık type param. oldu

int main()
{
using namespace std;

tuple<int, double, long, Date> tp;

cout << get<0>(tp) << '\n';
cout << get<1>(tp) << '\n';
cout << get<2>(tp) << '\n';
cout << get<3>(tp) << '\n';
}

-------------
//get l value ref döndürür aşağıdaki kod geçerlidir

int main()
{
using namespace std;

tuple<int, double, long, Date> tp;

cout << ++get<3> << '\n';

}
------------------

int main()
{
using namespace std;

tuple<int, double, long> tp1 = {4, 4.5, 45L}; //geçerli
tuple<int, double, long> tp1 = {4, 4.5, 45L};//geçerli
tuple tp2{4, 4.5, 45L};//geçerli, ctad cpp 17
}

-------------
//aşağıdaki fabrika fonksiyonun yazılmışı vardır

template<typename ...Args>
MakeTuple(Args && ...args)
{
return std::tuple<Args>(std::forward<Args>(args)...
}

int main()
{
using namespace std;

}

--------------
//geri dönüş değeri ile kullanabiliyoruz

int main()
{
using namespace std;

int x = 235;
double dval = 3.4;
char c = 'A';

auto tp = make_tuple(x, dval, c);

cout << get<0>(tp) << '\n';
cout << get<1>(tp) << '\n';
cout << get<2>(tp) << '\n';

}

-------------
//geri dönüş değeri ile kullanabiliyoruz, farklı bir format

int main()
{
using namespace std;

int x = 235;
double dval = 3.4;
char c = 'A';

auto tp = make_tuple(x, dval, c);

cout << get<int>(tp) << '\n';
cout << get<double>(tp) << '\n';
cout << get<char>(tp) << '\n';

}

----------------

int main()
{
using namespace std;

tuple x = {2, 2.3, 2, 'A' };

cout << get<char>(x) << '\n';
cout << get<double>(x) << '\n';
cout << get<int>(x) << '\n';

}

--------------

//tuple dolaşılabilir, ancak bu dersin konusu değil 
forrange, for ile dolaşılmaz tmp teknikleri gerekir

-------------

int main()
{
using namespace std;

enum {AGE, NAME, ID };

using age = int;
using name = std::string;
using id = long;

tuple<age, name, id> tp{41, "korhan", 897878L };

cout << get<AGE>(TP) << " " << get<NAME>(tp) << " " << get<ID>(tp) << '\n';
cout << get<AGE>(TP) << " " << get<name>(tp) << " " << get<id>(tp) << '\n';

}

-------------

//en sık kullanım yerleri :
geri dönüş değeri olarak kullanılması

using PersonData = std::tuple<int, std::string, Date>;

PersonData get_person_data
{

return {Irand{20, 60}(), rname(), Date::random()};
}

int main()
{
for (int i = 0; i < 10; ++i) {
auto tp = get_person_data();

cout << get<0>(tp> << '\n';
cout << get<1>(tp> << '\n';
cout << get<2>(tp> << '\n';
(void)getchar;
}
}

----------------

using PersonData = std::tuple<int, std::string, Date>;

PersonData get_person_data
{

return {Irand{20, 60}(), rname(), Date::random()};
}

int main()
{
for (int i = 0; i < 10; ++i) {
auto [age, name, emp_date] = get_person_data(); //structure binding
cout << age << " " << name << " " << emp_date; 
(void)getchar;
}
}

--------------------

using PersonData = std::tuple<int, std::string, Date>;

int main()
{
using namespace std;

auto tp = make_tuple(234, 5.6, "nihat");;
auto [x, y, z] = tp;

}

------------------------------------

structure binding:
------------------

int main()
{
using namespace std;

int a[3] = {54, 78, 90};

auto [x, y, z] = a;
//auto &[x, y, z] = a; //dizinin elemanlarına referans olucak

a[1] *= 10;

cout << "y = " << y << '\n';
}

--------

struct Data {
int a, b, c;
};


int main()
{
using namespace std;

Data mydata{3, 8, 67 };

auto [x, y, z] = mydata;
}

------------

struct Data {
int a, b, c;
};

Data foo()
{
return {10, 20, 30 };
}

int main()
{
using namespace std;

auto [a, b] = foo; //sayı tutmadığı için sentax hataso
auto [a, b, _] = foo; //bu şekilde olabilir
//auto [x, y, _] = foo; //aynı scope'da olduğu için hat
{
//auto [x, y, _] = foo; //hata düzelir

}
}

--------------

//std::array için kullanılabilir

int main()
{
using namespace std;

array a = {3, 6, 9 };

auto [elem0, elem1, elem2];
}

!! custom bir type'ı structure binding ile kullanmak için
tuple interface denilen arayüzü implement etmemiz gerekir

--------------

//aşağıaki kodun geçerli olması için tuple interface yazmamız gerekir

int main()
{
using namespace std;

auto [day, mon, year] = Date::random();
}

----------------

//tuple interface'i

using ttype = std::tuple<int, char, double, Date>;

int main()
{
constexpr auto n = tuple_size<ttype>::value;
constexpr auto n = tuple_size_v<ttype>; //aynı anlamda 

}

---------------

//tuple type, 
                          0     1       2      3
using ttype = std::tuple<int, char, double, Date>;

int main()
{
tuple_element<2, ttype>::type
tuple_element<2, ttype>
}

------------------------------------

//tuple'da referans tutmak

int main()
{
using namespace std;

int a = 23;
double dval = 45.09;
string name{ "tamer" };

tuple<int, double, string> tp{a, dval, name }; //bunlar referans değildir

a *= 100;
dval = -1;
name += "can"; //değişiklik olmıycak

cout<< get<0>(tp> << '\n';
cout<< get<1>(tp> << '\n';
cout<< get<2>(tp> << '\n';

}

----------------

//referans tutmak

int main()
{
using namespace std;

int a = 23;
double dval = 45.09;
string name{ "tamer" };

tuple<int&, double&, string&> tp{a, dval, name }; //bunlar referans değildir

a *= 100;
dval = -1;
name += "can"; //değişiklik olur
cout<< get<0>(tp> << '\n';
cout<< get<1>(tp> << '\n';
cout<< get<2>(tp> << '\n';

}

---------------

int main()
{
using namespace std;

int a = 23;
double dval = 45.09;
string name{ "tamer" };

auto tp = make_tuple(a, dval, name);  //ref değil değişiklik olmaz

a *= 100;
dval = -1;
name += "can";

cout<< get<0>(tp> << '\n';
cout<< get<1>(tp> << '\n';
cout<< get<2>(tp> << '\n';

}

----------------------
//hem referans yapmak isteniyor hemde make_tuple kullanmak

int main()
{
using namespace std;

int a = 23;
double dval = 45.09;
string name{ "tamer" };

auto tp = make_tuple(ref(a), ref(dval), ref(name));  

a *= 100;
dval = -1;
name += "can";

cout<< get<0>(tp> << '\n';
cout<< get<1>(tp> << '\n';
cout<< get<2>(tp> << '\n';

}

------------------
//tie : tuple döndürür, ref açılımını döndürür

int main()
{
int a = 23;
double dval = 45.09;
string name{ "tamer" };

auto tp = tie(a, dval, name);
}

---------------

tuple<int, double, string> foo()
{
return {12, 4.56, "furkan mert" };
}

int main()
{
int ival;
double dval;
string name;

// 2 tuple birbirine atanabilir

tie(ival, dval, name) = foo();
//tuple<int&, double&, string&>{ival, dval, name} = foo(); //aynı şeyi yapar

cout << "ival = " << ival << '\n';
cout << "dval = " << dval << '\n';
cout << "name = " << name << '\n';
 
}

---------------------

karşışaltırma işlemleri 

tuple karşılaştırma işlemleri pair gibidir

eşit olması için karşılıklı öğelerin eşit olması gerekir

//aşağıdaki kodda 2 ayrı konu tek bir kod ile örneklenir

//contanierda tuple tutulcak, oluştutulan tuple açılımın  sort ile sıralıycağız

//tuple.cpp dosyasında

---------------------
//karşılaştırma işlemini yapacak bir fonskiyon yazmak

class Date {
public:
Date(int day, int mon, int year);
friend bool operator<(const Date&d1, const Date& d2)
{
if (d1.myear != d2.myear) {
return d1.myear < d2.myear;
}

if (d1.mmon != d2.mmon) {
return d1.mmon < d2.mmon;
}

return d1.mday < d2.mday;
}

private:
int mday;
int mmon;
int myear;
};

---------------------

//yukarıdaki yapı yerine tuple kullanılabilir

class Date {
public:
Date(int day, int mon, int year);
friend bool operator<(const Date&d1, const Date& d2)
{
return std::tuple(d1.myear, d1.mmon, d1.mday) < std::tuple(d2.myear, d2.mmon, d2.mday)
}

private:
int mday;
int mmon;
int myear;
};

-------------

2. idiom

int main()
{
int x = 10;
int y = 20;
int z = 30;
int t = 40;

print("x = {} y = {} z = {} t = {}\n", x, y,z ,t);

int temp = x; // adeta kaydırma işlemi yapıyoruz
x = y;
y = z;
z = t;
t = temp;

print("x = {} y = {} z = {} t = {}\n", x, y,z ,t);

}

-----------

int main()
{
int x = 10;
int y = 20;
int z = 30;
int t = 40;

print("x = {} y = {} z = {} t = {}\n", x, y,z ,t);

tie(x, y, z, t) = tuple(y, z, t, x);

print("x = {} y = {} z = {} t = {}\n", x, y,z ,t);
}

-----------

int main()
{
using namespace std;

int x = 10;
int y = 20;

tie(x, y) = tuple(y, x);
}

-------------

//tmp tarafında sık ihtiyaç duyulan bir kod yapısı

using namespace std;

int sum(int x, int y, int z)
{
return x + y + z;
}

int main()
{
tuple tx{3, 6, 9 };

auto ret = sum(get<0>(tx), get<1>(tx), get<2>(tx));

cout << "ret = " << ret << '\n';
}

//yukarıdaki gibi yazmak yerine tmp (meta programming) deki bir fonksiyon şablonunu kullanıyoruz
//apply

using namespace std;

int sum(int x, int y, int z)
{
return x + y + z;
}

int main()
{
tuple tx{3, 6, 9 };

auto ret = apply(sum, tx); //aply kullanılabilir

cout << "ret = " << ret << '\n';
}

-----------------------

functional'daki başka bir öğeye bakıyoruz

invoke
------


int foo(int x, int y)
{
return x + y;
}

int main()
{
int a = 5, b = 9;

int ret = sum(a, b);
int ret = invoke(sum, a, b); //bu şekilde de yapılır, invoke'a çağrılır

cout << "ret = " << ret << '\n';
}

===========================================

yeni konu başlığını hatırlayabilmek için function pointerı hatırlamamız gerekiyor

function pointer:
-----------------

int foo(int, int);

int main()
{
// &foo  => int (*)(int, int)
// int(int, int)
}

----------

int foo(int);

int main()
{
int (*fp1)(int) = foo;
int (*fp1)(int) = &foo;

}

-----------

class Nec {
public:
static int foo(int);
static int baz(int);

};

int bar(int);

int main()
{
int (*fp)(int) = &Nec::foo;

fp = bar;

fp = &Nec::baz;
}

--------------

//non-static olsa idi

class Nec {
public:
int foo(int);
int baz(int);
};

int main()
{
int (*fp)(int) = &Nec::foo; //hata, non static tutamaz static olmalı
}

--------------

non static yapıların pointer değilkeninde tutulması

class Nec {

public:
int foo(int);
int bar(int);
};

int main()
{
auto fp1 = &Nec::foo;
int (Nec::*fp2)(int) = &Nec::foo;
}

-----------
!! static ve non-static tutan öğeler aynı türden değil

class Nec {
public:
int foo(int, int);
int bar(int, int);

};

int main()
{
auto fp = &Nec::foo; //kolay yönü budur ancak pekiştirme için yapıyoruz

int (Nec::*fp)(int, int) = &Nec::foo; 
}

------------

class Nec {
public:
int foo(int, int);
int bar(int, int);
static int baz(int, int);
};

int main()
{
int (Nec::*fp)(int, int) = &Nec::foo; 
fp = &Nec::bar; //legal
fp = &Nec::baz; //Hata
int (*fptr)(int, int) = &Nec::baz; //legal

}

----------------
//zor kısıma geldik

class Nec {
public:
int foo(int x)
{
std::cout << "Nec::foo(int x) x = " << x << '\n';
return x* x;
}
};

int main()
{
auto fp = &Nec::foo; //'&' kullanmassak örtülü dönüşüm olmaz
int (Nec::*fp)(int) = &Nec::foo; //bu şekilde de olur

Nec mynec;

//mynec.fp(12); //hata nec scopeunda arar

//bunun doğru yollunu bulmak için .* operarörü kullanılır

mynec.*fp; //bu şekilde olur
mynec.*fp(20) //operatör önceliğinden dolayı hata
(mynec.*fp)(20); //Bu şekilde kullanılır
}

--------------

class Nec {
public:
int foo(int x)
{
std::cout << "Nec::foo(int x) x = " << x << '\n';
std::cout << "this = " << this << '\n';

return x* x;
}
};

int main()
{
int (Nec::*fp)(int) = &Nec::foo;
Nec mynec;
std::cout << "&mynec = " << &mynec << '\n';

(mynec.*fp)(20);
}

----------------
böyle bir funtion pointer ile neler yapılabilir


class Nec {
public:
int foo(int x);
int bar(int x);
int baz(int x);
int func(int x);

};

using necfp = int (Nec::*)(int);

int main()
{
necfp fptr;
Nec mynec;

fptr = &Nec::foo;
fptr = &Nec::bar;
fptr = &Nec::baz;

(mynec.*fptr)(456);
}

----------

class Nec {
public:
int foo(int x);
int bar(int x);
int baz(int x);
int func(int x);

};

using necfp = int (Nec::*)(int);

int main()
{
using namespace std;

vector<necfp> myvec {&Nec::foo, &Nec::bar};

myvec.push_back(&Nec::baz);
myvec.push_back(&Nec::func);

Nec mynec;

for (auto fp : myvec) {
(mynec.*fp)(10);
}
}

------------

class Nec {
public:
int foo(int x);
int bar(int x);
int baz(int x);
int func(int x);

};

using necfp = int (Nec::*)(int);

int main()
{
using namespace std;

necfp ar[] = {&Nec::foo, &Nec::bar, &Nec::baz, &Nec::func };
}

---------------

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

//Hangi üye fonksiyonun çağrılacağınıda fonksiyonu çağıran kodun belirlemesini istiyoruz

void gf(Nec& nec, int (Nec::*fp)(int))
{
(nec.*fp)(21);
}

int main()
{
Nec mynec;

gf(mynec, &Nec::foo);
gf(mynec, &Nec::bar);

}

-----------

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

//Hangi üye fonksiyonun çağrılacağınıda fonksiyonu çağıran kodun belirlemesini istiyoruz

void gf(std::vector<Nec> nvec, int (Nec::*fp)(int))
{
for (auto nec : nvec) {}
auto val = (nec.*fp)(12);
}

int main()
{
Nec mynec;

gf(mynec, &Nec::bar);

}

-------------

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

int main()
{
int (Nec::*fp)(int) = &Nec::bar;

Nec* pnec = new Nec;

((*pnec).*fp)(345);
}

--------------
2. bir operator daha var

->*

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

int main()
{
int (Nec::*fp)(int) = &Nec::bar;

Nec* pnec = new Nec;

//((*pnec).*fp)(345);
(pnec->*fp)(4657);

}

------------------

elimizide sınıf nesnesinin kendisi var ise .*
elimizide sınıf nesnesinin kendisi değil adresi var ise ->*

--------------------

bunların karmaşıklığından kurtulmak için std::invoke vardır

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

int main()
{
int (Nec:: * fp)(int) = &Nec::bar;

Nec mynec;
Nec* necptr = new Nec;

std::invoke(fp, mynec, 345);
std::invoke(fp, necptr, 345); //pointer içinde kullanılır

// (mynec.*fp)(345) //aynı anlamda
}

------------------

class Nec {
public:

void func()
{
(this->*mfp)(34);
}

int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

private:
int (Nec::*mfp)(int) = &Nec::foo;
};













