////////////////////////////////////////////////////////////////////// 1. Ders ////////////////////////////////////////////////////////////

int foo(int x, int y, int z)
{
std::print("x = {} y = {} z = {}\n", x, y, z);
}

int main()
{
using namespace std;
using namespace placeholders;

auto f = bind(foo, 20, _1, _2);

f(333,999); //20 333 999
}

------------------

struct Functor {
void operator()(int a, int b)
{
std::cout << "a = " << a << " b = " << b << "\n";
}
};

int main()
{
using namespace std;
//using namespace kullanmadığımız için aşağıda o şekilde yaptık  

auto fn = bind(Functor{}, placeholders::_1, 6512);

fn(35);

}

------------------
//lambda olabilir

struct Functor {
void operator()(int a, int b)
{
std::cout << "a = " << a << " b = " << b << "\n";
}
};

int main()
{
using namespace std;
using namespace placeholders;

auto fn = bind([](int a, int b, int c) {
return a + b + c;
}, 99, _1, _1);

auto val = fn(35);

cout << "val = " << val << '\n';
}

---------------

class Nec {
public:
void func()const 
{
std::cout << "Nec::func()\n";
}

void bar(int a)const 
{
std::cout << "Nec::bar(int a) a=  "<< a '\n';
}

};


int main()
{
using namespace placeholders;

Nec mynec;

auto f1 = std::bind(&Nec::func, _1);

f1(mynec);
auto f2 = std::bind(&Nec::bar, _1, 89);

f2(mynec);
}

-----------

void func(int& x, int &y, int& z)
{
x += 10;
y += 10;
z += 10;
}

int main()
{
using namespace std;

int a = 72;
int b = 82;
int c = 92;

auto f1 = std::bind(func, a, b, c); //kopyasını yolluyor

f1();

cout << a << " " << b << " " << c << "\n"; 
}

-----------------
//refferance wrapper kullanmamız lazım

void func(int& x, int &y, int& z)
{
x += 10;
y += 10;
z += 10;
}

int main()
{
using namespace std;

int a = 72;
int b = 82;
int c = 92;

auto f1 = std::bind(func, ref(a), ref(b), ref(c)); //kopyasını yolluyor

f1();

cout << a << " " << b << " " << c << "\n"; 
}

--------------
//biraz farklı örnekleri inceliyoruz

#include <algorihm>
#include <csdlib>

int main()
{
using namespace std;
using namespace std::placeholders;

vector<int> ivec(100);

generate(ivec.begin(), ivec.end(), []{return rand() % 1000;});

int val;

cout << "kactan buyuk olanlar sayilsin: ";
cin >> val;

//cout << count_if(ivec.begin(), ivec.end(), [val](int i) {return i > val; }) << "\n";
cout << count_if(ivec.begin(), ivec.end(), bind(greater{}, _1, val) << '\n'; //900 den büyük olanlar yazar
cout << count_if(ivec.begin(), ivec.end(), bind(greater{}, val, _1) << '\n'; //900 kaç tanesinde büyük sorusunun cevabıdır
}

-----------------

//mülakatlarda bu soru banko soruluyor

void increment(int& x)
{
++x;
}

int main()
{
using namespace std;

int ival{ 35 };

auto fn1 = bind(increment, ival);
auto fn2 = bind(increment, ref(ival));

fn1();

cout << "ival = " << ival << '\n';
fn2();
cout << "ival = " << ival << '\n';

}
 
---------------------------------------

//std::function : aldığı argümanlar ile sarmaladığı collable çağırır 
yani function pointer gibi davranır

std::function neden kullanılır, function pointer fonksiyon tutar, std::function herhngi bir collable tutabilir


int foo(int x)
{
std::cout << "foo(int) cagrildi\n";
}

int main()
{
using namespace std;

//template param. olarak bir callable'in cagrilmaya aday fonksiyon türünü
//kullanmamız gerekiyor

//foo'nun türü ne? - int(int)

//&foo'nun türü ne? - int (*)(int)
function<int(int)> f;
}

---------------

int foo(int x)
{
std::cout << "foo(int) cagrildi\n";

return x * 19;

}

int bar(int x)
{
std::cout << "bar(int) cagrildi\n";

return x * x;
}

int main()
{
using namespace std;

//function<int(int)> f(foo);
//function<int(int)> f{foo}; //bu işlemler yapılabilir
function<int(int)> f = foo;

auto ret = f(90);
cout << "ret = " << ret << '\n';

f = bar;
ret = f(90);
cout << "ret = " << ret << '\n';
}

-------------------

//ctad olur

int foo(int x)
{
std::cout << "foo(int) cagrildi\n";

return x * 19;

}

int bar(int x)
{
std::cout << "bar(int) cagrildi\n";

return x * x;
}

int main()
{
using namespace std;

function f = foo;

}

-------------------

class Nec {
public:
Nec(int x) : mx(x) {}
void print_sum(int a) const
{
std::cout << mx << " + " << a << " = " << mx + a << '\n';
}

private:
int mx;
};

void print_int(int x)
{
std::cout << "[" << x << "]\n";
}

int main()
{
using namespace std;

function<void(int)> f(print_int);

f(23);

f = [](int x) {
cout << "x = " << x << "\n";
}

f(45);
}

-------------

class Nec {
public:
Nec(int x) : mx(x) {}
void print_sum(int a) const
{
std::cout << mx << " + " << a << " = " << mx + a << '\n';
}

private:
int mx;
};

void print_int(int x)
{
std::cout << "[" << x << "]\n";
}

int main()
{
using namespace std;

function<void(const Nec&, int)> f = &Nec::print_sum;
Nec mynec(666);

f(mynec, 222);
}

---------------

int foo(int);
double bar(double);
void baz(int, int);

int main()
{
using namespace std;

function f1 = foo();
//function<int(int)> f1 = foo(); //aynı anlamda
function f2 = bar();
//function<double(double)> f2 = bar(); //aynı anlamda
function f3 = baz();
//function<void, int, int> f3 = baz(); //aynı anlamda
}

--------------

int main()
{
using namespace std;

function<int(int)> f; //şuanda bir fonksiyonu tutmaz

try
{
auto val = f(45); //exception throw eder
}
catch(const std::exception& e)
{
    std::cout << "exception caught: "<< e.what() << '\n';
}
}

!! std::function boş iken onu fonksiyon çağrı operatörünün operandı yaparsak
exeception throw eder

------------
//sınıf boş ise çağırıp çağırmamayı seçme, operator bool ile yapılır

int foo(int x)
{
return x * 6;
}

int main()
{
using namespace std;

function<int(int)> f;

//f.operator bool 
if (f) {
std::cout << "ben sana bos degilim\n";
}
else {
std::cout << "kendimi bombos hissediyorum"\n;
}

f = foo;

if (f) {
std::cout << "ben sana bos degilim\n";
}
else {
std::cout << "kendimi bombos hissediyorum"\n;
}
}

//operator bool ile fonksiyonu kontrol edebiliyoruz

---------------------------

std::function en tipik kullanım seneryoları

call back : bir fonksiyonun bir fonksiyona çağırmak

void foo(int (*fp)(int)) //bu yapıda sadece fonksiyon adresi gönderebiliriz
{
auto val = fp(12); 
}

//std::function yaparsak hertürlü callable kabul edilir

void foo(int (*fp)(int)); //sadece function callable alır

void bar(std::function<int(int)>); //her türlü callable alabilir

------------------

void bar(std::function<int(int)>);

int f(int);

struct Nec {
static int foo(int);

};

struct Erg {
bool operator()(int)const;
};

int main()
{
auto fn = [](int x) {return x * x};

bar(f);
bar(Nec::foo);
bar(Erg{});
bar(fn);

auto fb = bind(func, _1, _1, _1);
bar(fb);
}

------------------------

callable kullanılan tipik seneryolar :

using fntype = std::function<int(int, int)> //bu şekilde yazılabilir, kolaylık sağlar

int main()
{
fntype f;
}

-----------

class Myclass {
public:
void foo()
{
auto val = mf(12);
}

private:
std::function<int(int)> mf;
};

---------

contanierlarda tutmak :

int f1(int);
int f2(int);
int f3(int);
int f4(int);
int f5(int);


int main()
{
using namespace std;

vector<int (*)(int)> myvec{f1, f2, f3, f4, f5};
}

-----------

int foo(int);
int bar(int, int, int);

struct Functor{
int operator()(int)const;
};

using fntype = std::function<int(int, int)>

int main()
{
using namespace std;

vector<fntype> vec;

vec.push_back(foo);
vec.push_back([](int x) {return x * 5; });
vec.push_back(Functor{});
vec.push_back(bind(bar, _1, 10, 20));

for (auto & f : vec) {
auto val = f(12);
}
}

------------
//template olduğu için bir çok yapıya izin verir

class Myclass {
public:
int foo(int);
int bar(int)const;

};

int main()
{
using namespace std;

Myclass m;

function<int(Myclass&, int)> f1{&Myclass::foo };
function<int(const Myclass&, int)> f2{&Myclass::foo};
function<int(const Myclass*, int)> f2{&Myclass::bar};

}

-----------------------------------

mem_fn ve not_fn adaptörleri

mem_fn : sınıfın üye fonksiyonunu alır ve direk çağrılabilir hale getirir
-------

class Myclass {
public:
void func()const
{
std::cout << "Myclass:func()\n";
}

void foo(int x)const
{
std::cout << "Myclass:foo(int x) x = "<< x << "\n";
}
};

int main()
{
using namespace std;

auto f1 = mem_fn(&Myclass::func);

Myclass mx;
Myclass * ptr = &mx;

//f1(mx);
f1(ptr);
auto f2 = mem_fn(&Myclass::foo);
f2(ptr, 778);
}

-----------------
mem_fn algoritmalarda kullanılır

int main()
{
using namespace std;

vector<string> svec;
rfill(svec,20, []{return rname() + ' ' + rfname(); });

print(svec, "\n");

vector<size_t> lenvec(svec.size()); 
//string uzunluk değerlerini lenvec'e aktarmak istiyoruz

//2 yolu var
//1- lambda ile yapmak

/*transform(svec.begin(), svec.end(), lenvec.begin(), [](const string& s) {
return s.size();
});*/

//2- mem_fn ile yapımı
transform(svec.begin(), svec.end(), lenvec.begin(), mem_fn(&string::size));

print(lenvec);
}

---------

class Nec {
public:
Nec(int val) : mval(val) {}
void print()const
{
std::cout << "[" << mval << "]\n";
}
private:
int mval
};

int main()
{
using namespace std;

vector<Nec> nvec;
for (int i = 0; i < 20; ++i) {
nvec.emplace_back(i);
}

for_each(nvec.begin(), nvec.end(), [](const Nec& nec) {
nec.print();
});

for_each(nvec.begin(), nvec.end(), mem_fn(&Nec::print));

}


--------------------

not_fn: callable alır cağıırır geri dönüş değerini değil lojik değerini döndürür
//çok ihtiyaç duyulmaz

int main()
{
using namespace std;
auto f = not_fn(isprime);

int x;

cout << "bir sayi girin: ";

cin >> x;

boolalpha(cout);
cout << "is_prime "<< x << "=" << is_prime(x) << '\n';x  
cout << "is_prime "<< x << "=" << f(x) << '\n';x  

}


-------------

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'00});

//asal olanları yazdır

//copy_if
                                                                //global bir fonksiyon olduğu için 'isprime' şeklinde de yazılabilir 
copy_if(ivec.begin(), ivec.end(), ostrram_iterator<int>{cout, "\n"}, &isprime);

}

-------------

//asal olmayanların yazılması

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'00});

copy_if(ivec.begin(), ivec.end(), ostrram_iterator<int>{cout, "\n"}, [](int x) {
return !is_prime(x); });

copy_if(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"},  not_fn(isprime)); //aynı etkiyi yapar


});

-------------

struct Pred {
bool operator()(int x) const 
{
return x % 7 == 0;
}
};

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'000});

copy_if(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"}, not_fn(Pred{}));

}

---------
//lambda ile yapılması

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'000});

std::cout << "bir tam sayi girin: ";
int x{};
cin >> x;
auto f = [](int i) {return i % x == 0; };

copy_if(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"}, not_fn(fn);

}

=======================================================

std::array :  c dizilerinin sarmalayan rupper sınıf
------------

//basitleştirilmiş hali

template<typename T, std::size_t n>
struct Array {
T ar[n];
};

int main()
{
using namespace std;

Array<int, 10> x;
Array<string, 20> y;

}

--------------

c++ da aggregate type denilen yapı var ve bu yapının ilave özellikleri vardır

struct Nec {
int x, y, z;
};

int main()
{
Nec mynec = {2, 5, 8} ; //aggregate özelliği
}

----------

struct Nec {
int a[5];
};

int main()
{
Nec mynec = {2, 5, 8} ; //aggregate özelliği
}

----------

template<typename T, std::size_t n>
struct Array {
T ar[n];
};

int main()
{
using namespace std;

Array<int, 10> x = {3,5,6,8,9};

}

---------------

std::array bir aggregate'dır.

---------------

struct Nec {
int a, b, c;
};

int main()
{
Nec mynec;

std::cout << mynec.a << mynec.b << mynec.c << "\n"; //ub, ilk değer verilmediği için garbage value
}

----------

struct Nec {
int a, b, c;
};

int main()
{
Nec mynec{}; //ub kalkar, 0 olur değeler

std::cout << mynec.a << mynec.b << mynec.c << "\n"

----------

//mülakatlarda necati hoca çok soruyor

int main()
{
array<int, 5> ar; //ub

cout << ar[0] << '\n'; 
}

---------

int main()
{
array<int, 5> ar{}; //o olma garantisi vardır

cout << ar[0] << '\n'; 
}

-----------

array sıfır maaliyetlidir

------------

neden c değilde std::array kullanalım?

!! çok özel durumlarun dışında std::array kullanmak iyidir

-STL uyumludur

-interface vardır

- .at exception throw eder

- array decay tehlikesi ortandan kalkar hiçbir şekilde ilk öğeye erişme olmaz(array decay ile), aynı maaliyetle array decayden arındırmış oluruz

- c ve c++ 'da fonksiyonlar ve geri dönüş değerleri dizi olamaz, ancak fonksiyon parametresi std::array olabilir

- std::array'de nesne yine stack'de


-----------

//interface

int main()
{
using namespace std;

array<int, 5> ar;

ar. //fonksiyonları incele
}

-----------

int main()
{
using namespace std;

int a[0]; //dizi boyutu sıfır olamaz, hata

//std::array bir sınıf şablonudur, arayde sentax hatası olmaz

}

-----------

int main()
{
using namespace std;

array<int, 0> ax;

boolalpha(cout);

cout << "ax.size() = " << ax.size() << '\n';
cout << << ax.empty() << "\n";


}

-----------

//temel özellikleri

-range base for loop ile kullanılabilir

int main()
{
using namespace std;

array<int, 5> ax{};
array<int, 5> ax; //garbage value olur

for (auto i : ax)
cout << i << ' ';
}

----------
//stad'dan faydalanabilinir

int main()
{
using namespace std;

array x = {1,2,3,4,5,6,7}; //legal ancak bütün tülerin aynı olması lazmım
array x = {1,2,3,4,5,6,7u}; //Hata

array x<int>; //geçerli değil, nedenini hoca açıklamadı
array x<>; //geçerli değil, nedenini hoca açıklamadı

}

----------

std::aray<int, 3> foo(int a, int b, int c)
{
//aşağıdaki yapıların heps geçerli

//return std::array<int, 3> {a, b,c};
//return std::array {a,b,c};
return {a,b,c};
}

//mülakatlarda sorulabilir

int main()
{
using namespace std;

int a[] = {1, 3, 4, 7, 2, 5, 7,13};

array ar = {begin(a), end(a)};
}

------------

std::aray<int, 3> foo(int a, int b, int c)
{

return {a,b,c};
}

int main()
{
using namespace std;

array<double, 5> ax{};
array<int, 5> ay{};

ax = ay; //hata

copy(ay.begin(), ay.end(), ax.begin());
}

-----------
//array inseteri yok

template <typename T, std::size_t n>
std::ostream& operatot << (std::ostream&os, const std::array<T, n>&ar)
{
os << '[';
for (std::size_t i{}; i < ar.size(); ++i)[
os << ar[i] << " , ";
}

return os << ar.back()) << "]";
}

int main()
{
using namespace std;

array<int, 3> ax{2, 5, 7};

cout << ax << "\n";
}

---------------
//literal operator

template <typename T, std::size_t n>
std::ostream& operatot << (std::ostream&os, const std::array<T, n>&ar)
{
os << '[';
for (std::size_t i{}; i < ar.size(); ++i)[
os << ar[i] << " , ";
}

return os << ar.back()) << "]";
}

int main()
{
using namespace std;

array a = {"naci"s, "cemal"s, "dagdalen"s};


}

--------------

template <typename T, std::size_t n>
std::ostream& operatot << (std::ostream&os, const std::array<T, n>&ar)
{
os << '[';
for (std::size_t i{}; i < ar.size(); ++i)[
os << ar[i] << " , ";
}

return os << ar.back()) << "]";
}

int main()
{
using namespace std;

array<array<int, 3>, 4> ar {{2,2,2}, {3,3,3}, {5,5,5}, {7,7,7}//bu şekilde yapılabilir

cout << ar << "\n";
}

/////////////////////////////////////////////// 2. Ders ////////////////////////////////////////////















