////////////////////////////////////////////////////////////////////// 1. Ders ////////////////////////////////////////////////////////////

int foo(int x, int y, int z)
{
std::print("x = {} y = {} z = {}\n", x, y, z);
}

int main()
{
using namespace std;
using namespace placeholders;

auto f = bind(foo, 20, _1, _2);

f(333,999); //20 333 999
}

------------------

struct Functor {
void operator()(int a, int b)
{
std::cout << "a = " << a << " b = " << b << "\n";
}
};

int main()
{
using namespace std;
//using namespace kullanmadığımız için aşağıda o şekilde yaptık  

auto fn = bind(Functor{}, placeholders::_1, 6512);

fn(35);

}

------------------
//lambda olabilir

struct Functor {
void operator()(int a, int b)
{
std::cout << "a = " << a << " b = " << b << "\n";
}
};

int main()
{
using namespace std;
using namespace placeholders;

auto fn = bind([](int a, int b, int c) {
return a + b + c;
}, 99, _1, _1);

auto val = fn(35);

cout << "val = " << val << '\n';
}

---------------

class Nec {
public:
void func()const 
{
std::cout << "Nec::func()\n";
}

void bar(int a)const 
{
std::cout << "Nec::bar(int a) a=  "<< a '\n';
}

};


int main()
{
using namespace placeholders;

Nec mynec;

auto f1 = std::bind(&Nec::func, _1);

f1(mynec);
auto f2 = std::bind(&Nec::bar, _1, 89);

f2(mynec);
}

-----------

void func(int& x, int &y, int& z)
{
x += 10;
y += 10;
z += 10;
}

int main()
{
using namespace std;

int a = 72;
int b = 82;
int c = 92;

auto f1 = std::bind(func, a, b, c); //kopyasını yolluyor

f1();

cout << a << " " << b << " " << c << "\n"; 
}

-----------------
//refferance wrapper kullanmamız lazım

void func(int& x, int &y, int& z)
{
x += 10;
y += 10;
z += 10;
}

int main()
{
using namespace std;

int a = 72;
int b = 82;
int c = 92;

auto f1 = std::bind(func, ref(a), ref(b), ref(c)); //kopyasını yolluyor

f1();

cout << a << " " << b << " " << c << "\n"; 
}

--------------
//biraz farklı örnekleri inceliyoruz

#include <algorihm>
#include <csdlib>

int main()
{
using namespace std;
using namespace std::placeholders;

vector<int> ivec(100);

generate(ivec.begin(), ivec.end(), []{return rand() % 1000;});

int val;

cout << "kactan buyuk olanlar sayilsin: ";
cin >> val;

//cout << count_if(ivec.begin(), ivec.end(), [val](int i) {return i > val; }) << "\n";
cout << count_if(ivec.begin(), ivec.end(), bind(greater{}, _1, val) << '\n'; //900 den büyük olanlar yazar
cout << count_if(ivec.begin(), ivec.end(), bind(greater{}, val, _1) << '\n'; //900 kaç tanesinde büyük sorusunun cevabıdır
}

-----------------

//mülakatlarda bu soru banko soruluyor

void increment(int& x)
{
++x;
}

int main()
{
using namespace std;

int ival{ 35 };

auto fn1 = bind(increment, ival);
auto fn2 = bind(increment, ref(ival));

fn1();

cout << "ival = " << ival << '\n';
fn2();
cout << "ival = " << ival << '\n';

}
 
---------------------------------------

//std::function : aldığı argümanlar ile sarmaladığı collable çağırır 
yani function pointer gibi davranır

std::function neden kullanılır, function pointer fonksiyon tutar, std::function herhngi bir collable tutabilir


int foo(int x)
{
std::cout << "foo(int) cagrildi\n";
}

int main()
{
using namespace std;

//template param. olarak bir callable'in cagrilmaya aday fonksiyon türünü
//kullanmamız gerekiyor

//foo'nun türü ne? - int(int)

//&foo'nun türü ne? - int (*)(int)
function<int(int)> f;
}

---------------

int foo(int x)
{
std::cout << "foo(int) cagrildi\n";

return x * 19;

}

int bar(int x)
{
std::cout << "bar(int) cagrildi\n";

return x * x;
}

int main()
{
using namespace std;

//function<int(int)> f(foo); //f çağrıldığı zaman foo çağrılmış olur
//function<int(int)> f{foo}; //bu işlemler yapılabilir
function<int(int)> f = foo;

auto ret = f(90); //foo çağrılır
cout << "ret = " << ret << '\n';

f = bar;
ret = f(90);//bar çağrılır
cout << "ret = " << ret << '\n';
}

-------------------

//CTAD olur

int foo(int x)
{
std::cout << "foo(int) cagrildi\n";

return x * 19;

}

int bar(int x)
{
std::cout << "bar(int) cagrildi\n";

return x * x;
}

int main()
{
using namespace std;

function f = foo; //CTAD

}

-------------------

class Nec {
public:
Nec(int x) : mx(x) {}
void print_sum(int a) const
{
std::cout << mx << " + " << a << " = " << mx + a << '\n';
}

private:
int mx;
};

void print_int(int x)
{
std::cout << "[" << x << "]\n";
}

int main()
{
using namespace std;

function<void(int)> f(print_int);

f(23);

f = [](int x) {
cout << "x = " << x << "\n";
}

f(45);
}

-------------

class Nec {
public:
Nec(int x) : mx(x) {}
void print_sum(int a) const
{
std::cout << mx << " + " << a << " = " << mx + a << '\n';
}

private:
int mx;
};

void print_int(int x)
{
std::cout << "[" << x << "]\n";
}

int main()
{
using namespace std;

function<void(const Nec&, int)> f = &Nec::print_sum;
Nec mynec(666);

f(mynec, 222);
}

---------------

int foo(int);
double bar(double);
void baz(int, int);

int main()
{
using namespace std;

function f1 = foo();
//function<int(int)> f1 = foo(); //aynı anlamda
function f2 = bar();
//function<double(double)> f2 = bar(); //aynı anlamda
function f3 = baz();
//function<void, int, int> f3 = baz(); //aynı anlamda
}

--------------

int main()
{
using namespace std;

function<int(int)> f; //şuanda bir fonksiyonu tutmaz

try
{
auto val = f(45); //exception throw eder
}
catch(const std::exception& e)
{
    std::cout << "exception caught: "<< e.what() << '\n';
}
}

!! std::function boş iken onu fonksiyon çağrı operatörünün operandı yaparsak
exeception throw eder

------------
//sınıf boş ise çağırıp çağırmamayı seçme, operator bool ile yapılır

int foo(int x)
{
return x * 6;
}

int main()
{
using namespace std;

function<int(int)> f;

//f.operator bool 
if (f) {
std::cout << "ben sana bos degilim\n";
}
else {
std::cout << "kendimi bombos hissediyorum"\n;
}

f = foo;

if (f) {
std::cout << "ben sana bos degilim\n";
}
else {
std::cout << "kendimi bombos hissediyorum"\n;
}
}

//operator bool ile fonksiyonu kontrol edebiliyoruz

---------------------------

std::function en tipik kullanım seneryoları

call back : bir fonksiyonun bir fonksiyona çağırmak

void foo(int (*fp)(int)) //bu yapıda sadece fonksiyon adresi gönderebiliriz
{
auto val = fp(12); 
}

//std::function yaparsak hertürlü callable kabul edilir

void foo(int (*fp)(int)); //sadece function callable alır

void bar(std::function<int(int)>); //her türlü callable alabilir

------------------

void bar(std::function<int(int)>);

int f(int);

struct Nec {
static int foo(int);

};

struct Erg {
bool operator()(int)const;
};

int main()
{
auto fn = [](int x) {return x * x};

bar(f);
bar(Nec::foo);
bar(Erg{});
bar(fn);

auto fb = bind(func, _1, _1, _1);
bar(fb);
}

------------------------

callable kullanılan tipik seneryolar :

using fntype = std::function<int(int, int)> //bu şekilde yazılabilir, kolaylık sağlar

int main()
{
fntype f;
}

-----------

class Myclass {
public:
void foo()
{
auto val = mf(12);
}

private:
std::function<int(int)> mf; //bu şekilde olması en tipik sneryoladan birisi
};

---------

contanierlarda tutmak :

int f1(int);
int f2(int);
int f3(int);
int f4(int);
int f5(int);


int main()
{
using namespace std;

vector<int (*)(int)> myvec{f1, f2, f3, f4, f5}; //bu vektör fonksiyon adresleri tutar
}

-----------

int foo(int);
int bar(int, int, int);

struct Functor{
int operator()(int)const;
};

using fntype = std::function<int(int, int)>

int main()
{
using namespace std;

vector<fntype> vec; //her şeyi tutabiliyoruz içerisinde

vec.push_back(foo);
vec.push_back([](int x) {return x * 5; });
vec.push_back(Functor{});
vec.push_back(bind(bar, _1, 10, 20));

for (auto & f : vec) {
auto val = f(12);
}
}

------------
//template olduğu için bir çok yapıya izin verir

class Myclass {
public:
int foo(int);
int bar(int)const;

};

int main()
{
using namespace std;

Myclass m;

function<int(Myclass&, int)> f1{&Myclass::foo};
function<int(const Myclass&, int)> f2{&Myclass::foo};
function<int(const Myclass*, int)> f2{&Myclass::bar};

}

---------------------------------------------

mem_fn ve not_fn adaptörleri

mem_fn : sınıfın üye fonksiyonunu alır ve direk çağrılabilir hale getirir
-------

class Myclass {
public:
void func()const
{
std::cout << "Myclass:func()\n";
}

void foo(int x)const
{
std::cout << "Myclass:foo(int x) x = "<< x << "\n";
}
};

int main()
{
using namespace std;

auto f1 = mem_fn(&Myclass::func);

Myclass mx;
Myclass * ptr = &mx;

//f1(mx);
f1(ptr);
auto f2 = mem_fn(&Myclass::foo);
f2(ptr, 778);
}

-----------------
mem_fn kullanıldığı tipik seneryo, algoritmalarda kullanılmasıdır

int main()
{
using namespace std;

vector<string> svec;
rfill(svec,20, []{return rname() + ' ' + rfname(); });

print(svec, "\n");

vector<size_t> lenvec(svec.size()); 
//string uzunluk değerlerini lenvec'e aktarmak istiyoruz

//2 yolu var
//1- lambda ile yapmak

/*transform(svec.begin(), svec.end(), lenvec.begin(), [](const string& s) {
return s.size();
});*/

//2- mem_fn ile yapımı
transform(svec.begin(), svec.end(), lenvec.begin(), mem_fn(&string::size));

print(lenvec);
}

---------

class Nec {
public:
Nec(int val) : mval(val) {}
void print()const
{
std::cout << "[" << mval << "]\n";
}
private:
int mval
};

int main()
{
using namespace std;

vector<Nec> nvec;
for (int i = 0; i < 20; ++i) {
nvec.emplace_back(i);
}

for_each(nvec.begin(), nvec.end(), [](const Nec& nec) {
nec.print();
});

for_each(nvec.begin(), nvec.end(), mem_fn(&Nec::print));

}


--------------------

not_fn: callable alır cağıırır geri dönüş değerini değil lojik değerini döndürür
//çok ihtiyaç duyulmaz

int main()
{
using namespace std;
auto f = not_fn(isprime);

int x;

cout << "bir sayi girin: ";

cin >> x;

boolalpha(cout);
cout << "is_prime "<< x << "=" << is_prime(x) << '\n';x  
cout << "is_prime "<< x << "=" << f(x) << '\n';x  

}


-------------

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'00});

//asal olanları yazdır

//copy_if
                                                                //global bir fonksiyon olduğu için 'isprime' şeklinde de yazılabilir 
copy_if(ivec.begin(), ivec.end(), ostrram_iterator<int>{cout, "\n"}, &isprime);

}

-------------

//asal olmayanların yazılması

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'00});

copy_if(ivec.begin(), ivec.end(), ostrram_iterator<int>{cout, "\n"}, [](int x) {
return !is_prime(x); });

copy_if(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"},  not_fn(isprime)); //aynı etkiyi yapar


});

-------------

struct Pred {
bool operator()(int x) const 
{
return x % 7 == 0;
}
};

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'000});

copy_if(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"}, not_fn(Pred{}));

}

---------
//lambda ile yapılması

int main()
{
using namespace std;

vector<int> ivec;
rfill(ivec, 100, Irand{0, 100'000});

std::cout << "bir tam sayi girin: ";
int x{};
cin >> x;
auto f = [](int i) {return i % x == 0; };

copy_if(ivec.begin(), ivec.end(), ostream_iterator<int>{cout, "\n"}, not_fn(fn);

}

=======================================================

std::array :  c dizilerinin sarmalayan rupper sınıf
------------

//basitleştirilmiş hali

template<typename T, std::size_t n>
struct Array {
T ar[n];
};

int main()
{
using namespace std;

Array<int, 10> x;
Array<string, 20> y;

}

--------------

c++ da aggregate type denilen yapı var ve bu yapının ilave özellikleri vardır

struct Nec {
int x, y, z;
};

int main()
{
Nec mynec = {2, 5, 8} ; //aggregate özelliği
}

----------

struct Nec {
int a[5];
};

int main()
{
Nec mynec = {2, 5, 8} ; //aggregate özelliği
}

----------

template<typename T, std::size_t n>
struct Array {
T ar[n];
};

int main()
{
using namespace std;

Array<int, 10> x = {3,5,6,8,9};

}

---------------

std::array bir aggregate'dır.

---------------

struct Nec {
int a, b, c;
};

int main()
{
Nec mynec;

std::cout << mynec.a << mynec.b << mynec.c << "\n"; //ub, ilk değer verilmediği için garbage value
}

----------

struct Nec {
int a, b, c;
};

int main()
{
Nec mynec{}; //ub kalkar, 0 olur değeler

std::cout << mynec.a << mynec.b << mynec.c << "\n"

----------

//mülakatlarda necati hoca çok soruyor

int main()
{
array<int, 5> ar; //ub

cout << ar[0] << '\n'; 
}

---------

int main()
{
array<int, 5> ar{}; //o olma garantisi vardır

cout << ar[0] << '\n'; 
}

-----------

array sıfır maaliyetlidir

------------

neden c değilde std::array kullanalım?

!! çok özel durumlarun dışında std::array kullanmak iyidir

-STL uyumludur

-interface vardır

- .at exception throw eder

- array decay tehlikesi ortandan kalkar hiçbir şekilde ilk öğeye erişme olmaz(array decay ile), aynı maaliyetle array decayden arındırmış oluruz

- c ve c++ 'da fonksiyonlar ve geri dönüş değerleri dizi olamaz, ancak fonksiyon parametresi std::array olabilir

- std::array'de nesne yine stack'de


-----------

//interface

int main()
{
using namespace std;

array<int, 5> ar;

ar. //fonksiyonları incele
}

-----------

int main()
{
using namespace std;

int a[0]; //dizi boyutu sıfır olamaz, hata

//std::array bir sınıf şablonudur, arayde sentax hatası olmaz

}

-----------

int main()
{
using namespace std;

array<int, 0> ax;

boolalpha(cout);

cout << "ax.size() = " << ax.size() << '\n';
cout << << ax.empty() << "\n";


}

-----------

//temel özellikleri

-range base for loop ile kullanılabilir

int main()
{
using namespace std;

array<int, 5> ax{};
array<int, 5> ax; //garbage value olur

for (auto i : ax)
cout << i << ' ';
}

----------
//stad'dan faydalanabilinir

int main()
{
using namespace std;

array x = {1,2,3,4,5,6,7}; //legal ancak bütün tülerin aynı olması lazmım
array x = {1,2,3,4,5,6,7u}; //Hata

array x<int>; //geçerli değil, nedenini hoca açıklamadı
array x<>; //geçerli değil, nedenini hoca açıklamadı

}

----------

std::aray<int, 3> foo(int a, int b, int c)
{
//aşağıdaki yapıların heps geçerli

//return std::array<int, 3> {a, b,c};
//return std::array {a,b,c};
return {a,b,c};
}

//mülakatlarda sorulabilir

int main()
{
using namespace std;

int a[] = {1, 3, 4, 7, 2, 5, 7,13};

array ar = {begin(a), end(a)};
}

------------

std::aray<int, 3> foo(int a, int b, int c)
{

return {a,b,c};
}

int main()
{
using namespace std;

array<double, 5> ax{};
array<int, 5> ay{};

ax = ay; //hata

copy(ay.begin(), ay.end(), ax.begin());
}

-----------
//array inseteri yok

template <typename T, std::size_t n>
std::ostream& operatot << (std::ostream&os, const std::array<T, n>&ar)
{
os << '[';
for (std::size_t i{}; i < ar.size(); ++i)[
os << ar[i] << " , ";
}

return os << ar.back()) << "]";
}

int main()
{
using namespace std;

array<int, 3> ax{2, 5, 7};

cout << ax << "\n";
}

---------------
//literal operator

template <typename T, std::size_t n>
std::ostream& operatot << (std::ostream&os, const std::array<T, n>&ar)
{
os << '[';
for (std::size_t i{}; i < ar.size(); ++i)[
os << ar[i] << " , ";
}

return os << ar.back()) << "]";
}

int main()
{
using namespace std;

array a = {"naci"s, "cemal"s, "dagdalen"s};


}

--------------

template <typename T, std::size_t n>
std::ostream& operatot << (std::ostream&os, const std::array<T, n>&ar)
{
os << '[';
for (std::size_t i{}; i < ar.size(); ++i)[
os << ar[i] << " , ";
}

return os << ar.back()) << "]";
}

int main()
{
using namespace std;

array<array<int, 3>, 4> ar {{2,2,2}, {3,3,3}, {5,5,5}, {7,7,7}//bu şekilde yapılabilir

cout << ar << "\n";
}

/////////////////////////////////////////////// 2. Ders ////////////////////////////////////////////

//mülakatlarda neden array kullanıyoruz sorusu sorulur?

-sıfır maaliyetli 

-array'in sunduğu interface vardır

-array decay yok

int main()
{
using namespace std;

array a{1, 3, 5, ,7, 8};
//int *p1 = a; //olmaz

int* p2 = a.data();
int* p3 = &a[0];
int* p4 = &a.at(0);
int* p5 = &*a.begin();
}

---------------

//şaşırtmalı bir soru

int main()
{
using namespace std;

int a[5]{};

3[a]++; //legal
}

---------------
//c tekrar

p[2] //aynı anlamda

*(p + 2) //aynı anlamda

2[p] //aynı anlamda

----------------
//c tekrar
int main()
{
using namespace std;

constexpr auto val = 2["elma] - 1["elma"]; //2. indisten 1. indis çıkar 1 kalır
}

------------------

int main()
{
using namespace std;

array<int, 5> a{};

3[a]++; //geçerli değil bu bir sınıf nesnesi
}

==================================================

tuple :pair'in çoklusudur
-----

int main()
{
using namespace std;

//aşağıdaki şekillerde olabilir
std::tuple<> t0
std::tuple<int> t1;
std::tuple<int, double> t2;
std::tuple<int, double, long> t3;

}

-----------

int main()
{
std::tuple<int, double, long, Date> f1;
//4 öğe var tp bir arada tutuyor
//ilk 3 öğe value init edilir sıfır ile hayata gelir
//date için default ctor çağrıldı, sınıf nesnesi olduğu içinx 

}

-----------

//öğelere erişmek için get kullanılır
//c++ 17 öncesinde non-type'dı artık type param. oldu

int main()
{
using namespace std;

tuple<int, double, long, Date> tp;

cout << get<0>(tp) << '\n';
cout << get<1>(tp) << '\n';
cout << get<2>(tp) << '\n';
cout << get<3>(tp) << '\n';
}

-------------
//get l value ref döndürür aşağıdaki kod geçerlidir

int main()
{
using namespace std;

tuple<int, double, long, Date> tp;

cout << ++get<3> << '\n';

}
------------------

int main()
{
using namespace std;

tuple<int, double, long> tp1 = {4, 4.5, 45L}; //geçerli
tuple<int, double, long> tp1 = {4, 4.5, 45L};//geçerli
tuple tp2{4, 4.5, 45L};//geçerli, ctad cpp 17
}

-------------
//aşağıdaki fabrika fonksiyonun yazılmışı vardır

template<typename ...Args>
MakeTuple(Args && ...args)
{
return std::tuple<Args>(std::forward<Args>(args)...
}

int main()
{
using namespace std;

}

--------------
//geri dönüş değeri ile kullanabiliyoruz

int main()
{
using namespace std;

int x = 235;
double dval = 3.4;
char c = 'A';

auto tp = make_tuple(x, dval, c);

cout << get<0>(tp) << '\n';
cout << get<1>(tp) << '\n';
cout << get<2>(tp) << '\n';

}

-------------
//geri dönüş değeri ile kullanabiliyoruz, farklı bir format

int main()
{
using namespace std;

int x = 235;
double dval = 3.4;
char c = 'A';

auto tp = make_tuple(x, dval, c);

cout << get<int>(tp) << '\n';
cout << get<double>(tp) << '\n';
cout << get<char>(tp) << '\n';

}

----------------

int main()
{
using namespace std;

tuple x = {2, 2.3, 2, 'A' };

cout << get<char>(x) << '\n';
cout << get<double>(x) << '\n';
cout << get<int>(x) << '\n';

}

--------------

//tuple dolaşılabilir, ancak bu dersin konusu değil 
forrange, for ile dolaşılmaz tmp teknikleri gerekir

-------------

int main()
{
using namespace std;

enum {AGE, NAME, ID };

using age = int;
using name = std::string;
using id = long;

tuple<age, name, id> tp{41, "korhan", 897878L };

cout << get<AGE>(TP) << " " << get<NAME>(tp) << " " << get<ID>(tp) << '\n';
cout << get<AGE>(TP) << " " << get<name>(tp) << " " << get<id>(tp) << '\n';

}

-------------

//en sık kullanım yerleri :
geri dönüş değeri olarak kullanılması

using PersonData = std::tuple<int, std::string, Date>;

PersonData get_person_data
{

return {Irand{20, 60}(), rname(), Date::random()};
}

int main()
{
for (int i = 0; i < 10; ++i) {
auto tp = get_person_data();

cout << get<0>(tp) << '\n';
cout << get<1>(tp) << '\n';
cout << get<2>(tp) << '\n';
(void)getchar;
}
}

----------------

using PersonData = std::tuple<int, std::string, Date>;

PersonData get_person_data
{

return {Irand{20, 60}(), rname(), Date::random()};
}

int main()
{
for (int i = 0; i < 10; ++i) {
auto [age, name, emp_date] = get_person_data(); //structure binding
cout << age << " " << name << " " << emp_date; 
(void)getchar;
}
}

--------------------

using PersonData = std::tuple<int, std::string, Date>;

int main()
{
using namespace std;

auto tp = make_tuple(234, 5.6, "nihat");;
auto [x, y, z] = tp;

}

------------------------------------

structure binding:
------------------

int main()
{
using namespace std;

int a[3] = {54, 78, 90};

auto [x, y, z] = a;
//auto &[x, y, z] = a; //dizinin elemanlarına referans olucak

a[1] *= 10;

cout << "y = " << y << '\n';
}

--------

struct Data {
int a, b, c;
};


int main()
{
using namespace std;

Data mydata{3, 8, 67 };

auto [x, y, z] = mydata;
}

------------

struct Data {
int a, b, c;
};

Data foo()
{
return {10, 20, 30 };
}

int main()
{
using namespace std;

auto [a, b] = foo; //sayı tutmadığı için sentax hataso
auto [a, b, _] = foo; //bu şekilde olabilir
//auto [x, y, _] = foo; //aynı scope'da olduğu için hat
{
//auto [x, y, _] = foo; //hata düzelir

}
}

--------------

//std::array için kullanılabilir

int main()
{
using namespace std;

array a = {3, 6, 9 };

auto [elem0, elem1, elem2];
}

!! custom bir type'ı structure binding ile kullanmak için
tuple interface denilen arayüzü implement etmemiz gerekir

--------------

//aşağıaki kodun geçerli olması için tuple interface yazmamız gerekir

int main()
{
using namespace std;

auto [day, mon, year] = Date::random();
}

----------------

//tuple interface'i

using ttype = std::tuple<int, char, double, Date>;

int main()
{
constexpr auto n = tuple_size<ttype>::value;
constexpr auto n = tuple_size_v<ttype>; //aynı anlamda 

}

---------------

//tuple type, 
                          0     1       2      3
using ttype = std::tuple<int, char, double, Date>;

int main()
{
tuple_element<2, ttype>::type
tuple_element<2, ttype>
}

------------------------------------

//tuple'da referans tutmak

int main()
{
using namespace std;

int a = 23;
double dval = 45.09;
string name{ "tamer" };

tuple<int, double, string> tp{a, dval, name }; //bunlar referans değildir

a *= 100;
dval = -1;
name += "can"; //değişiklik olmıycak

cout<< get<0>(tp) << '\n';
cout<< get<1>(tp) << '\n';
cout<< get<2>(tp) << '\n';

}

----------------

//referans tutmak

int main()
{
using namespace std;

int a = 23;
double dval = 45.09;
string name{ "tamer" };

tuple<int&, double&, string&> tp{a, dval, name }; //bunlar referans değildir

a *= 100;
dval = -1;
name += "can"; //değişiklik olur
cout<< get<0>(tp) << '\n';
cout<< get<1>(tp) << '\n';
cout<< get<2>(tp) << '\n';

}

---------------

int main()
{
using namespace std;

int a = 23;
double dval = 45.09;
string name{ "tamer" };

auto tp = make_tuple(a, dval, name);  //ref değil değişiklik olmaz

a *= 100;
dval = -1;
name += "can";

cout<< get<0>(tp) << '\n';
cout<< get<1>(tp) << '\n';
cout<< get<2>(tp) << '\n';

}

----------------------
//hem referans yapmak isteniyor hemde make_tuple kullanmak

int main()
{
using namespace std;

int a = 23;
double dval = 45.09;
string name{ "tamer" };

auto tp = make_tuple(ref(a), ref(dval), ref(name));  

a *= 100;
dval = -1;
name += "can";

cout<< get<0>(tp> << '\n';
cout<< get<1>(tp> << '\n';
cout<< get<2>(tp> << '\n';

}

------------------
//tie : tuple döndürür, ref açılımını döndürür

int main()
{
int a = 23;
double dval = 45.09;
string name{ "tamer" };

auto tp = tie(a, dval, name);
}

---------------

tuple<int, double, string> foo()
{
return {12, 4.56, "furkan mert" };
}

int main()
{
int ival;
double dval;
string name;

// 2 tuple birbirine atanabilir

tie(ival, dval, name) = foo();
//tuple<int&, double&, string&>{ival, dval, name} = foo(); //aynı şeyi yapar

cout << "ival = " << ival << '\n';
cout << "dval = " << dval << '\n';
cout << "name = " << name << '\n';
 
}

---------------------

karşışaltırma işlemleri 

tuple karşılaştırma işlemleri pair gibidir

eşit olması için karşılıklı öğelerin eşit olması gerekir

//aşağıdaki kodda 2 ayrı konu tek bir kod ile örneklenir

//contanierda tuple tutulcak, oluştutulan tuple açılımın  sort ile sıralıycağız

//tuple.cpp dosyasında

---------------------
//karşılaştırma işlemini yapacak bir fonskiyon yazmak

class Date {
public:
Date(int day, int mon, int year);
friend bool operator<(const Date&d1, const Date& d2)
{
if (d1.myear != d2.myear) {
return d1.myear < d2.myear;
}

if (d1.mmon != d2.mmon) {
return d1.mmon < d2.mmon;
}

return d1.mday < d2.mday;
}

private:
int mday;
int mmon;
int myear;
};

---------------------

//yukarıdaki yapı yerine tuple kullanılabilir

class Date {
public:
Date(int day, int mon, int year);
friend bool operator<(const Date&d1, const Date& d2)
{
return std::tuple(d1.myear, d1.mmon, d1.mday) < std::tuple(d2.myear, d2.mmon, d2.mday)
}

private:
int mday;
int mmon;
int myear;
};

-------------

2. idiom

int main()
{
int x = 10;
int y = 20;
int z = 30;
int t = 40;

print("x = {} y = {} z = {} t = {}\n", x, y,z ,t);

int temp = x; // adeta kaydırma işlemi yapıyoruz
x = y;
y = z;
z = t;
t = temp;

print("x = {} y = {} z = {} t = {}\n", x, y,z ,t);

}

-----------

int main()
{
int x = 10;
int y = 20;
int z = 30;
int t = 40;

print("x = {} y = {} z = {} t = {}\n", x, y,z ,t);

tie(x, y, z, t) = tuple(y, z, t, x);

print("x = {} y = {} z = {} t = {}\n", x, y,z ,t);
}

-----------

int main()
{
using namespace std;

int x = 10;
int y = 20;

tie(x, y) = tuple(y, x);
}

-------------

//tmp tarafında sık ihtiyaç duyulan bir kod yapısı

using namespace std;

int sum(int x, int y, int z)
{
return x + y + z;
}

int main()
{
tuple tx{3, 6, 9 };

auto ret = sum(get<0>(tx), get<1>(tx), get<2>(tx));

cout << "ret = " << ret << '\n';
}

//yukarıdaki gibi yazmak yerine tmp (meta programming) deki bir fonksiyon şablonunu kullanıyoruz
//apply

using namespace std;

int sum(int x, int y, int z)
{
return x + y + z;
}

int main()
{
tuple tx{3, 6, 9 };

auto ret = apply(sum, tx); //aply kullanılabilir

cout << "ret = " << ret << '\n';
}

-----------------------

functional'daki başka bir öğeye bakıyoruz

invoke
------


int foo(int x, int y)
{
return x + y;
}

int main()
{
int a = 5, b = 9;

int ret = sum(a, b);
int ret = invoke(sum, a, b); //bu şekilde de yapılır, invoke'a çağrılır

cout << "ret = " << ret << '\n';
}

===========================================

yeni konu başlığını hatırlayabilmek için function pointerı hatırlamamız gerekiyor

function pointer:
-----------------

int foo(int, int);

int main()
{
// &foo  => int (*)(int, int)
// int(int, int)
}

----------

int foo(int);

int main()
{
int (*fp1)(int) = foo;
int (*fp1)(int) = &foo;

}

-----------

class Nec {
public:
static int foo(int);
static int baz(int);

};

int bar(int);

int main()
{
int (*fp)(int) = &Nec::foo;

fp = bar;

fp = &Nec::baz;
}

--------------

//non-static olsa idi

class Nec {
public:
int foo(int);
int baz(int);
};

int main()
{
int (*fp)(int) = &Nec::foo; //hata, non static tutamaz static olmalı
}

!! sınıfların static adreslerinin türleri ile sınfların non-static adresleri aynı türden değil
--------------
yeni konu sınıfların non-static üyelerinin adreslerinin tutulması

non static yapıların pointer değişkende tutulması

class Nec {

public:
int foo(int);
int bar(int);
};

int main()
{
auto fp1 = &Nec::foo;
int (Nec::*fp2)(int) = &Nec::foo; //bu şekilde tutuluyor
}

-----------
!! static ve non-static tutan öğeler aynı türden değil

class Nec {
public:
int foo(int, int);
int bar(int, int);

};

int main()
{
auto fp = &Nec::foo; //kolay yönü budur ancak pekiştirme için yapıyoruz

int (Nec::*fp)(int, int) = &Nec::foo; 
}

------------

class Nec {
public:
int foo(int, int);
int bar(int, int);
static int baz(int, int);
};

int main()
{
int (Nec::*fp)(int, int) = &Nec::foo; 
fp = &Nec::bar; //legal
fp = &Nec::baz; //Hata
int (*fptr)(int, int) = &Nec::baz; //legal

}

----------------
//zor kısıma geldik

class Nec {
public:
int foo(int x)
{
std::cout << "Nec::foo(int x) x = " << x << '\n';
return x* x;
}
};

int main()
{
auto fp = &Nec::foo; //'&' kullanmassak örtülü dönüşüm olmaz
int (Nec::*fp)(int) = &Nec::foo; //bu şekilde de olur

Nec mynec;

//mynec.fp(12); //hata nec scopeunda arar

!! eğer elimizde bir sınıf nesnesi var ise (mynec) ve bir üye fonksiyon göstericisi(fp) var ise ayrı bir operatör kullanmamız gerekir (.*)

//bunun doğru yollunu bulmak için .* operarörü kullanılır

mynec.*fp; //bu şekilde olur
mynec.*fp(20) //operatör önceliğinden dolayı hata
(mynec.*fp)(20); //Bu şekilde kullanılır
}

--------------

class Nec {
public:
int foo(int x)
{
std::cout << "Nec::foo(int x) x = " << x << '\n';
std::cout << "this = " << this << '\n';

return x* x;
}
};

int main()
{
int (Nec::*fp)(int) = &Nec::foo;
Nec mynec;
std::cout << "&mynec = " << &mynec << '\n';

(mynec.*fp)(20);
}

----------------
böyle bir funtion pointer ile neler yapılabilir


class Nec {
public:
int foo(int x);
int bar(int x);
int baz(int x);
int func(int x);

};

using necfp = int (Nec::*)(int);

int main()
{
necfp fptr;
Nec mynec;

fptr = &Nec::foo;
fptr = &Nec::bar;
fptr = &Nec::baz;

(mynec.*fptr)(456);
}

----------

class Nec {
public:
int foo(int x);
int bar(int x);
int baz(int x);
int func(int x);

};

using necfp = int (Nec::*)(int);

int main()
{
using namespace std;

vector<necfp> myvec {&Nec::foo, &Nec::bar};

myvec.push_back(&Nec::baz);
myvec.push_back(&Nec::func);

Nec mynec;

for (auto fp : myvec) {
(mynec.*fp)(10);
}
}

------------

class Nec {
public:
int foo(int x);
int bar(int x);
int baz(int x);
int func(int x);

};

using necfp = int (Nec::*)(int);

int main()
{
using namespace std;

necfp ar[] = {&Nec::foo, &Nec::bar, &Nec::baz, &Nec::func };
}

---------------

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

//Hangi üye fonksiyonun çağrılacağınıda fonksiyonu çağıran kodun belirlemesini istiyoruz

void gf(Nec& nec, int (Nec::*fp)(int))
{
(nec.*fp)(21);
}

int main()
{
Nec mynec;

gf(mynec, &Nec::foo);
gf(mynec, &Nec::bar);

}

-----------

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

//Hangi üye fonksiyonun çağrılacağınıda fonksiyonu çağıran kodun belirlemesini istiyoruz

void gf(std::vector<Nec> nvec, int (Nec::*fp)(int))
{
for (auto nec : nvec) {}
auto val = (nec.*fp)(12);
}

int main()
{
Nec mynec;

gf(mynec, &Nec::bar);

}

-------------

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

int main()
{
int (Nec::*fp)(int) = &Nec::bar;

Nec* pnec = new Nec;

((*pnec).*fp)(345);
}

--------------
2. bir operator daha var

->*

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

int main()
{
int (Nec::*fp)(int) = &Nec::bar;

Nec* pnec = new Nec;

//((*pnec).*fp)(345);
(pnec->*fp)(4657);

}

------------------

elimizide sınıf nesnesinin kendisi var ise .*
elimizide sınıf nesnesinin kendisi değil adresi var ise ->*

--------------------

bunların karmaşıklığından kurtulmak için std::invoke vardır

class Nec {
public:
int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}
};

int main()
{
int (Nec:: * fp)(int) = &Nec::bar;

Nec mynec;
Nec* necptr = new Nec;

std::invoke(fp, mynec, 345);
std::invoke(fp, necptr, 345); //pointer içinde kullanılır

// (mynec.*fp)(345) //aynı anlamda
}

------------------

class Nec {
public:

void func()
{
(this->*mfp)(34);
}

int foo(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

int bar(int x);
{
std::cout << "Nec::b(int x) x = " << x << "\n";
return x *x;
}

int baz(int x);
{
std::cout << "Nec::foo(int x) x = " << x << "\n";
return x + 5;
}

private:
int (Nec::*mfp)(int) = &Nec::foo;
};

//////////////////////////////////////////////////// 3. Ders ////////////////////////////////////////////////

//TEKRAR

sınıfların non-static üye fonksiyonlarının adresi, bilfiğimiz fonksyion adresleri gibi değil

class Nec {
public:
void foo(int);

};

int main()
{
auto fp = &Nec::foo;
//void (Nec::*)(int) fp = &Nec::foo; //auto kullanmasaydık bu şekilde olurdu

Nec mynec;
(mynec.*fp)(12); 
// ((*necptr.*fp)(12);   //225. satır bu şekilde de olur

Nec* necptr = &mynec; //nec nesnesi olsa idi
(necptr->0fp)(12); //bu şekilde yapaarız
}

---------

class Nec {
public:
void f1(int);
void f2(int);
void f3(int);
void f4(int);
};

void foo(int, void (Nec::* mfp)(int))
{

}

----------

class Myclass {
public:
Myclass() = default;

int f1(int a)
{
std::cout << "int Myclass::f1(int)\n";
return a + 10;
}

int f2(int a)
{
std::cout << "int Myclass::f2(int)\n";
return a + 20;
}

int f4(int a)
{
std::cout << "int Myclass::f3(int)\n";
return a + 30;
}

int f3(int a)
{
std::cout << "int Myclass::f4(int)\n";
return a + 40;
}
private:
int mval{};

};

// öyle  bir function pointer array oluşturcağız ki dizimizin elemanları
//f1 f2 f3 f4 fonksiyonlarının adrelerini tutucak

using Mfptr = int (Myclass::*)(int);

int main()
{
/*int (Myclass:: *fp[4])(int) = {
&Myclass::f1,
&Myclass::f2,
&Myclass::f3,
&Myclass::f4, };
*/
//bu şekilde de olur

Mfptr fpa[] = {
&Myclass::f1,
&Myclass::f2,
&Myclass::f3,
&Myclass::f4,
};

Myclass m {35};

for (auto fptr : fpa) {
//std::cout << (m.*fptr)(10) << '\n';
cout << std::invoke(fptr, m, 10); //üstteki yerine bu yazılabilir
}
}

--------------
class Myclass {
public:
Myclass() = default;
Myclass(int val) : mval{val}{};

int f1(int a)
{
std::cout << "int Myclass::f1(int)\n";
return a + 10;
}

int f2(int a)
{
std::cout << "int Myclass::f2(int)\n";
return a + 20;
}

int f3(int a)
{
std::cout << "int Myclass::f3(int)\n";
return a + 30;
}

int f4(int a)
{
std::cout << "int Myclass::f4(int)\n";
return a + 40;
}
private:
int mval{};
};

int main()
{
auto fp = &Myclass::f1;
Myclass m(76);
Myclass* mptr(&m);

std::cout << (m.*fp)(20) << '\n';
std::cout << (mptr->fp)(20) << '\n';
std::cout << std::invoke(fp, m, 20) << '\n';
std::cout << std::invoke(fp, mptr, 20) << '\n';

}

--------------------------------------

data member pointer
------------------

programcıların kafalarını karıştıran bir yer

struct Nec {
int a{3};
int b{3};
int c{3};

};

int main()
{
Nec mynec;
&mynec.a //türü int*
}

----------

struct Nec {
int a{3};
int b{3};
int c{3};
};

int main()
{
//ortada bir nesne yok
&Nec::a; //bu şekilde data member pointer denir
//türü int Nec::*
}

----------

struct Nec {
int a{3};
int b{3};
int c{3};
};

int main()
{
auto ptr = &Nec::a;
//int Nec::*ptr = &Nec::a;

Nec mynec;

cout << mynec.*ptr << '\n';

mynec.a = 777;
cout << mynec.*ptr << '\n';

ptr = &Nec::b;
cout << mynec.*ptr << '\n';

mynec.*ptr = 9999; 
cout << mynec.b << '\n';

}

---------------------

//burada da invoke kullanılabilir

struct Nec {
int a{3};
int b{3};
int c{3};
};

int main()
{
auto ptr = &Nec::a;
Nec mynec;

std::invoke(ptr, mynec) = 9999;
std::cout << mynec.a << '\n';
}

-----------------

//mülakatlarda bu yapı karşımıza çıktığı zmana bu örneği ver

//open high low close
//usd try

// 5 dakida
// 9:00 - 9:05
//28.88 open fiyatı
// 28.97 high fiyatı
// 28.65 low fiyatı
// 28.89 close fiyatı

struct OHLC {
double open;
double high;
double low;
double close;

};

double get_moving_avarage(cosnt std::vector<OHLC>& candles, double OHLC::*)
{
//yapılacak işlemin seçilmesi, 

double sum{};

for (const auto& candle : candles) {
sum += candle.*fp;
//sum += std::invoke(fp, candle);
}

auto mean = sum / candles.size(); 
}

int main()
{
std::vector<OHLC> myvec;

auto mean = get_moving_avarage(myvec, &OHLC::low)
mean = get_moving_avarage(myvec, &OHLC::high);
}

===================================================

bitset
-------

#include <bitset>

-boolen olarak kullanılabilecek bitleri temsil eder
-bitset contanier değildir
-begin, end gibi fonksiyonları yoktur
- aslında boolen değerlerden oluşan vektör isteriz
- birbiri ile ilişkili boolen değerlerin bir arada tutulabildiği en ucuz yöntemdir

template <std::size_t n>
class Bitset{

}

-------

int main()
{
using namespace std;

bitset<16> bs1; //16 tane kullanılabilcek bit sağlar
bitset<24> bs2;


}

----------------

arayüzü :
---------

int main()
{
using namespace std;

bitset<16> bx;

cout << bx; // 0 olarak hayata getirir
}

-----------

int main()
{
using namespace std;

bitset<32> bx{ 78234u };

cout << bx; 
}

-------------

int main()
{
using namespace std;

bitset<32> bx{"1010110101011010"};

cout << bx  << '\n'; 
}

----------------

bite referans olmaz

-----------------

//müalaktlarda sorulur

boolen bir değer olarak kullanılabilir ancak kendisi boolen değil bittir

---------------

int main()
{
using namespace std;

bitset<32> bx{"1010110101011010"};

auto b = bx[3];

bx[3] = true;
bx.operator[](3).operator=(true); //yukarıdaki bu anlama gelir
}

------------------
//elimizde bitset var ise aşağıdakiler yazılabilir

int main()
{
using namespace std;

bitset<32> bx{"1010110101011010"};

cout << bx[4] << "\n";

bx[4].flip(); //biti ters çevirir

}

----------------
count : kaç tane bitin 1 olduğunu söyler

int main()
{
using namespace std;

bitset<32> bx{"1010110101011010"};

cout << bx.count() << '\n'; 
}

----------------

int main()
{
using namespace std;

int x;

cout << "bir tam sayi girin: ";
cin>> x;

cout << bitset<32>(x) << "\n";
cout << bitset<32>(x).count()<< "biti 1\n"
}

---------------

int main()
{
using namespace std;

cout << boolalpha;

bitset<32> bs{2'987'451!123u };

cout << "[" << bs << "]\n";
cout << bs.count() << "biti 1\n";

cout << "bs.any() = " << bs.any() << "\n"; //en az 1 bit set edilmişse true döndürür
bs = 0u;
cout << "bs.any() = " << bs.any() << "\n";
}

------------
//any : is any bit set
//none : is none of bit set
//all : eğer tüm bitler 1 ise

int main()
{
using namespace std;

cout << boolalpha;

bitset<32> bs{2'987'451'123u };

cout << "[" << bs << "]\n";
cout << bs.count() << "biti 1\n";

cout << "bs.none() = " << bs.none() << "\n"; // 
bs = 0u;
cout << "bs.any() = " << bs.any() << "\n";
}

-----------

int main()
{
using namespace std;

cout << boolalpha;

bitset<32> bs{0};

bs.flip();

cout << "[" << bs << "]\n";
cout << bs.count() << "biti 1\n";

cout << "bs.all() = " << bs.all() << "\n"; // 
}

----------
//test

//set get fonksiyonları

int main()
{
using namespace std;
cout << boolalpha;

bitset<32> bs{98435453u};
cout << bs << "\n";
size_t idx;

std::cout << "kacinci bit : ";
cin >> idx;

cout << bs.test(idx) << "\n"; //kaçıncı bit 1
}

--------------
//set

int main()
{
using namespace std;
cout << boolalpha;

bitset<32> bs{0};
cout << bs << "\n";

size_t idx;

std::cout << "kacinci bit : ";
cin >> idx;

bs.set(idx); //istenilen biti 1 yapar

cout << bs << "\n";
}

-----------
//reset

int main()
{
using namespace std;
cout << boolalpha;

bitset<32> bs{-1};
cout << bs << "\n";

bs.reset(); //tüm bitleri sıfırlar
bs.reset(5); //5. biti sıfırlar

cout << bs << "\n";

}

------------

//to_ulong

int main()
{
using namespace std;
cout << boolalpha;

bitset<32> bs;

bs[1] = true;
bs[0] = true;
bs[2] = true;
bs[3] = true;

cout << bs << "\n";

cout << bs.to_ulong() << "\n";
}

------------

int main()
{
using namespace std;
cout << boolalpha;

bitset<32> bs(6734328u);

auto str = bs.to_string();

cout << bs << "\n";
std::replace(str.begin(), str.end(), '1', 'A'); // 1 yerine A
std::replace(str.begin(), str.end(), '0', 'B'); // 0 yerine B koyuldu
cout << str << "\n";

}

-----------

int main()
{
using namespace std;

bitset<32>;
bs. //incele
}

----------

int main()
{
using namespace std;

bitset<32> bs;

bs.set(5, false); //bu şekildde de olur

}

-------------

int main()
{
using namespace std;

bitset<32> bs;

bs.set(4).reset(3).flip(7);

cout << bs << "\n";

}

------------

enum Color {
White,
Yellow,
Red, 
Brown,
Magenta,
Black,
NoOfColors,
};

int main()
{
using namespace std;

bitset<NoOfColors> myset;
myset[Magenta] = true;
myset[Red] = true;

}

-------------

bitset ile kritik bir nokta

int main()
{
using namespace std;

bitset<16> x{597u };
bitset<16> y{512u };

cout << boolalpha;

cout << (x == y) << '\n';
cout << (x != y) << '\n';
cout << (x < y) << '\n'; //hata çünkü böyel bir şey yok


}

------------

int main()
{
using namespace std;

vector<bitse<32>> bsvec;
bsvec.reserve(1000);

for (int i = 0; i < 1000; ++i) {
bsvec.emplace_back(i);
}

for (const auto&bs : bsvec) {
std::cout << bs << "\n";
}
}

----------

#include <set>

int main()
{
using namespace std;

set<bitset<32>> bsvec;

for (int i = 0; i < 1000; ++i) {
bsvec.emplace(i);
}
}

-------------
to_ulong : unsigned long tamsayı değerine dönüştürür.

int main()
{
using namespace std;

auto fless = [](const bitset<32>&b1, const bitset<32>& b2) {
return b1.to_ulong() < b2.to_ulong();
};

set<bitset<32>, decltype(fless)> bset;

for (int i = 0; i < 1000; ++i) {
bset.insert(Irand{0, 2'000'000'000}());
}

for (const auto&bs : bset) {
cout << bs << '\n';
}
}

-----------------

bitset bitsel operatörleri overload ediyor

int main()
{
using namespace std;

const bitset<16> x{"01000110001010"};
const bitset<16> y{"10101010101011"};

// x & y

// operator&(x, y)

cout << x << "\n";
cout << x << "\n";

cout << (x & y) << "\n"; //bitsel ve işlemi yapar
cout << (x | y) << "\n";
cout << (x ^ y) << "\n";
}

--------------

int main()
{
using namespace std;

const bitset<16> x{"01000110001010"};
const bitset<16> y{"10101010101011 "};

x.operator&=(y);

x &= y;
x |= y;
x ^= y;

}

-----------
//bitsel kaydırmada overload edilmiştir

//necati hoca mülakatlarda soruyor

int main()
{
using namespace std;

bitset<16> x{ 1u };

cout << (x << 2) << "\n"; //aradaki farka bak
cout << x << 2 << "\n";
operator<<(cout, x.operator<<(2));

}

---------------

int main()
{
using namespace std;

bitset<16> x{ 34151u };

cout << ~x << "\n"; //değişiklik yapmaz

cout << x << "\n";
}

--------------

int main()
{
using namespace std;

string str{ "11111111111" };

bitset<32> bsx{str, 5, 3}; //5 indeksiden başlarayark 3 tane
cout << bsx << "\n";
}

-------------

int main()
{
using namespace std;

bitset<16> bs{"1111111111111"};

bs[5] = true;
bs[5].operator=(true);

if (bs[5]) { //aynı anlamda

}

if (bs[5].operator bool()) { //aynı anlamda

}

if (bs.test(5)) { //aynı anlamda

}

bs[5].operator~();

}

====================================================

Dinamik Ömürlü Nesneler
------------------------

temel bilgileri tekrar

-otomatik storage
-dinamik storage : program çalışırken elde edilir
-static storage
-local storage


dinamik olması isteğimiz zaman hayata getirebiliriz demektir

!! stackde veya otomatik ömürlü nesne oluşturmak iş görüyorsa o şekilde oluştur

---------
birçok olumsuz yanına rağmen dinamik ömürlü nesnelerin kullanıldığı yerler vardır
mesela,
-programın çalışma zamanında nesnenin türünün belli olduğu duurmlarda
-bazı veri yapılarının implementasyonu 
-runtime polymorfizi

-----------------------

new operator/expression ifadeleri ile hayata gelir

delete hayatı biter

new ifadeleri
------------

new T
new T[n]
new(s)T

----------------------


int main()
{
using namespace std;

vector<void*> myvec;

try {
for (int i = 0; i < 10000; ++i) {
myvec.push_back(operator new(1024 * 1024);

}
}
catch (const std::bad_alloc& ex) {
//catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}

cout << "size = " << myvec.size() << "\n";

}


------------------

gloabal operator new ile neler yapabilirim

-overload edebiliriz, global operator new yerine bizim overloadınız çalışıcak

-ismi ile çağırabiliriz

-bir sınıf için overload edebiliriz

----------------

new T

operator new(sizeof(T)) : bellek allocate eder

void operator delete(void *) : elde edilen bellek alanını siler

----------------

//my operator new overload

void* operator new(std::size_t n)
{
std::cout << "operator new(size_t n) called\n";
std::cout << "n = " << n << "\n";

auto vp = std::malloc(n);
if (!vp) {
throw std::bad_alloc{};
}
std::cout << "the address of the allocated block is " << vp << "\n";
return vp;
}

//operatör delete yazılması

void operator delete(void* vp)
{
std::cout << "operator delete called! vp " << vp << "\n";
std::free(vp);
}


class Neco {
public:
Neco()
{
std::cout << "Neco default ctor this: " << this << << "\n";
}

~Neco() //delete edilmediği sürece çağrılmaz
{
std::cout << "Neco default dtor this: " << this << << "\n";
}
unsigned char buffer[2048]{};
};

int main()
{

Neco* p = new Neco;

//...
}

----------------

class Nec {

};

int main()
{
Nec* p = new Nec;
 

void* praw = operator new(sizeof(Nec));

try {
p = new(praw)Nec();
}
catch (...) {
operator delete(praw);
}
}

-----------

operatör new işleminin başarısız olması durumunda 
std::bad_alloc sınıfının türünden bir exeption throw ettiğini söylemişti
ancak bu tam doğru değildir

using new_handler = void (*)(void);

get_new_handler() //global fonksiyon göstericisini değerini get ediyor

set_new_handler() //new_handler türüden fonksiyon adresi ister, o fonksiyon adresi ile global fonksiyon adresini set ediyor

---------
using namespace std;

int main()
{
cout << (get_new_handler() == nullptr) << "\n"
}

-----------

using namespace std;

void my_new_handler()
{

}

int main()
{
set_new_handler(&get_new_handler);
}

--------
peki ne işe yarar

operator new gerçekte kodu aşağıdaki şekilde

void *operator new(size_t n)
{
for (;;) {
void *vp = std::malloc(n);
if (vp) {
return vp;
}
auto fptr = get_new_handler();
if (!fptr) {
throw std::bad_alloc{};
}

fptr();
}
}

---------

eğer set_new_handler ile kendi fonksiyonumuz kayıt ettirmez isek
operator new başarısız olduğunda exception throw edicek 
ama kendi fonksiyonumuz kayıt ettirmiş isek derleyici döngüsel yapıda
derleyici başarısız oldukça sürekli bizim kayıt ettirilmiş fonksiyonuuzu çağıracak

-----------

void myhandler()
{
std::cout << "myhandler called!!!";
(void)getchar();
}

int main()
{
vector<void*> myvec;

try {
for (int i = 0; i < 1000; ++i) {
myvec.push_back(operator new(1024 * 1024));
}
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

//exception throw edicektir

-------------

void myhandler()
{
std::cout << "myhandler called!!!";
(void)getchar();
}

int main()
{
vector<void*> myvec;

set_new_handler(myhandler);
//başarısız olduğu zaman, döngüsel yapı içinde sürekli myhandler çağırıca
try {
for (int i = 0; i < 1000; ++i) {
myvec.push_back(operator new(1024 * 1024));
}
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

----------

operator new başarısız olması durumunda bad alloc throw etmesini istiyorsan bir şey yapmana gerek yok

ama bu mekanizmayı custom etmek istiyorsan
-geri dönüş değeri olmayan
-set_new_handlera bunun adresi ile çağrı yapıcaksın

------------

bu handler neler yapabilir

1. daha önce allocate edilmiş bellek bloğunun geri verilmesi

2. nullptr geçer isek bad_alloc throw eder

3. kendi bad_alloc türünden elde edebilriz

-------------

void myhandler()
{
static int cnt{}

std::cout << "myhandler called!!!";
(void)getchar();
if (++cnt == 10) {
std::cout <<" yeterince calıstım ancak basarili olamadim\n";
set_new_handler(nullptr); 
}
}

int main()
{
vector<void*> myvec;

set_new_handler(myhandler);
//başarısız olduğu zaman, döngüsel yapı içinde sürekli myhandler çağırıca
try {
for (int i = 0; i < 1000; ++i) {
myvec.push_back(operator new(1024 * 1024));
}
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

-------------

void another_handler()
{
static int cnt{}

std::cout << "another_handler called!!!";
(void)getchar();
if (++cnt == 5) {
std::cout <<" yeterince calıstım ancak basarili olamadim\n";
set_new_handler(nullptr); 
}
}

void myhandler()
{
static int cnt{}

std::cout << "myhandler called!!!";
(void)getchar();
if (++count == 10) {
std::cout <<" yeterince calıstım ancak basarili olamadim\n";
set_new_handler(another_handler); 
}
}

int main()
{
vector<void*> myvec;

set_new_handler(myhandler);
//başarısız olduğu zaman, döngüsel yapı içinde sürekli myhandler çağırıca
try {
for (int i = 0; i < 1000; ++i) {
myvec.push_back(operator new(1024 * 1024));
}
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

