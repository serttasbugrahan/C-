//////////////////////////////////////////////////////////1. Ders//////////////////////////////////////////

Aşağıdaki operatörlerin overload edilmesinden devam ediyoruz...

operator[]
dereferencing *
->
function call
type cast

----------------------------
ufak c tekrarı

p[5]
*(p + 5) //yukaridaki ile aynı anlamda

int main()
{
cout << 2["ELMA"] - 1["ELMA"] << "\n"; //1 çıkar
cout << "ELMA"[2] - "ELMA"[1] << "\n"; //yukarıdak ile aynı anlam
}

----------------------------

int main()
{
std::string str{ "koray" };

str[1] = 'a';
str[4] = 'n';

std::cout << str << '\n';
//köşeli parantez operatörü overload edilir
}

------------------

x[y]

x.operator[](y) //derleyici yukarıdaki kodu buna çevirir

----

int main()
{
std::string str{ "koray" };

str[1] = 'a';
str.operator[](1) = 'a'; //derleyici buna çevirir
}

----

a[3] //l value

----
minimal bir array sınıfı yazıyoruz

class String {
//...
public:
String(const char* p) : new char[std::strlen(p) + 1]} //bu kod legal kıldı main altındaki satırı
{
std::strcpy(mp, p);
}
///...

std::size_t lenght()const
{
return std::strlen(mp);
}

friend std::ostream& operator<<(std::ostream& os, const String& s)
{
return os << "'" << s.mp << "'"
}

char& operator[](std::size_t idx)
{
return mp[idx];
}
private:
char* mp;
};

int main()
{
String str("mustafa demirhan");

std::cout << str << '\n';
std::cout << str[1] << "\n";
str[0] = '!'; //buranın legal olabilmesi için 'str[0]' l value olmalı

for (size_t i{}; i < str.lenght(); ++i) {
std::cout << str[i] << ' ';
}
}

-----------------

class String {
//...
public:
String(const char* p) : new char[std::strlen(p) + 1]} //bu kod legal kıldı main altındaki satırı
{
std::strcpy(mp, p);
}
///...

std::size_t lenght()const
{
return std::strlen(mp);
}

friend std::ostream& operator<<(std::ostream& os, const String& s)
{
return os << "'" << s.mp << "'"
}

char& operator[](std::size_t idx)
{
return mp[idx];
}
private:
char* mp;
};

const char& operator[](std::size_t idx)const
{
return mp[idx];  
}

int main()
{
const String str("mustafa demirhan");
auto c = str[4]; //hata, const t* ==> t*, bu durumu aşmak için const overloading yapılır
//auto c = str.operator[](4); //aynı anlamda

str[3] //bu yazılırsa const olmayan
const String s = "Bilal";
str[3] //const olmayan çağrılır, erişim amaçlı kullanılır

//bu durumu aşmak için const overloading yapılır
//nint dosyası içinde cevabı
}

---

class Myclass {
public:
void foo();
};

int main()
{
const Myclass m;
m.foo(); //const t* ==> t*'a dönüşüm yapmaya zorlanır, hata

}

-----
//yukarıdaki overlaodingi string kütüphanesi kullanır
 
#include <string.h>

int main()
{
std::string s{ "Tamer" };

std::cout << s << '\n';
s[0] = 'S'; //bu atamalar legal
s[4] = 't';

std::cout << s << '\n';
}

------

class Myclass {
public:
void operator[](size_t idx)
{
std::cout << "Myclass::operator[](size_t idx) idx = " << idx << '\n';
std::cout << "this = << this << '\n';
}
};

int main()
{
using namespace std;

Myclass m;

cout << "&m = " << &m << '\n';
m[4];
//m.operator[](4);
}

------------------------------------------

iki operatörün overload edilmesi:
---------------------------------

* dereferencing/indirection
. dot operator
-> arrow operator

int main()
{
int ival{ 764 };
int* p{ &ival };

}

------

// func işlevinin parametre değişkenin türü int&&
//219. satirdaki x ifadesinin türü int
//bir ifadenin türü referans türü olmaz

void func(int&& x) //x'in türü int &&
{
x //x'in türü int
}

------

Mülakat sorusu

void bar(int&)
{
std::cout << "1";
}

void bar(int&&)
{
std::cout << "2";
}

void foo(int && x)
{
bar(x); //function overloading var

}

int main()
{
foo(5); //1 çağrılır
}

---------

konuya geri dönüyoruz...

class Myclass {
public:
int &operator*()
{
std::cout << "operartor* this = " << this << "\n";
return g;
}
};

int main()
{
Myclass m;

cout << "&m = " << &m << '\n';

*m = 99; //g nesnesine atama olur
//m.operator*() = 99; //aynı anlamda
cout << "g = " << g << '\n';
}

---------------------

ok operatörünün overload edilmesi

p->x

!! ok operatörü binary bir operatör olmasına rağmen unary operator gibi
overload edilir yani fonksiyonun parametre değişkeni olmaz

!! global operator fonksiyonu olarak overload edilemez

------

class Nec {};

class SmartPtr {

public:
Nec* operator->(); //paramtere değişkeni yazarsak sentax hatası olur
};

-----

p bir sınıf nesnesi olsun bu sınıf için ok operatörü 
overload edilmiş olsun derleyici

p->x gibi bir ifade için nasıl bir kod üretiyor?

p.operator->()->x //bu şekilde yapıyor

bunun geçerli olabilmesi için ok operatör fonksiyonun geri dönüş değeri pointer olmalıdır

class Myclass {
public:
void foo();
void bar(int);
};

int main()
{
Myclass* p = new Myclass;
p->foo();
p->bar(12);
}
------

class Myclass {
public:
void foo();
void bar(int);
};

class PointerLike {
public:
PointerLike(Myclass*);
//Myclass& operator->(); //içerik operatörü overload edilir
Myclass* operator->(); //bu kod ile lagal olur
};

int main()
{
PointerLike p = new Myclass; //bu kodu legal yapma

*p

p->foo();
p->operator->()->foo(); //buna dönüşür
p->bar(12);
p->operator->()->bar(); //buna dönüşür
}


///////////////////////////////////////////2. Ders//////////////////////////////////////

Geçen dersin son bölümünün tekrarı
----------------------------------

derleyici bir sınıf nesnesi ok operatörünün operandı olduğunda
ok operatörünün operandı olan sınıf nesnesi ifadesini o sınıf nesnesini *this olarak kullanıp
sınıfın ok operatör fonksiyonuna çsğrıya dönüştüryor ama fonksiyon çağrı ifadesi yine okun sol operandı uapıyor


class Myclass {
public:
void foo() 
{
std::cout << "Myclass::foo()\n";
}
void bar(int)
{
std::cout << "Myclass::bar(int)\n";
}
};

int  main()
{
Myclass m;
Myclass* p{ &m };

p-> foo(); //normalde bu şekilde çağrılabilinir
p-> bar(12);
}

-------

class Myclass {
public:
void foo() 
{
std::cout << "Myclass::foo()\n";
}
void bar(int)
{
std::cout << "Myclass::bar(int)\n";
}
};

class MyPtr {
public:
Myclass *operator->()

};

int  main()
{
Myclass m;
Myptr p;

p-> foo(); //legal olur yine
p.operator->()->foo(); //derleyici bu şekilde yazar
p-> bar(12);
p.operator->()->bar(12);
}

-----------

class Myclass {
public:
void foo() 
{
std::cout << "this = " << this << '\n';
std::cout << "Myclass::foo()\n";
}
void bar(int)
{
std::cout << "Myclass::bar(int)\n";
}
};

Myclass g;

class MyPtr {
public:
Myclass *operator->()
{
return &g;
}
};

int  main()
{
using namespace std;
cout << "&g = " << &g << '\n';

Myptr p;

p-> foo(); 
p-> bar(12);
}

-------------------------------
//öyle bir sınıf olucakki bu sınıfın varlık nedeni bu sınıf türünden nesnelerin dinamik ömürlü
date nesnelerinin hayatını kontrol etme olucak

//datePtr görevi dinamik ömürlü nesnenin hayatını kontrol etmek

class Date {
public:
Date() = default;
Date(int d, int m, int y) : md{d}, mm{m}, mm{y} //ctor
{
std::cout << *this << "adresindeki " << this << "adresindeki nesneye hayata geliyor\n";
}

~Date()
{
std::cout << *this << "adresindeki " << this << "adresindeki nesneye hayata veda ediyor\n";
}

friend std::ostream& operatpr<<(std::ostream& os, const Date& dt);
{
return os << "(" <<dt.md << "-" << dt.mm << "-" << dt.my << ")"
}

int get_month_day()const
{
return md;
}

int get_month()const
{
return mm;
}

void set_year(int y)
{
my = y;
}

void set_month()
{
mm = m;
}
private:
int md{1},mm{1},my{1980};
};

//bir datePtr nesnesi new ifadesi ile oluşturulmuş
//dinamik ömürlü bir date nesnesini  gösterir (sözde)
//ancak DatePtr nesnesinin hayatı bittiğinde gösterdiği Date nesnesini dekete eder
//bunlara smartpointer denir 

class DatePtr {
public:
DatePtr() = default;
explicit DatePtr(Date* p) : mp{p} {}
~DatePtr()
{
if (mp)
delete mp;
}


DatePtr(const DatePtr&) = delete;
DatePtr& operator=(const DatePtr&) = delete;

Date& operator*()
{
return *mp;
}

Date* operator->()
{
return mp;
}
private:
Date* mp{ nullptr };
};


int main()
{
using namespace std;

std::cout << "main basladi\n";
if (true) {
DatePtr p{ new Date{3, 5 , 1987}}; //smartpointer sayesinde delete ifadesi ile sonlandırmayız, buranın legal olması için DatePtr sınıfına parametresi Date* türünden olan ctor vermemiz lazım
cout << *p << "\n"; //burası için içerik operatörünü overload etmemiz gerekiyor
cout << "ay = " << p->get_month() << '\n';
cout << "ayin gunu = " << p->get_month_day() << '\n';
p->set_year(2022);
cout << *p << "\n";
}
std::cout << "main devam ediyor\n";
}

-----------------------
!!cpp'de 2 çeşit kod vardır:
1 normal kod 
2 meta kod (template) derleyiciye yazdırılan 
------------------------

class Date {
public:
Date() = default;
Date(int d, int m, int y) : md{d}, mm{m}, mm{y} //ctor
{
std::cout << *this << "adresindeki " << this << "adresindeki nesneye hayata geliyor\n";
}

~Date()
{
std::cout << *this << "adresindeki " << this << "adresindeki nesneye hayata veda ediyor\n";
}

friend std::ostream& operatpr<<(std::ostream& os, const Date& dt);
{
return os << "(" <<dt.md << "-" << dt.mm << "-" << dt.my << ")"
}

int get_month_day()const
{
return md;
}

int get_month()const
{
return mm;
}

void set_year(int y)
{
my = y;
}

void set_month()
{
mm = m;
}
private:
int md{1},mm{1},my{1980};
};

template <typename T>
class SmartPtr {
public:
SmartPtr() = default;
explicit SmartPtr(T* p) : mp{p} {}
~SmartPtr()
{
if (mp)
delete mp;
}


SmartPtr(const SmartPtr&) = delete;
SmartPtr& operator=(const SmartPtr&) = delete;

T& operator*()
{
return *mp;
}

Date* operator->()
{
return mp;
}
private:
T* mp{ nullptr };
};


int main()
{
using namespace std;
std::cout << "main basladi\n";
if (true) {
SmartPtr<Date> p{ new Date{3, 5 , 1987}}; //smartpointer sayesinde delete ifadesi ile sonlandırmayız, buranın legal olması için DatePtr sınıfına parametresi Date* türünden olan ctor vermemiz lazım
cout << *p << "\n"; //burası için içerik operatörünü overload etmemiz gerekiyor
cout << "ay = " << p->get_month() << '\n';
cout << "ayin gunu = " << p->get_month_day() << '\n';
p->set_year(2022);
cout << *p << "\n";
}
std::cout << "main devam ediyor\n";
}

-------

specialization 

--------

class A {
void foo();
};

struct B {
A* operator->();
};

struct C {
B operator->
};

struct D {
C operator->()
};

int main()
{
D dx;
dx->foo(); //legal
//dx.operator->().operator->().operator->()->foo();
}

-------------------------------------------------

fonksiyon çağrı operatörü:
--------------------------
!! operator overloadingin en öenmli konularından birisi

func(23)
fptr(12)

foo(3, 5)
bir fonksiyon aşağıdaki durumlardan biri olabilir

a) bir fonksiyon ismi (function designator)
b) bir fonksiyon pointer
c) function-like macro

callable
 -function object
 -closure object

---------

Nec foo;
foo(3, 5)
foo.operator()(3, 5)

kuralları:
---------
- fonksiyonun ismi operator() çağrı ismi olmak zorunda
- üye fonksiyon olmak zorunda(diğer üye fonksiyonları : atama, ok operatörü, köşeli parantex)
- varsayılan arguman alabilir.
- ismiyle çağrılabilir
- overload edilebilir

class Myclass {
public:
void operator()()const; //const olabilir
{
std::cout << "Myclass::operator()() this : " << this << '\n';
}
};

int main()
{
Myclass m;
std::cout << "&m = " << &m << '\n';
m(); //nesne ismi
m.operator()(); //bu şekilde 2 parantez olmalı
}


-----------

class Myclass {
public:
void operator()(int x = 5);

};

int main()
{
m();
m.operator()(5); //derleyici buna çevirir
m(12);
m.operator()(12); //derleyici buna çevirir
}

-------------

class Myclass {
public:
void operator()(int);
void operator()(int, int);
void operator()(double);
void operator()(const char *);
};

int main()
{
Myclass m;

m(5); //6
m(5, 7); //7
m(2.3); //8
m("m"); //9
}

----------------

normal bir fonksiyondan farkı

normal fonksiyonların doğrudan bir state bilgisi yok 

// bu işlemler generic programlamada işe yarıycak

class Random {
public:
Random(int low, int high) : mlow{low}, mhigh{high} {}
int operator()()
{
return std::rand() % (mhigh - mlow + 1) + mlow;
}
private:
int mlow, mhigh;
};


int main()
{
Random rand1{ 45, 72 };
Random rand1{ 5678, 5792 };

for (int i = 0; i < 10; ++i)
std::cout << rand1() << ' ';

std::cout << "\n\n";

for (int i = 0; i < 10; ++i)
std::cout << rand1() << ' ';
}
}

--------------
//kodu anlamaya çalışma

int main()
{
using namespace std;

vectır vec{2, 5,7,4,323,2,5,23,12,67};

int n;

std::cout << "kaca bolunenler sayılsın: ";
std::cin >> n;

cout << count_if(vec.begin(), vec.end(), [n](int x) {return x % n == 0});
}

--------------------------------------------------

tür dönüştürme operatörlerinin overload edilmesi:
-------------------------------------------------

sınıf türünden bir üye başka bir türe dönüşebilecek (class --> int/double vb.)

----------

class Nec {


};

int main()
{
Nec mynec;
int ival{ 0 };
ival = mynec; //legal değil
}

-----------

class Nec {
public:
operator int()const; // !! geri dönüş değeri yazılmaz
};

int main()
{
Nec mynec;
int ival{ 0 };
ival = mynec; //legal oldu
// ival = mynec.operator int(); derleyici bu şekilde anlar
}

----------

kurallar

class Erg {

};
   
class Nec {
public:
operator Erg(); //erg türüne, int türüne, double türüne, int* int& vs. hepsine dönüştürebiliriz
};

int main()
{
Nec munec;
Erg myerg;

myerg = mynec;
}

---------

kritik nokta: çok önemli de olsa büyük bir risk içerir
örtülü dönüşümü tetikler

dönüşüm 2 türlü olur
 -standart dönüşüm
 -user defined dönüşüm

class Nec {
public:
operator int()const;
};

int main()
{
double dval{};
Nec mynec;
dval = mynec; //geçerli çünkü standart dönüşüm olur 
}


--------------

class Nec {
public:
operator int* ()const; 
};

int main()
{
Nec mynec;
bool b = mynec;
}

------------

class Nec {
public:
explicit operator int* ()const; 
};

int main()
{
Nec mynec;
bool b = mynec;

ival = mynec; //derleyici örtülü dönüşüm yapamaz explicitden dolayı
ival = static_cast<int>(mynec); //geçerli
ival =(int)mynec; //geçerli
ival = int(mynec); //geçerli
}

!! tür dönüştürme operatörünü explicit yapmaya çalış genelde

-----------

class Counter {

public:
Counter() = default;
Counter(int val) : mc{val} {}

Counter& operator++()
{
++mc;
return *this;
}

Counter operator++(int)
{
Counter temp(*this);
++*this;
return temp;
}

operator int()const
{
return mc;
}
private:
int mc{};
};

void bar(int)
{

}

int foo()
{
Counter c{ 6786 };
return c;
}

int main()
{
Counter c{ 4 };
for (int i = 0; i < 10; ++i) {
++c;
}
int ival = c;

bar(c);
}

---------------

2.7







