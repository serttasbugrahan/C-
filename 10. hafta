//////////////////////////////////////////////////////////////////////////1. Ders//////////////////////////////////////////////////////7

RTTI:
-----

polimorfik bir tür söz konusu olduğunda onun gerçek türü ve davranışı çalışma zamanında belli olur

çalışma zamanındaki type başka derleyicinin koda bakarak bulduğu type başka öğle durumlar var ki normalde başvurmıycağımız bir yöntem olsa da
programın çalışma zamanında bir nesnenin dinamik türünün ne olduğun tespit etmemiz söz konusudur
cpp bunlar için araç sağlar

-dynamic_cast
-typeid
  type_info


upcasting : türemiş sınıftan taban sınıfa 
donw-casting : taban sınıftan türemişe (programın çalışma zamanıyla ilgilidir)

--------------

dynamic cast iki farklı şekilde kullanılabiliyor :

dynamic cast down-casting'in güvenli bir şekilde yapılıp yapılamıycağını sınıyor

dynamic_cast<Mercedes *>(car_ptr) //türü Mercedes *
dynamic_cast<Mercedes &>(car_ref) //türü Mercedes &

Mercedes *p = dynamic_cast<Mercedes *>(car_ptr);


-----------

class Base {

};

class Der : public Base {

};

void foo(Base* baseptr);

int main()
{
Der* derptr = dynamic_cast<Der*>(baseptr); //hata, bir sınıfın polimorfik olması için en az bir virtual fonksiyona saship olmalı
//dynamic_cast geçerli olması için sınıfın polimorfiik olması gerekir

}

int main()
{

}

-----------

class Base {
public:
virtual ~Base() = default;

};

class Der : public Base {

};

void foo(Base* baseptr);

int main()
{
Der* derptr = dynamic_cast<Der*>(baseptr);
}

----------------------
//dynamic cast örneği (chatgbt)

class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    void DerivedMethod() {}
};

int main() {
    Base* basePtr = new Derived;
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);

    if (derivedPtr) {
        // dynamic_cast başarılı oldu, güvenli bir şekilde tür dönüşümü yapıldı
        derivedPtr->DerivedMethod();
    } else {
        // dynamic_cast başarısız oldu, tür dönüşümü güvenli değil
    }

    delete basePtr;
    return 0;
}

----------------------
bu kısım car_4.h içinde

-----------------------

!! dynamic cast operatörünün kullanımında 
hedef tür referans türü ise
down-casting güvenli bir şekilde yapılamıyor ise 
standart kütüphanemiizn

std::bad_cast sınıfı türünden 
std::bad_cast sınıfı
  std::expection
sınıfından kalıtım yoluyla elde edilmiştir
expection throw edilir

-------------------------------------------

typeid: 
-------
typeid kullanıcak isek type_info include etmemiz gerekir, #include<typeinfo>

typeid(*ptr)
typeid(id)
typeid(10)
typeid(++x)

typeid(int)
typeid(Tesla)

typeid nesnelerinin hepsi sınıf türürnden const bir nesneye referans

-----------------
typeid kodu(chatgbt)
#include <iostream>
#include <typeinfo>

class MyClass {
};

int main() {
    MyClass obj;
    const std::type_info& typeInfo = typeid(obj);

    std::cout << "Type of obj: " << typeInfo.name() << std::endl;

    if (typeInfo == typeid(MyClass)) {
        std::cout << "obj is of type MyClass" << std::endl;
    }

    return 0;
}
----------------
#include<type_info>

int main()
{
std::type_info x; //hata verir çünkü default ctor yok
//kopyası çıkarılamaz ya da default init yapılarak type_info nesnesini oluşturabiliriz
}

------

int main()
{
int x = 10;
auto y = typeid(x); //copy ctor delete edildi
}

her ayrı (distinc) tür için bir type_info nesnesi var

int main()
{
int x = 10;
}

----------

int main()
{
int a[10]{};

auto sz = sizeof(a[30)]; //normalde ub ancak işlem kodu üretilmediği için ub değil
}

----------

!! typeid için işlem kodu üretilmez

int main()
{
int x = 12;

const auto& r = typeid(++x);
std::cout << "x = " << x << '\n';
}

------------

class Nec {

};

int main()
{
Nec mynec;

typeid(mynec); //legal, polymorfic bir tür olması gerekmez
typeid(Nec); //static olabilir legal
}

-----------------------------

type info sınıfını inceliyoruz...


class Nec {

};

int main()
{
Nec mynec;

std::cout << typeid(mynec).name(); //yazı adresi döndürür, ancak standart değildir, farklı yazılar çıkabilir yani

}

-----------

class Nec {

};

int main()
{
Nec mynec;
int ival{};

typeid(mynec).operator==(typeid(int))
}

-----

class Nec {

};

int main()
{
using namespace std;

int x = 10;
doyble dval = 5.78;
cout<<
(typeid(x) == typeid(int)) << "\n";
}

------

class Base {
//public:virtual ~Base(){};
};

class Der : public Base {

};

int main()
{
Der myder;
Base* ptr = &myder;

std::cout << (typeid(*ptr) == typeid(Der)) << "\n";
//type id ifadenin türü polimorfik olan ifadeye göre değişir
//polimorfic değil ise static türü esas alır
//polimorfic ise dinamik türü esas alır
}

-------

class Base {
public:
virtual ~Base(){}; //burası olursa dinamik türü esas alır 
};

class Der : public Base {

};

int main()
{
Der myder;
Base* ptr = &myder;

std::cout << typeid(*ptr).name << "\n";
}

-----------------
car_5.h içinde
-----------------
mülakatlarda soruluyor...

/// class A class B

a ve b aynı hiyerarşi içierisinde mi onu sorgulaman gerekiyor nasıl yaparsın ?
-static cast ile

class Base {

};

class Der : public Base {

};

class Nec {

};

int main()
{
Nec mynec;
Der *derptr = static_cast<Der *>(&mynec); //illegal olur 

Base mybase;
Der* derptr = static_cast<Der*>(&mybase); //legal
}


---------------

typeid(*ptr)

polimorfik tür söz konusu olduğunda eğer typeid operatörünün operandı olan ifade  
dereference edilmiş pointer ifadesi ise pointer değerinin nullptr olması durumunda 

std::bad_typeid

sınıfı türünden exception throw edilir.

------------------------------------------------------

//herb sutter

taban sınıfların dtor'ları ya public virtual ya da
protected non-virtual olmalı

NVI (non-virtual interface)

------------
!! template method :taban sınıf türemiş sınıfa customization point vermek istiyorsa virtual function yapıyor
//oop patentlerinden biridir cp ile alakası yok

class Base {

virtual void attack();
public:
void fight()
{
attact(); //buna template method denir
}
};

======================================================================

std::string:
------------

c de yazılar char dizilerde tutulur c++ yazıları bir sınıf türünden nesne oluşturarak kullanıyoruz

---
#include <cstring> //c deki strcmp, strcpy tarzı fonksiyonları çağırmak için kukkanır 
---

#include <string> 

string STL'in başlık dosyalarından biridir
STL ==> stnadart Template library

----------

namespace Std olmasaydı sınıfı aşağıdaki şekilde implemente ederdik

int main()
{
std::basic_string<char, std::char_traits<char>, std::allocator<char>>
}

--------

//generic programlama ile alakası vardır, generic programlama olmasaydı
bütün sınıf fonksitonları çağırılacaktı

int main()
{
using  namespace std;

string str("Buğrahan serttas");

cout << str;
}

----------
STL has 4 components:
-Algorithms
-Containers
-Functors
-Iterators

-Bu bir sınıf şablonu (class template)
-container'dır

sequence containers:
vector
deque
list
forward_list
string
array

associative contaniners:
set
multiset
map
multimap

unordered associative containers:
unordered_set
unordered_multiset
unordered_map
unordered_multimap

------

std::string bir stl contanier'i
  sequence container

data structere
  dynamic_array

-------

/////////////////////////////////////////2. Ders///////////////////////////

String devam...
---------------

aslında bir sınıf şablonudur, basic string isimlli sınıf şablonundan bir açılımından bahsediyoruz aslında

!! reallocation' a diikat etmemiz gerekir mümkün olduğunca kaçınmamız lazım


-------------------

bir sınıfla ilgili ilk sorulması gerekenler şunlar:
1-sınıfın genel farlık nedeni ne
2-bu sınıf kalıtım ile mi kullanılacak yoksa bir ilgisi yok mu
3-sınıf polimorfic mi değil mi
4-sınıf generic mi değil mi, yani sınıf şablonu olarak mı oluşturulmuş yok non-temlate'mi
5-sınıfın bize verdiği hizmetler
6-operator overloafing var mı funciton overloading var mı, fonksiyonların beklediği invariantlar var mı?

-------------------

operator overloading'den çok fazla faydalanır, bunlar:

<<
>>
[ ]
+
+=
<=> spaceship
"mehmet"s
"mehmet"sv

--------------------

sınıf fazla fonksiyon vardır templateler sayesinde sadece çağırdımız fonksiyonun kodu eklenir

---------------------
generic: türden bağımsız demek
---------------------

containers (kaplar)
algorithms (algoritmalar)
  veri yapıları üstünde koşturulacak algoritma
  <algorithm>
  <numeric>
iterators (iterators)
Functors
---------------------

kodu anlamaya çalışma

int main()
{
using namespace std;
string name{ "emrecan suster" };

reverse(name.begin(), name.end()); //burada çağırılan global bir fonksiyon

}

-------------------

mülakatlarda algoritma sorularından en çok 
yazılar üstünde gelir

---------------------

string sınıfının hem üye fonksiyonları var hemde yazı işleri bazı işleri üye fonksiyonlarına
bazı yazı işlerini global algoritma dediğimiz fonksiyonlara yaptırıyoruz

----------------------

int main()
{
std::string::size_type //ideali bu türü kullanmaktır

}

------------------------
!! diğer sınıflarında (vector...) size_type'ı vardır

hangi veriler std::string::size_type türündendir

1- size değeri / lenght / yazı uzunluğu
2- kapasite türü
3- bazı stirng fonksiyonları bir ya da iki parametresine indeks değeri istiyolar
4- string::size_type npos

-----------------------

en zor kısımlardan biri

bazı parametrik yapılar var bunları iyi öğrenirsek çok daha iyi kavrarız

--------
!!BURASI ÇOK ÖNEMLİ

bazı fonksiyonların parametresi:
-const string&  ==> stringin tutuğu ifadenin tamamı üzerinde (whole string) 
-const string&, size_type idx ==> stringin idx paramteresinde başlarayak sonuna kadar demek (substring)
-const string&, size_type idx, size_type len ==> idx'den başlarayak len uzunluğunda işlem yapıcak (substring)
-const char* ==> null karakter ile sonlanan bir adres vermek zorundayız (cstring)
-const char*, size_type len ==> bu adresten başlarak len tane karakter (data parametre)
-char ==> sadece 1 tane karakter üzerinde işlem yapıca(
-size_type, char c ==> n tane c karakteri (fill)
-iterator beg, iterator end ==> (range parametre)
-std::initializer_list<char> {'B', 'A', 'B', 'A'}

------------

initializer_list: bir dizi oluştur ve başladığı ve bittiği yerin adresini tutan elemanlara sahip bir  sınıf nesnesi haline getiriyor 
böylece bir fonksiyona aşğıdaki şekilde geçtiğimiz aman uzunluğunu da geçmiş oluruz

int main()
{
std::initializer_list<int> x{1, 3, 5, 7, 9};

/*
const int ar[] = {1, 3, 5, 7, 9};
class initializer_list {
const int *ps;
const int *pw;
}
*/

}

-------

#include <initializer_list>

void foo(std::initializer_list<int> p)
{
std::cout << "&p = " << &p << '\n';
std::cout << p.begin() << "\n";
std::cout << p.end() << "\n";
}

int main()
{
std::initializer_list<int> x{1, 3, 5, 7, 9};
x.end(); //dizinin bittiği yerin adresini döndürür

std::cout << "&x = " << &x << '\n';
std::cout << x.begin() << "\n";
std::cout << x.end() << "\n";

foo(x); //adresleri farklı olur ancak begin ve end adresleri ayn olur
}

---------------

int main()
{
auto x = {1, 3, 5, 7}; //init. list
auto y{1, 3, 5, 7}; //hata
auto x{ 1 }; //legal, int x, init değil
auto t = {2, 5, 7. }; //hata olur aynı türden olması gerekir, c++ 14 ile geldi
 
}

-----------------------------------

mülakatlardaki en klasik sorulardan birisi

class Myclass {
public:
Myclass(std::initializer_list<int>)
{
std::cout << "Myclass(initializer_list)\n";
}

Myclass(int)
{
std::cout << "Myclass(int)\n";
}

Myclass(int, int)
{
std::cout << "Myclass(int, int)\n";
}
};

int main()
{
Myclass m1{3, 6, 8, 1};
Myclass m2 = {3, 6, 8, 1};

Myclass m1(10, 20); //int int çağrıır
Myclass m1{10, 20}; //init_list çağrılır 

}

---------------------
bu soru mülakkatta gelicek

#include <vector>
#include <initializer_list>

int main()
{
std::cout<int> vec1(100); //100 tane sıfır değeri ile başlatıcak
std::cout<int> vec2{100}; //init list 1 tane 100 değeri ile başlıycak 

std::cout << "vec1.size() = " << vec1.size() << '\n';
std::cout << "vec2.size() = " << vec2.size() << '\n';

}

--------------------

int main()
{
using namespace std;

string s1(50, 'A');
std::cout << s1 << '\n';
string s2{50, 'A'}; //init listten dolay
std::cout << s2 << '\n';
}


--------------------------------------

string sınıfın üye fonksiyonları :

1)

void ps(const std::string& s)
{
std::cout << "|" << s << "|\n";
}

int main()
{
using namespace std;

string s1; //default ctor
ps(s1);

cout << "s1.size() = " << s1.size() << '\n';
cout << "s1.length() = " << s1.length() << '\n';

}

----

  void ps(const std::string& s)
  {
  std::cout << "|" << s << "|\n";
  }
  
  int main()
  {
  using namespace std;
  
  string s1;
  ps(s1);
  
  s1.empty(); //predicate'dir bool döndüren fonksiyonlara denir
  
  //cout << boolalpha; //bu şekilde yazarız true veya false istersek değeri
  cout << s1.empty() << "\n"; //0, 1 diye yazar
  //çok fazla yerde kullanılır empty
  //s1.size == 0 ile aynı anlamdadır
  }

-------------
2)

void ps(const std::string& s)
{
std::cout << "|" << s << "|\n";
}

int main()
{
using namespace std;
string str("ahmet eraslan");
ps(str);
cout << "str.size() = " << str.size() <<"\n"; 
}

------

void ps(const std::string& s)
{
std::cout << "|" << s << "|\n";
}

  int main()
  {
  using namespace std;
  
  char ar[] = { 'A', 'B', 'C'};
  char ar[] = "murathan";
  string str(ar + 5); //ub
  //string str(ar + 3, 2);
  //string str(ar, 20); //ub
  char arr[] = "murat";
  string strrarr, 6); //hata yok
  cout << "str.lenght() = " << strr.lenght() << '\n'; 
  
  ps(str);
  }

-------

void ps(const std::string& s)
{
std::cout << "|" << s << "|\n";
}

int main()
{
using namespace std;
size_t n;

cout << "kac tane: ";
cin >> n;
cout << string(n, '*');

}

--------

void ps(const std::string& s)
{
std::cout << "|" << s << "|\n";
}

int main()
{
using namespace std;

string str(20, '\0';
cout << "str.size() = " << str.size() << '\n'
}

---------

void ps(const std::string& s)
{
std::cout << "|" << s << "|\n";
}

int main()
{
using namespace std;

string s1(100, 'A');
string s2(s1); //copy
string s3(std::move(s1)); //move
 }

-----------

int main()
{
//char parametreli ctor yoktur

using namespace std;

std::string str('A'); //hata
//eğer tek bir karakterden oluşan yazı tutmasını istiyorsak

string s1("a"); //1
string s2(1, "A"); //2
string s3{'A'}; //3

cout << "s1.size() = " << s1.size() << '\n';
cout << "s2.size() = " << s2.size() << '\n';
cout << "s3.size() = " << s3.size() << '\n';

}

----------------

int main()
{
using namespace std;

string s1{ "cengizhan" };
string s2(s1, 3); 
cout << "s2 = " << s2 << '\n';
string s2(s1, 1,4); 
cout << "s2 = " << s2 << '\n';
string s2(s1, 3,50); 
cout << "s2 = " << s2 << '\n'; //hata yok
}

----------------

int main()
{
using namespace std;

string s1{50, 'A'};
string s2{66, 65, 66, 65};

cout << "s2 = " << s2 << '\n';
}

-----------------
son ctor olan range ctor

int main()
{
using namespace std;
char str[] = {"gokhan girgin"};

string s1{str}; //cstr
string s1{str, 3}; //array
string s1{str, str + 4}; //range

cout << "s1 = " << s1 << '\n';
cout << "s2 = " << s2 << '\n';
cout << "s3 = " << s3 << '\n';

} 

//ctor bitti
--------------------------------------

size_type capacity()const;

int main()
{
using namespace std;

string str(153, 'A');

cout << "str.size() = " << str.size() << '\n';
cout << "str.capacity() = " << str.capacity() << '\n';

str += "gokhan";
cout << "str.capacity() = " << str.capacity() << '\n';

str.push_back('.');

str += "gokhan";
cout << "str.capacity() = " << str.capacity() << '\n';
}



!! kapasite stirng sınıfınfa ve vector sınıfında kapasitenin artış katsayısı
derleyiciye bağlıdır


------

int main()
{
    using namespace std;

    string str(40, 'A');
    int cnt{};

    // her reallocation olduğunda bu bilgileri yazıdırı
    while (str.size() < 500'000)
    {
        str.push_back('A');
        if (str.capacity() > cnt)
        {
            cout << ++cnt << ". reallocation\n";
            cout << "size = " << str.size() << '\n ';
            cout << "capacity = " << str.capacity() << '\n';
            cnt = str.capacity();
            (void)getchar();
        }
    }
}

---------------

yapılan en büyük hatalardan birisi gereksiz yere reallocationa sebep olmak

int main()
{
using namespace std;

string str;
char c = 'S';
for (int i = 0; i < 1000; ++i) {
str.push_back(c); //gereksiz reallocation çağrılır bunun yerine reserve fonksiyonunu kullanmak gerekir
}
}

--------------
reserve fonksyionu:

int main()
{
using namespace std;

string str(40, 'A');
str.reserve(600'000); //size arrtırmaz kapasite arttırır
auto cap = str.capacity();
int cnt{};

while (str.size() < 500'000) {
str.push_bacj('A');
if (str.capacity() > cap) {
cout << ++cnt << ". reallocation\n";
cout << "size = " <<str.size() << \n";
cout << "capacity = " <<str.capacity() << \n";
cap = str.capacity();
(void)getchar();
}
}
}

------

int main()
{
using namespace std;

string str(40, 'A');

str.reserve(600'000);
auto cap = str.capacity();
cout << "size = " << str.size() << '\n';
cout << "capacity = " << str.capacity() << '\n';

}

-------------------------

mülakkatta mutlaka sorulur

string yazıları her zman heap(free store)'de tutulmaz
derleyiciler SSO (smalls ignal opt.) yapabilir
SSO : uzunluğu küçük olan string nesnelerin string nesnesi içinde oluştutulması


int main()
{
using namespace std;

string str(40, 'A');
}

//////////////////////////////////////////////////////3. Ders////////////////////////////////////////////









