///////////////////////////////////////////////// 1. Ders //////////////////////////////////////////////

forward_list : tekli bağlı liste sınıfı

çifte bağlı listede silinecek öğenin konumunu verirsek o öğeyi destroy etmenin problemi yoktur

tekli bağlı liste : bir düğümü udate etmek istiyorsak bir  önceki düğümdeki pointerı update etmemiz gerekir ancak tekli bağlı listede bu mümkün değildir

bu sıkıntıyı aşmak için tekli bağlı sınıf before begin fonksiyonu bize verir

before begin bize iterator verir ancak o iteratörde bir nesne yoktur

!! back() ,size() ,push_back() fonksiyonu yoktur
!! push_front(), front() vardır

---------------

tekli bağlı liste sınıfı => forward list,
çifte bağlı liste => list

---------------
//mülakatlarda sorulabilir

her öğeden bir tane bırakmak istiyorsak sort + unique yapılabilir

---------------
#include <forward_list>

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});

mylist.push_front(123); //başa ekler
mylist.push_front(999); //başa ekler

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
mlist.pop_front(); //baştan 1 öğe siler

}

--------------
//bu kodları (nutility kullanmadığı) kendin yazmaya çalış

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

auto iter = next(mylist.begin(), 3); //8'in konumunu verdik ancak 1 sonraki konumu tuttu
cout << *iter << "\n";
mylist.insert_after(iter, 7777);

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}

-----------

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

auto iter = next(mylist.begin(), 3); //8'in konumunu verdik ancak 1 sonraki konumu tuttu
cout << *iter << "\n";
mylist.insert_after(iter, {-7, -8, -9});

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}

-----------

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

mylist.insert_after(mylist.before_begin(), {-7, -8 , -9 });

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}


------------

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

mylist.erase_after(mylist.before_begin(), next(mylist.begin(), 3)); //ilk 3 öğe silinir

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}

------------

//mülakatlarda çok çıkan bir sorudur, aranan değeri bulma

//kendin kodunu yaz

//1. yol- 2 iterator kullanarak çözümü
//2. yol- aranan değeri next'e bakarak bulabiliriz

int main()
{
using namespace std;

forward_list mylist{3,6,1,5,9,2,8,13,21 }; //template argümanının bildirmemize rağmen sitacdan dolayı hata vermez (c++17)


int ival;

std::cout << "silinecek degeri girin: ";

cin >> ival;

//
}

==============================================================

contanier adapters / so-called conta
------------------

3 tane abstrack data type'ı implemente eden onlar için interface sunan sınıflardır

bu konuyu anlayabilmek için aşağıdakilerin bilmemiz gerekir

-stack : LIFO (son giren ilk çıkar)
  push = yığının en üstüne ekler.
  pop = en üstündeki öğeyi kaldırır ve geri döndürür.
  top = yığının en üstündeki öğeyi geri döndürür, ancak yığından kaldırmaz
  empty = yığının boş olup olmadığını kontrol eder. Eğer yığın boşsa true, değilse false döndürür.

-queue : ilk giren ilk çıkar

-priority : kuyruğa hangi sırayla girerse girsin önceiği en yüksek olan ilk çıkıyor


---------

stl'de contanierın ne olacağını template argümanı belirliyor

mesela stack kullanmak istiyoruz ama contanier olarak vector komposiztion edinmek istiyorum
fiilen o vectorde tutulsun diyebiliryouz,

ancak default template argümanı da var

stack ve queue default template deque
priority default template bir vector

------------

#include <stack>

int main()
{
using namespace std;

stack<int> mystack; // default görünümü
stack<int, deque<int>> mystack;

stack<int, vector<int>> mystack; //şimdi vector kullanılır

//bu yapı kalıtım yapısına kullanılır, 

mystack.c // contanier'a erişir protected olduğu için hata alırız
}

-----------

class NecStack : public std::stack<int> {
//...

publicÇ
void foo()
{
c.assign
}
};

int main()
{
using namespace std;

stack<int, vector<int>> mystack;

}

------------

int main()
{
using namespace std;

stack<int> mystack;

mystack.push(2);
mystack.push(3);
mystack.push(7);
mystack.push(11);

cout << "size = " << mystack.size() << "\n";
cout << "mystack.top() = " << mystack.top() << "\n";
mystack.top()++;

while (!mystack.empty()) {
cout << mystack.yop() << '\n';
mystack.pop();
}
}

---------------

arka tarafta nasıl işler

template <typename T, typename C = std::deque<T>>
class Stack {

public:
void push(const T& val)
{
c.push_back(val);
}

T& top()
{
return c.back();
}

void pop()
{
c.pop_back();
}

bool empty()const
{
return c.empty();
}

auto size()const
{
return c.size();
}

protected:
C c;
};

------------

//contanierlarda olan init list yoktur

int main()
{
stack<int> mystack{4, 6, 7, 8, 9 };
}

-------------
stack bir contanier değil
------------
int main()
{
using namespace std;

deque dx{3, 5, 7, 9};
vector dvec{3, 5, 7, 9};

stack<int> mystack{ dvec };
}

-------------

//mülakatlarda aşağıdaki soru çok sık soruluyor
//bunu kendin çöz dedi
// ([{<  parantezlerin uyumlu olup olamdığına bakıcak

bool is_match(const std::string& s)
{

}

int main()
{
is_match("(a + [2x](val){{neco}})") //bu uyumlu mesela hepsi kapanmış
//is_match bool döndürücek eğer parantezler uyumlu ise true değil ise false
//yazı dolaşılacak açılanlardan birini görünce stack push edilir 
//açılan veya kapana değil ise geçicez, eğer açılanı ise copy edicez
//yazı bitince stack boş olucak
}

----------------

bool is_match(const std::string& s);

int main()
{
using namespace std;

stack<string> sx;

for (int i = 0; i < 10; ++i) {
auto name = rname();
sx.push(name);
std::cout << name << " eklendi\n";
}

std::cout << "size = " << sx.size() << '\n';
while (!sx.empty()) {
std::cout << sx.top() << '\n';
sx.pop();
}
}

-----------------

queue
------

//sadece son öğeye değil ilk öğeye de erişebiliriz

#include <queue>

int main()
{
using namespace std;

queue<string> names;

names.push("melike");
names.push("emre");
names.push("tamer");
names.push("furkan");
names.push("selim");
names.push("yasar");

std::cout << "kurukta" << names.size() << "kisi var\n";
std::cout << "kuyruk basi : " << names.front() << '\n';
std::cout << "kuyruk sonu : " << names.back() << '\n';

while (!names.empty()) {
cout << names.front() << "\n";
names.pop();
(void)getchar();
}
}

----------------

priority_queue: default template argümanı vector
---------------

int main()
{
using namespace std;

priority_queue<string> x; //default less parametresini alır

for (int i = 0; i < 10; ++i) {
auto name = rname();
x.push(name);
cout << name << " eklendi\n";
}

while (!x.empty()) {
std::cout << x.top() << "kuyruktan cikiyor\n"; //max_heap 'e göre çalışır
x.pop();
(void)getchar();
}
}

------------

template <typename T>
using minpq = std::priority_queue<T, std::vector<T>, std::greater<T>>;

int main()
{
using namespace std;

minpq<Date> x;

for (int i = 0; i < 10; ++i) {
x.push(Date::random());
}

while (!x.empty()) {
std::cout << x.top() << '\n';
x.pop();
//(void)getchar();
}
}

------------------

yukarıdaki sınıfları implemente etmeye çalış ilerlemini güçelndirir deid necati hoca

-----------------

template <typename T, typename C = std::vector<T>, typename Comp = std::less<typename C::value_type>>
class PrioritQueu {

};

========================================

associative contaniers
----------------------

set : sadece key tutulur, keye erişir, önceden seçilmiş değerlede o değerin olup olmamasına bakmak, varsa ona erişmek
ologn karmalıklıkta, bir anahtardan bir tane olabilir, tc'den tc'ye erişmek

multiset : bir anahtardan birden fazla olabilir, 

map : tutulanlar pair'ler, key value pairleri, anahtar ile bir value'a erişilir, tc'den isime erişir

multimap : bir keyden birden fazla olabilir

hepsi benzer işler yaparlar, 

arka planda binary search tree dediğimiz veri yapısı dediğimiz veri yapısıdır

------------

sette bir karşılaştırma kriterine ihtiyacımız var buradaki arama işlemleri silme işlemleri
bir comporatör kullanılıyor.

12 45 77 98 343

a == b // equality, 

burada kullanılan terim bu değil . Burada kullanılana equivalance denir

equivalance !(a < b) && (b < a)

--------

associative contanierslar eklenilecek konumu kendileri biliyor değere göre ekleme yapılıyor

öbür contanierslarda konum ile ekleme yapılır

mesela sequence contaniera 17 değeri ekle desek ekler ama nereye ekliyceğini bilmez

associative contaniers anahtarı ister nereye ekliyceğini bilir (ikili arama ağacı sayesinde), comportör kullanarak karşılaştırma yapa yapa konum bulunur


-------
1. template tutulcak öğe türü, 
2. template karşılaştırma kriteri
3. allocator parametre

//2. ve 3. için default kullanılır

#include <set>

int main()
{
using namespace std;

set<int, less<int>, allocator<int>>
set<int, greater<int>>
}

-----------

int main()
{
using namespace std;

set<int> myset {3,1,4,2,8,9,7 };

for (auto iter = myset.begin(); iter != myset.end(); ++iter)
cout << *iter << '\n';
}

----------

int main()
{
using namespace std;

set<int, greater<int>> myset {3,1,4,2,8,9,7 };

for (auto iter = myset.begin(); iter != myset.end(); ++iter)
cout << *iter << '\n';

for (int ival : myset ) { //range base for loop kullanılabilir 
cout << ival << " ";
}
}

------------

int main()
{
using namespace std;

set<string> myset; //küçükten büyüğe dolaşır
set<string, greater<string>> myset; //büyükten küçüğe sıralar

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

----------
//bu kısımı tam anlamadım

class scomp {
public:
bool operator()(const std::string& s1, const std::string& s2)const //burdaki constluğa dikkat et
{
return s1.size() < s2.size() || (s1.size() == s2.size() && s1 < s2);
}

};

int main()
{
using namespace std;

set<string, scomp<string>> myset; //büyükten küçüğe sıralar

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

------------
//bu kısımı tam anlamadım

//aşağıdaki şekilde de olabilirdi

bool mycomp(const std::string& s1, const std::string& s2)
{
return s1.size() < s2.size() || (s1.size() == s2.size() && s1 < s2);
}
};

int main()
{
using namespace std;

set<string, decltype(&mycomp)> myset(mycomp); //büyükten küçüğe sıralar

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

---------------
//bu kısımı tam anlamadım

int main()
{
using namespace std;

auto fcomp = [](const std::string& s1, const std::string& s2)
{
return s1.size() < s2.size() || (s1.size() == s2.size() && s1 < s2);
}
};

set<string, decltype(fcomp)> myset(fcomp);
set<string, decltype(fcomp)> myset; //cpp 23 ile bu şekilde yazılabilir

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

---------------

çok sık yapılan bir hata

bool mycomp(int x, int y)
{

}

strict weak odering : karşılaştırma kriterimi operatör diyelim

a < b true ise
b > a false olmalı

a operator b 
b operator b

a < a false olmalı,

--------------

set multiset farkına bir daha bakıyoruz

int main()
{
using namespace std;

set<int> myset; 

rfill(myset, 100, Irand{0 ,200}); //her bir anahtardan bir tane var
//multiset olsaydı her bir anahtardan birden fazla olabilirdi

for(auto val : myset) {
cout << val << " ";
}
 
}

-------------
//insert fonksiyonu ile sete üye veya üyeler ekleyebiliriz

int main()
{
using namespace std;

multiset<int> myset;

myset.
//fonksiyonları incele
}

--------------
// aşağıdaki logoritmik karmaşıklık değildir, linear complexity
//setin kendi fonksyionu find logoritmik karmaşıklıkta

template <typename InIter, typename T>
InIter Find(InIter beg, InIter end, const T& val)
{
while (beg != end) {
if ( *beg == val)
return beg;
++beg;
}
return end;
}

int main()
{
using namespace std;

multiset<int> myset;
}

---------------

kritik olan üretimde de kullanılan fonksiyonlara bakıyoruz

int main()
{
using namespace std;

set<string> myset;
//multiset<string> myset; //mesela 2. bir nalan olabilirdi

vector<string> svec {"derya", "ceyhun", "nalan", "tekin"};

myset.insert("ayse");
myset.insert({"ali", "zeki", "nuri", "derya"});
myset.insert(svec.begin(), svec.end());

cout << "size = " << myset.size() << '\n';

for (const auto& s : myset)
cout << s << ' ';
}

-------------

int main()
{
using namespace std;

set<string> myset {"derya", "ceyhun", "nalan", "tekin"};
print(myset);

cout << "eklenecek ismi girin: ";
string name{};

cin >> name;

cout << "size = " << myset.size() << '\n';

//set olduğu için mesela nalan eklemeye çalışsak eklemez

//sequnce contanier olsaydı iterator döndürücekti eklenmiş öğenin konumunu döndürücekti
//ancak eklenme grantisi yok bu nedenle iterator bool değeri döndürüyor

//iterator - bool
//ekleme gerçekleşirse bool değeri true olucak, iteratörde eklenmiş öğeye iteratör olucak
//eğer ekleme gerçekleşmemişse false,  iteratorüde var olan değeri olucak

//auto p = myset.insert(name); 
//pair<set<string>::iterator, bool> p = myset.insert(name); //bunlardan herhangi birini kullanabiliriz
auto [iter, inserted] = myset.insert(name); 

if (p.second) {
std::cout << "ekleme yapildi...\n";
cout << "size = " << myset.size() << '\n';
cout << *p.first << "\n";
cout << "distance = " << distance(myset.begin(), p.first) << '\n';
print(myset);
}
else {
std::cout << name << "sette var\n";
cout << *p.first << "\n";
cout << "distance = " << distance(myset.begin(), p.first) << '\n';
}
}

-------------

int main()
{
using namespace std;

set<string> myset {"derya", "ceyhun", "nalan", "tekin"};
print(myset);

cout << "eklenecek ismi girin: ";
string name{};

cin >> name;

cout << "size = " << myset.size() << '\n';

auto iter = myset.insert("deniz").first
mysert.insert("deniz").first-> //bu şekilde işlemler yapabiliriz

------------
//eklemeyi aşağıdaki şekilde de yapabiliriz

int main()
{
using namespace std;

set<string> myset;

for (int i = 0; i < 20; ++i) {
myset.insert(rname());
print(myset);
(void)getchar();
}
}

------------

sette sorulan soru, ya var ya yok

multisette sorulan soru, ya yok ya n tane var

--------------

//aramaya yönelik sorulara bakıyoruz

int main()
{
using namespace std;

set<string> myset;

rfill(myset, 20, rname);
print(myset);
}

cout << "arancak isim: ";
string name{};

cin >> name;

if (auto iter = myset.find(name); iter != myset.end()) {
std::cout << "bulundu..." << *iter << "\n";
std::cout << distance : " << distance(myset.begin(), iter) << "\n";
}
else {
std::cout << "bulunamadi\n"
}
}

--------------

int main()
{
using namespace std;

set<string> myset;

rfill(myset, 10, rname);
print(myset);

cout << "aranacak isim: ";
string name{};

cin >> name;

if (myset.count(name)) { //eskiden böyle bir kullanım vardı, kaç tane olduğu sayılırdı

}

if (myset.contains(name) { //boolen döndürür cpp 20 ile geldi

}
}

-------------

int main()
{
using namespace std;

multiset<int> myset{2,2,2,25,6,7,7,7,7,9};

cout << myset.count(7); //geri dönüş değeri 7'den kaç tane var ise o olacak
}

-----------

int main()
{
using namespace std;

multiset<int> myset{2,2,2,2,6,7,7,7,7,9};

auto iter = myset.find(7);
auto n = distance(myset.begin(), iter);

cout << "n = " << n << '\n';
}

----------

int main()
{
using namespace std;

multiset<int> myset{2,2,2,2,6,7,7,7,7,9};

auto iterlower = myset.lower_bound(7); 
auto iterupper = myset.upper_bound(7); 

cout << distance(myset.begin(), iterlower) << '\n';
cout << distance(myset.begin(), iterupper) << '\n';
}

-----------

//setin silme fonksiyonları değerle silme de içeriyor

int main()
{
using namespace std;

multiset<int> myset{2,3,4,4,4,7,7,7,7,9};

print(myset);

myset.erase(myset.begin(), next(myset.begin());
myset.erase(myset.begin(), next(myset.begin(), 4); //bu şekilde de olur

print(myset);
myset.erase(prev(myset.end()));
print(myset);

}

----------

//değerle silme de vardır

int main()
{
using namespace std;

multiset<int> myset{2,3,4,4,4,7,7,7,7,9};

print(myset);

auto n = myset.erase(myset.begin(), next(myset.begin(), 4));

}

----------

int main()
{
using namespace std;

multiset<int> myset{2,3,4,4,4,7,7,7,7,9};

print(myset);

auto n = erase(myset, 7); //cpp 20, 23 ile geldi
print(myset);
}





