///////////////////////////////////////////////// 1. Ders //////////////////////////////////////////////

forward_list : tekli bağlı liste sınıfı

çifte bağlı listede silinecek öğenin konumunu verirsek o öğeyi destroy etmenin problemi yoktur

tekli bağlı liste : bir düğümü udate etmek istiyorsak bir  önceki düğümdeki pointerı update etmemiz gerekir ancak tekli bağlı listede bu mümkün değildir

bu sıkıntıyı aşmak için tekli bağlı sınıf before begin fonksiyonu bize verir

before begin bize iterator verir ancak o iteratörde bir nesne yoktur

!! back() ,size() ,push_back() fonksiyonu yoktur
!! push_front(), front() vardır

---------------

tekli bağlı liste sınıfı => forward list,
çifte bağlı liste => list

---------------
//mülakatlarda sorulabilir

her öğeden bir tane bırakmak istiyorsak sort + unique yapılabilir

---------------
#include <forward_list>

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});

mylist.push_front(123); //başa ekler
mylist.push_front(999); //başa ekler

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
mlist.pop_front(); //baştan 1 öğe siler

}

--------------
//bu kodları (nutility kullanmadığı) kendin yazmaya çalış

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

auto iter = next(mylist.begin(), 3); //8'in konumunu verdik ancak 1 sonraki konumu tuttu
cout << *iter << "\n";
mylist.insert_after(iter, 7777);

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}

-----------

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

auto iter = next(mylist.begin(), 3); //8'in konumunu verdik ancak 1 sonraki konumu tuttu
cout << *iter << "\n";
mylist.insert_after(iter, {-7, -8, -9}); //8 ile 1 arasına yerleştirir

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}

-----------

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

mylist.insert_after(mylist.before_begin(), {-7, -8 , -9 });

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}


------------

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

mylist.erase_after(mylist.before_begin(), next(mylist.begin(), 3)); //ilk 3 öğe silinir

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}

------------

//mülakatlarda çok çıkan bir sorudur, aranan değeri bulma

//kendin kodunu yaz

//1. yol- 2 iterator kullanarak çözümü
//2. yol- aranan değeri next'e bakarak bulabiliriz

int main()
{
using namespace std;

forward_list mylist{3,6,1,5,9,2,8,13,21 }; //template argümanının bildirmemize rağmen sitacdan dolayı hata vermez (c++17)


int ival;

std::cout << "silinecek degeri girin: ";

cin >> ival;

//
}

==============================================================

contanier adapters / so-called conta
------------------

3 tane abstrack data type'ı implemente eden onlar için interface sunan sınıflardır

bu konuyu anlayabilmek için aşağıdakilerin bilmemiz gerekir

-stack : LIFO (son giren ilk çıkar), üst üste tabak koyma
  push = yığının en üstüne ekler.
  pop = en üstündeki öğeyi kaldırır ve geri döndürür.
  top = yığının en üstündeki öğeyi geri döndürür, ancak yığından kaldırmaz
  empty = yığının boş olup olmadığını kontrol eder. Eğer yığın boşsa true, değilse false döndürür.

-queue : ilk giren ilk çıkar, bilet sırası

-priority : kuyruğa hangi sırayla girerse girsin önceiği en yüksek olan ilk çıkıyor


---------

stl'de contanierın ne olacağını template argümanı belirliyor

mesela stack kullanmak istiyoruz ama contanier olarak vector komposiztion edinmek istiyorum
fiilen o vectorde tutulsun diyebiliryouz,

ancak default template argümanı da var

stack ve queue default template deque
priority default template bir vector

------------

#include <stack>

int main()
{
using namespace std;

stack<int> mystack; // default görünümü
stack<int, deque<int>> mystack;

stack<int, vector<int>> mystack; //şimdi vector kullanılır

//bu yapı kalıtım yapısına kullanılır, 

mystack.c // contanier'a erişir protected olduğu için hata alırız
}

-----------

class NecStack : public std::stack<int> {
//...

public:
void foo()
{
c.assign
}
};

int main()
{
using namespace std;

stack<int, vector<int>> mystack;

}

------------

int main()
{
using namespace std;

stack<int> mystack;

mystack.push(2);
mystack.push(3);
mystack.push(7);
mystack.push(11);

cout << "size = " << mystack.size() << "\n";
cout << "mystack.top() = " << mystack.top() << "\n";
mystack.top()++;

while (!mystack.empty()) {
cout << mystack.top() << '\n';
mystack.pop();
}
}

---------------

arka tarafta nasıl işler

template <typename T, typename C = std::deque<T>>
class Stack {

public:
void push(const T& val)
{
c.push_back(val);
}

T& top()
{
return c.back();
}

void pop()
{
c.pop_back();
}

bool empty()const
{
return c.empty();
}

auto size()const
{
return c.size();
}

protected:
C c;
};

------------

//stack, queue, priority    olan init list yoktur

int main()
{
stack<int> mystack{4, 6, 7, 8, 9 };
}

-------------

stack bir contanier değil
------------

int main()
{
using namespace std;

deque dx{3, 5, 7, 9};
vector dvec{3, 5, 7, 9};

stack<int> mystack{ dvec };
}

-------------

//mülakatlarda aşağıdaki soru çok sık soruluyor
//bunu kendin çöz dedi
// ([{<  parantezlerin uyumlu olup olamdığına bakıcak

bool is_match(const std::string& s)
{

}

int main()
{
is_match("(a + [2x](val){{neco}})") //bu uyumlu mesela hepsi kapanmış
//is_match bool döndürücek eğer parantezler uyumlu ise true değil ise false
//yazı dolaşılacak açılanlardan birini görünce stack push edilir 
//açılan veya kapana değil ise geçicez, eğer açılanı ise copy edicez
//yazı bitince stack boş olucak
}

----------------

bool is_match(const std::string& s);

int main()
{
using namespace std;

stack<string> sx;

for (int i = 0; i < 10; ++i) {
auto name = rname();
sx.push(name);
std::cout << name << " eklendi\n";
}

std::cout << "size = " << sx.size() << '\n';
while (!sx.empty()) {
std::cout << sx.top() << '\n';
sx.pop();
}
}

-----------------

queue
------

//sadece son öğeye değil ilk öğeye de erişebiliriz

#include <queue>

int main()
{
using namespace std;

queue<string> names;

names.push("melike");
names.push("emre");
names.push("tamer");
names.push("furkan");
names.push("selim");
names.push("yasar");

std::cout << "kurukta" << names.size() << "kisi var\n";
std::cout << "kuyruk basi : " << names.front() << '\n';
std::cout << "kuyruk sonu : " << names.back() << '\n';

while (!names.empty()) {
cout << names.front() << "\n";
names.pop();
(void)getchar();
}
}

----------------

priority_queue: default template argümanı vector
---------------

int main()
{
using namespace std;

priority_queue<string> x; //default less parametresini alır

for (int i = 0; i < 10; ++i) {
auto name = rname();
x.push(name);
cout << name << " eklendi\n";
}

while (!x.empty()) {
std::cout << x.top() << "kuyruktan cikiyor\n"; //max_heap 'e göre çalışır
x.pop();
(void)getchar();
}
}

------------

template <typename T>
using minpq = std::priority_queue<T, std::vector<T>, std::greater<T>>;

int main()
{
using namespace std;

minpq<Date> x;

for (int i = 0; i < 10; ++i) {
x.push(Date::random());
}

while (!x.empty()) {
std::cout << x.top() << '\n';
x.pop();
//(void)getchar();
}
}

------------------

yukarıdaki sınıfları implemente etmeye çalış ilerlemini güçelndirir deid necati hoca

-----------------

template <typename T, typename C = std::vector<T>, typename Comp = std::less<typename C::value_type>>
class PrioritQueu {

};

========================================

associative contaniers
----------------------

set : sadece key tutulur, keye erişir, önceden seçilmiş değerlede o değerin olup olmamasına bakmak, varsa ona erişmek
ologn karmalıklıkta, bir anahtardan bir tane olabilir, tc'den tc'ye erişmek

multiset : bir anahtardan birden fazla olabilir, 

map : tutulanlar pair'ler, key value pairleri, anahtar ile bir value'a erişilir, tc'den isime erişir

multimap : bir keyden birden fazla olabilir

hepsi benzer işler yaparlar, 

arka planda binary search tree dediğimiz veri yapısı dediğimiz veri yapısıdır

------------

sette bir karşılaştırma kriterine ihtiyacımız var buradaki arama işlemleri silme işlemleri
bir comporatör kullanılıyor.

12 45 77 98 343

a == b // equality, 

burada kullanılan terim bu değil . Burada kullanılana equivalance denir

equivalance !(a < b) && (b < a)

--------

associative contanierslar eklenilecek konumu kendileri biliyor değere göre ekleme yapılıyor

öbür contanierslarda konum ile ekleme yapılır

mesela sequence contaniera 17 değeri ekle desek ekler ama nereye ekliyceğini bilmez

associative contaniers anahtarı ister nereye ekliyceğini bilir (ikili arama ağacı sayesinde), comportör kullanarak karşılaştırma yapa yapa konum bulunur


-------
1. template tutulcak öğe türü, 
2. template karşılaştırma kriteri
3. allocator parametre

//2. ve 3. için default kullanılır

#include <set>

int main()
{
using namespace std;

set<int, less<int>, allocator<int>>
set<int, greater<int>>
}

-----------

int main()
{
using namespace std;

set<int> myset {3,1,4,2,8,9,7 };

for (auto iter = myset.begin(); iter != myset.end(); ++iter)
cout << *iter << '\n';
}

----------

int main()
{
using namespace std;

set<int, greater<int>> myset {3,1,4,2,8,9,7 }; //defaultu less'dir

for (auto iter = myset.begin(); iter != myset.end(); ++iter)
cout << *iter << '\n';

for (int ival : myset ) { //range base for loop kullanılabilir 
cout << ival << " ";
}
}

------------

int main()
{
using namespace std;

set<string> myset; //küçükten büyüğe dolaşır
set<string, greater<string>> myset; //büyükten küçüğe sıralar

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

----------
//class yapısı ile yapımı

class scomp {
public:
bool operator()(const std::string& s1, const std::string& s2)const //burdaki constluğa dikkat et
{
return s1.size() < s2.size() || (s1.size() == s2.size() && s1 < s2);
}
};

int main()
{
using namespace std;

set<string, scomp<string>> myset; //büyükten küçüğe sıralar

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

------------
//fonksiyon ile yapımı
//aşağıdaki şekilde de olabilirdi

bool mycomp(const std::string& s1, const std::string& s2)
{
return s1.size() < s2.size() || (s1.size() == s2.size() && s1 < s2);
}
};

int main()
{
using namespace std;

set<string, decltype(&mycomp)> myset(mycomp); //büyükten küçüğe sıralar

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

---------------

int main()
{
using namespace std;

auto fcomp = [](const std::string& s1, const std::string& s2)
{
return s1.size() < s2.size() || (s1.size() == s2.size() && s1 < s2);
}
};

set<string, decltype(fcomp)> myset(fcomp);
set<string, decltype(fcomp)> myset; //cpp 23 ile bu şekilde yazılabilir

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

---------------

çok sık yapılan bir hata

bool mycomp(int x, int y)
{

}

strict weak odering : karşılaştırma kriterimi operatör diyelim

a < b true ise
b > a false olmalı

a operator b 
b operator b

a < a false olmalı, 

//yukarıdakilerine dikkaet edilmeli

--------------

set multiset farkına bir daha bakıyoruz

int main()
{
using namespace std;

set<int> myset; 

rfill(myset, 100, Irand{0 ,200}); //her bir anahtardan bir tane var
//multiset olsaydı her bir anahtardan birden fazla olabilirdi

for(auto val : myset) {
cout << val << " ";
}
 
}

-------------
//insert fonksiyonu ile sete üye veya üyeler ekleyebiliriz

int main()
{
using namespace std;

multiset<int> myset;

myset.
//fonksiyonları incele
}

--------------
// aşağıdaki logoritmik karmaşıklık değildir, linear complexity
//setin kendi fonksyionu find logoritmik karmaşıklıkta

template <typename InIter, typename T>
InIter Find(InIter beg, InIter end, const T& val)
{
while (beg != end) {
if ( *beg == val)
return beg;
++beg;
}
return end;
}

int main()
{
using namespace std;

multiset<int> myset;
}

---------------

kritik olan üretimde de kullanılan fonksiyonlara bakıyoruz

int main()
{
using namespace std;

set<string> myset; //default olarak less parametresi alır
//multiset<string> myset; //mesela 2. bir nalan olabilirdi


myset.insert("ayse");
myset.insert({"ali", "zeki", "nuri", "derya"});
myset.insert(svec.begin(), svec.end());

cout << "size = " << myset.size() << '\n';

for (const auto& s : myset)
cout << s << ' ';
}

-------------

int main()
{
using namespace std;

set<string> myset {"derya", "ceyhun", "nalan", "tekin"};
print(myset);

cout << "eklenecek ismi girin: ";
string name{};

cin >> name;

cout << "size = " << myset.size() << '\n';

//set olduğu için mesela nalan eklemeye çalışsak eklemez

//sequnce contanier olsaydı iterator döndürücekti eklenmiş öğenin konumunu döndürücekti
//ancak eklenme grantisi yok bu nedenle iterator bool değeri döndürüyor

//iterator - bool
//ekleme gerçekleşirse bool değeri true olucak, iteratörde eklenmiş öğeye iteratör olucak
//eğer ekleme gerçekleşmemişse false,  iteratorüde var olan değeri olucak

//auto p = myset.insert(name); 
//pair<set<string>::iterator, bool> p = myset.insert(name); //bunlardan herhangi birini kullanabiliriz
auto [iter, inserted] = myset.insert(name); 

if (p.second) { //pair olduğu için first iteratör konumunu second true/false değerini tutar
std::cout << "ekleme yapildi...\n";
cout << "size = " << myset.size() << '\n';
cout << *p.first << "\n";
cout << "distance = " << distance(myset.begin(), p.first) << '\n';
print(myset);
}
else {
std::cout << name << "sette var\n";
cout << *p.first << "\n";
cout << "distance = " << distance(myset.begin(), p.first) << '\n';
}
}

-------------

int main()
{
using namespace std;

set<string> myset {"derya", "ceyhun", "nalan", "tekin"};
print(myset);

cout << "eklenecek ismi girin: ";
string name{};

cin >> name;

cout << "size = " << myset.size() << '\n';

auto iter = myset.insert("deniz").first;
myset.insert("deniz").first-> //bu şekilde işlemler yapabiliriz

------------
//eklemeyi aşağıdaki şekilde de yapabiliriz

int main()
{
using namespace std;

set<string> myset;

for (int i = 0; i < 20; ++i) {
myset.insert(rname());
print(myset);
(void)getchar();
}
}

------------

sette sorulan soru, ya var ya yok

multisette sorulan soru, ya yok ya n tane var

--------------

//aramaya yönelik sorulara bakıyoruz

int main()
{
using namespace std;

set<string> myset;

rfill(myset, 20, rname);
print(myset);
}

cout << "arancak isim: ";
string name{};

cin >> name;

if (auto iter = myset.find(name); iter != myset.end()) {
std::cout << "bulundu..." << *iter << "\n";
std::cout << distance : " << distance(myset.begin(), iter) << "\n";
}
else {
std::cout << "bulunamadi\n"
}
}

--------------

int main()
{
using namespace std;

set<string> myset;

rfill(myset, 10, rname);
print(myset);

cout << "aranacak isim: ";
string name{};

cin >> name;

if (myset.count(name)) { //eskiden böyle bir kullanım vardı, kaç tane olduğu sayılırdı

}

if (myset.contains(name) { //boolen döndürür cpp 20 ile geldi

}
}

-------------

int main()
{
using namespace std;

multiset<int> myset{2,2,2,25,6,7,7,7,7,9};

cout << myset.count(7); //geri dönüş değeri 7'den kaç tane var ise o olacak
}

-----------

int main()
{
using namespace std;

multiset<int> myset{2,2,2,2,6,7,7,7,7,9};

auto iter = myset.find(7);
auto n = distance(myset.begin(), iter);

cout << "n = " << n << '\n';
}

----------

int main()
{
using namespace std;

multiset<int> myset{2,2,2,2,6,7,7,7,7,9};

auto iterlower = myset.lower_bound(7); 
auto iterupper = myset.upper_bound(7); 

cout << distance(myset.begin(), iterlower) << '\n';
cout << distance(myset.begin(), iterupper) << '\n';
}

-----------

//setin silme fonksiyonları değerle silme de içeriyor

int main()
{
using namespace std;

multiset<int> myset{2,3,4,4,4,7,7,7,7,9};

print(myset);

myset.erase(myset.begin(), next(myset.begin());
myset.erase(myset.begin(), next(myset.begin(), 4); //bu şekilde de olur

print(myset);
myset.erase(prev(myset.end()));
print(myset);

}

----------

//değerle silme de vardır

int main()
{
using namespace std;

multiset<int> myset{2,3,4,4,4,7,7,7,7,9};

print(myset);

auto n = myset.erase(myset.begin(), next(myset.begin(), 4)); //ilk 4 sildi

}

----------

int main()
{
using namespace std;

multiset<int> myset{2,3,4,4,4,7,7,7,7,9};

print(myset);

auto n = erase(myset, 7); //cpp 20, 23 ile geldi
print(myset);
}


//////////////////////////////////////////// 2. Ders ////////////////////////////////////////

associative contanierslar tipik olarak binary search tree algoritmasını implemente ederler

ikili arama ağacı anahtarla erişimi logoritmik karmaşıklığa çevirir

set'in ağrılıklı uygulaması var mı? yok mu? uygulamasıdır

---------------

associative contanierslar'ın kafa karıştırıcı bir fonksiyonu

insert
------
konum ister normalde istememesi lazım ancak hint insert denilen bu yapı ile konum istenerek
daha iyi performans sağlanır, konum dğru ise gereksiz yere çalışmıycak yanlış ise bildiği konuma koyucak

int main()
{
using namespace std;

vector<string> svec {"eda", "naz", "tan" };
set<string> myset{"ayca", "berna", "derya", "meliha", "saliha" };

myset.insert(myset.begin(), "aliye"); //hint insert

copy(svec.begin(), svec.end(), inserter(myset, myset.begin()));

myset.emplace_hint(myset.begin(), 10, 'A'); //10 ve A argümanlarını perfect forwarding ederek nesneyi oluştur
}

---------------

modern cpp öncesi çok sorulan bir mülakat sorusu

int main()
{
using namespace std;

set<string> myset;
rfill(myset, 10, rname);
print(myset);

cout << "eski ve yeni ismi giriniz: ";
string old_name, new_name;
cin >> old_name >> new_name;

//sette mesela ali gitsin, yerine veli gelsin
//bu işlemi yaptır

//find ile bulup onu silip insert fonksiyonu ile yeni anahtar ekliyceksiniz

if (auto iter = myset.find(old_name); iter != myset.end()) { //myset end yazdırmayı dene son konum mu sondan bir sonra mı kontrol et
myset.erase(iter);
myset.insert(new_name);
std::cout << "anahtar degistirildi\n";
print(myset);
}
cout << "bulunamadi\n";
}

-------------------

yukarıdakinin yeni interface'i

//extrack: düğümün çıkarılması işlemini yapar
  
int main()
{
using namespace std;

set<string> myset;
rfill(myset, 10, rname);
print(myset);

cout << "size = " << myset.size() << '\n';
cout << "eski ve yeni ismi giriniz: ";
string old_name, new_name;
cin >> old_name >> new_name;

auto iter = myset.find(old_name);
auto handle = myset.extract(iter);
cout << "size = " << myset.size() << '\n';
(void)getchar();

if (handle.empty()) //handle boş olup olmadığına bu şekilde bakabiliria

handle.value() = new_name; //fonksyionun geri dönüş değerinin l value olduğu görülür, yani düğümdeki datayı döndürür
myset.insert(move(handle));

}


--------------

int main()
{
using namespace std;

set<string> myset;
rfill(myset, 10, rname);
print(myset);

cout << "size = " << myset.size() << '\n';
cout << "eski ve yeni ismi giriniz: ";
string old_name, new_name;
cin >> old_name >> new_name;

if (auto iter = myset.find(old_name); iter != myset.end()) {
auto handle = myset.extract(iter);
cout << "size = " << myset.size() << '\n';
(void)getchar();
handle.value() = new_name;
myset.insert(move(handle));
cout << "size = " << myset.size() << '\n'
print(myset);
}
else {
std::cout << "bulunamadi\n";  
}
}

----------

int main()
{
using namespace std;
rfill(myset, 20, Irand{0, 5});
print(myset);

auto iter = myset.lower_bound(3);

auto [iter.first, iter_last] = myset.equal_range(3);
}

--------------

unavalibel context'te lambda kullanılabiliyordu

int main()
{
using namespace std;

auto fcomp = [](int x, int y) {
return x % 100 < y % 100;
};

sizeof(decltype([]{})) //bu bir hata değil
}


----------
//yukarıdaki yapı sayesinde aşşağıdaki kullanılabilir

int main()
{
using namespace std;

set<int, decltype([](int x, int y) {
return x % 100 < y % 100;
}) > myset;
}

====================================================

MAP
----

sete insert ederken insert edilcek öğeyi geçeriz map'e pair geçmemiz lazım

first -> key
second -> value

map ve multimap seçimini doğru anlamak gerekir

mesela ingilizce türkçe sözlük için multimap kullanırız

-----------
1. template parametre : anahtarın türü
2. template parametre : o anahtara karşılık gelicek value türü
3. template parametre : karşılaştırma kriteri less key açılmını alır
4. template parametre : allocator'ın key const key açılımı

----------


int main()
{
using namespace std;

map<int, string> mx; //int değerlerinin küçükten büyüğe sıralanmasıyla olur

for (int i = 0; i < 10; ++i) {
mx.insert(pair{rand(), rname() });
}

for (const auto& p : mx) {
print("{:<12} {}\n", p.first, p.second);x
}
}

------------
//mülakatlarda sorulur

int main()
{
using namespace std;

map<int, string> mx; //int değerlerinin küçükten büyüğe sıralanmasıyla olur

for (int i = 0; i < 10; ++i) {
mx.insert(pair{rand(), rname() });
}

auto iter = mx.begin();

iter->fisrt = "furkanmert"; //hata, key değiştirilemez
const_cast<string&>(iter->fisrt) = "furkanmert"; //legal ancak ub
iter->second = 873443;

}

-------------

int main()
{
using namespace std;

map<string, int> mx{ {"deniz", 567}, {"ayca", 812}, {"yilmaz", 313}, {"deniz", 9999 }};

cout << "mx.size() = " << mx.size() << '\n';

}

----------

int main()
{
using namespace std;

map<string, int> mx{ {"deniz", 567}, {"ayca", 812}, {"yilmaz", 313}, {"bilge", 567 }}; // anahtardan birden fazla olabilir

cout << "mx.size() = " << mx.size() << '\n';

}

----------

mape öğe eklemenin yolları :

mape pair'ler eklenecek

int main()
{
using namespace std;

map<string, int> mx;

pair<string, int> p1{"tayfun", 767};

mx.insert(p1);
mx.insert(pair{"alican", 871});
mx.insert(pair{"veli", 219});
mx.insert(make_pair("deniz", 761));
mx.emplace("damla", 732);

//dolaşırken aşağıdakileri kullanabiliriz

for (auto iter = mx.begin(); iter != mx.end(); ++iter) {
print("{:<16} {}\n", iter->first, iter->second);
}

//... forrange

for (const auto& p : mx) {
print("{:<16} {}\n", p.first, p.second);
}
}

//... structure binding C++ 17, en çok bu kullanılır

for (const auto& [name, grade] : mx) {
cout << name << " " << grade << '\n';
}

-------------

int main()
{
using namespace std;

map<string, string> mymap;

for (int i = 0; i < 1000; ++i) {
mymap.emplace(rname(), rtown());
}

print(mymap, "\n");
}

------------

insert ile emplace farkı:
insert benden pair ister
emplace pair istemez

--------------

fonksiyonları :
-------------

int main()
{
using namespace std;

map<string, string> mymap;

for (int i = 0; i < 1000; ++i) {
mymap.emplace(rname(), rtown());

auto handle = mymap.extract("deniz");

handle.key; //keye erişir
handle.mapped; //mape erişir

}

--------------

int main()
{
using namespace std;

map<int, string>< mymap;

for (int i = 0; i < 10; ++i) {
mymap.emplace(Irand{0,100}(), rname());
}
print(mymap, "\n");

int key;

std::cout << "yasi girin: ";
cin >> key;

mymap[key] = "sadullah";
//mymap.at(key) = "sadullah"; //anahtar yok ise exception throw eder

print(mymap, "\n");
}

-----------

yukarıki yapının kullanıldığı idiyomatik bir yapı vardır

mülakatların fovori sorusudur

int main()
{
vector<string> svec;

rfill(svec, 10000, rname);

//her bir isimden kaç tane olduğunu bulmammız gerekiror ve bu bilgiyi bir yerde tutucaz

map<string, int> cmap;

for (const auto& name : svec) {
++cmap[name];
}

std::ofstream ofs{"out.txt"};
if (!ofs) {
std::cerr << "out.txt dosyasi olusturlamadi\n";
exit(EXIT_FAILURE);
}

for (const auto& [name, count] : cmap) {
print(ofs, "{:<18} {}", name, count);
}
}

------------

klasik bir mülakat sorusu daha vardır

//değerlerin sırasına göre yazmak istiyoruz

//vectöre taşıyarak yapabliriz

int main()
{
vector<string> svec;

rfill(svec, 10000, rname);

//her bir isimden kaç tane olduğunu bulmammız gerekiror ve bu bilgiyi bir yerde tutucaz

map<string, int> cmap;

for (const auto& name : svec) {
++cmap[name];
}

vector<pair<string, int>> myvec{cmap.begin(), cmap.end()};

sort(myvec.begin(), myvec.end(), [](const auto &p1, const auto& p2) {
return p1.second > p2.second;
});


std::ofstream ofs{"out.txt"};
if (!ofs) {
std::cerr << "out.txt dosyasi olusturlamadi\n";
exit(EXIT_FAILURE);
}

for (const auto& [name, count] : myvec) {
print(ofs, "{:<18} {}", name, count);
}
}

------------

int main()
{
using namespace std;

map<string,int> mymap;

for (int i = 0; i < 10; ++i) {
mymap.emplace(Irand{0, 70}(), rname());
}

print(mymap, "\n");

string old_key, new_key;

cout << "eski ve yeni anahtarları girin: ";
cin >> old_key >> new_key;

auto handle = mymap.extract(old_key)
if (handle) {
handle.key() = new_key;
cout << "anahtar degistirildi\n";
print(mymap, "\n");

};
}

-------------------

ödev:

int main()
{
using namespace std;

multimap<string, int> mymap;

string name{"deniz"};

//deniz key'leri icin value'lar birer arttırılıcak

}

--------

int main()
{
using namespace std;

multimap<double, int> mymap;

cout << typeid(mymap.key_comp()).name() << '\n';
cout << typeid(mymap.value_comp()).name() << '\n';

}

====================================================

hash table (çırpı tablosu) : bir çırpıda bulutyordan aklına gelsin
----------------------------

anahtarla arama yaparız ancak setten farklı olarak constant time' a çekmek istiyoruz

sette anahtarla arama logoritmik karmaşıklıkta, hast table'da amorties constant time'da

anahtarı indexe dönüştüren bir fonksiyon var

temel problem farklı anahtarları aynı index değerine hash edebilir

farklı anahtarlar aynı indexe eriştiğinde ikisininde erişmesini sağlamamız lazım

------

vectörde o indexli öğeye eriştiğimizde eğer o anahtarla çakışan başka bir anahtar yok ise bağlı listede 1 tane öğe olucak

eğer o anahtar yok ise bağlı liste boş olucak

eğer anahtar 3 taneye eriştiyse bağlı listede 3 tane olucak

bağlı listeleri tutan öğeler apit deniyo

int, double vs bütün türler için stl sağladığı hash fonksiyonunu kullanmalıyız

------

hash bütün türleri için explicit specilation sağlıyor

------
//int'leri hash ediceksin mesela

int main()
{
using namespace std;

hash<int> hasher;

size_t val = hasher(87562); //87562 hash değeri

cout << val << "\n"; //0 ile size_t max değeri arasında hash değeri üretiyor    


}

-------
//değerler biribiri ile alakasız çıkacaktır

int main()
{
using namespace std;

hash<int> hasher;

for (int i = 8'712'651; i < 8'712'690; ++i) {
print("hash value for {} is {}\n", i, hasher(i));
}
}

-------

int main()
{
using namespace std;

hash<string> hasher;

cout << hasher("deniz") << '\n';
cout << hasher("denis") << '\n';
cout << hasher("denizcan") << '\n';
cout << hasher("denizhan") << '\n';

-------

int main()
{
using namespace std;

int ival = 346369723;

cout << hash<int>{}(ival) << '\n';
}

---------

kendi sınıfımız için hasher oluşturmak istiyoruz
bunu yapmanın yollaru vardır

//en iyi seçenek boost::hash

struct DateHasher {
std::size operator()(const Date& dt)
{
std::hash<int> hasher;

return hasher(dt.month_day()) + hasher(dt.month()) + hasher(dt.year());
}
};

int main()
{
using namespace std;

Date mydate{17, 11, 2023 };

cout << DateHasher{}(mydate) << '\n';
++mydate;
cout << DateHasher{}(mydate) << '\n';
}

---------

2. bir yol

template <>
struct std::hash<Date> {
std::size operator()(const Date& dt)
{
std::hash<int> hasher;

return hasher(dt.month_day()) + hasher(dt.month()) + hasher(dt.year());
}
};

int main()
{
using namespace std;

Date mydate{17, 11, 2023 };

cout << DateHasher{}(mydate) << '\n';
++mydate;
cout << DateHasher{}(mydate) << '\n';
}

============================================

unordered_set

#include <unordered_set>

int main()
{
using namespace std;

unordered_set<int, hash<int>, equal_to<int>

unordered_set<Date> myset; //hata olur hash'in date açılımı yok

}

------------

class DateHasher {
std::size_t operator()(const Date&)const;

};

struct DateEqual {
bool operator()(const Date&, const Date&)const;
};

int main()
{
using namespace std;

unordered_set<Date, DateHasher> myset;
}

-------------

int main()
{
using namespace std;

auto flash = [](const Date&) { //hasher olarak burası
return 12u;
};

auto eq = [](const Date&, const Date&) { //karşılaştırma olarak burası kullanılır
return true;
};

unordered_set<Date, decltype(flash), decltype(eq)>
}

---------------

üye fonksiyonlara bakıyoruz

int main()
{
using namespace std;

unordered_set<int> myset(400); //400 tane buget ile başlasın demek

cout << myset.bucket_count() << "\n";
}

---------

int main()
{
using namespace std;

unordered_set<int> myset;

auto x = myset.hash_function();

}

--------

int main()
{
using namespace std;

unordered_set<string> myset;

for (int i = 0; i < 10; ++i) {
myset.insert(rname());
}

print(myset);

for (int i = 0; i < 10; ++i) {
string name; //derleyici bunun kolayca implemente edebilir. o yüzden içerde veya dışarda yazmamızım bir önemi yoktur içerde yazınca 10 kere ctor çağrılmaz
cout << "iism girin: ";
cin >> name;
if (auto iter = myset.find(name); iter != myset.end())
{

}
}
}

////////////////////////////////////////////// 3. Ders /////////////////////////////////////////
































