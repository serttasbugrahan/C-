///////////////////////////////////////////////// 1. Ders //////////////////////////////////////////////

forward_list : tekli bağlı liste sınıfı

çifte bağlı listede silinecek öğenin konumunu verirsek o öğeyi destroy etmenin problemi yoktur

tekli bağlı liste : bir düğümü udate etmek istiyorsak bir  önceki düğümdeki pointerı update etmemiz gerekir ancak tekli bağlı listede bu mümkün değildir

bu sıkıntıyı aşmak için tekli bağlı sınıf before begin fonksiyonu bize verir

before begin bize iterator verir ancak o iteratörde bir nesne yoktur

!! back() ,size() ,push_back() fonksiyonu yoktur
!! push_front(), front() vardır

---------------

tekli bağlı liste sınıfı => forward list,
çifte bağlı liste => list

---------------
//mülakatlarda sorulabilir

her öğeden bir tane bırakmak istiyorsak sort + unique yapılabilir

---------------
#include <forward_list>

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});

mylist.push_front(123); //başa ekler
mylist.push_front(999); //başa ekler

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
mlist.pop_front(); //baştan 1 öğe siler

}

--------------
//bu kodları (nutility kullanmadığı) kendin yazmaya çalış

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

auto iter = next(mylist.begin(), 3); //8'in konumunu verdik ancak 1 sonraki konumu tuttu
cout << *iter << "\n";
mylist.insert_after(iter, 7777);

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}

-----------

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

auto iter = next(mylist.begin(), 3); //8'in konumunu verdik ancak 1 sonraki konumu tuttu
cout << *iter << "\n";
mylist.insert_after(iter, {-7, -8, -9}); //8 ile 1 arasına yerleştirir

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}

-----------

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

mylist.insert_after(mylist.before_begin(), {-7, -8 , -9 });

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}


------------

int main()
{
using namespace std;

forward_list<int> mylist{3, 5, 6, 8, 1, 9};

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";

mylist.erase_after(mylist.before_begin(), next(mylist.begin(), 3)); //ilk 3 öğe silinir

copy(mylist.begin(), mylist.end(), ostream_iterator<int>{cout, " "});
std::cout << "\n";
}

------------

//mülakatlarda çok çıkan bir sorudur, aranan değeri bulma

//kendin kodunu yaz

//1. yol- 2 iterator kullanarak çözümü
//2. yol- aranan değeri next'e bakarak bulabiliriz

int main()
{
using namespace std;

forward_list mylist{3,6,1,5,9,2,8,13,21 }; //template argümanının bildirmemize rağmen sitacdan dolayı hata vermez (c++17)


int ival;

std::cout << "silinecek degeri girin: ";

cin >> ival;

//
}

==============================================================

contanier adapters / so-called conta
------------------

3 tane abstrack data type'ı implemente eden onlar için interface sunan sınıflardır

bu konuyu anlayabilmek için aşağıdakilerin bilmemiz gerekir

-stack : LIFO (son giren ilk çıkar), üst üste tabak koyma
  push = yığının en üstüne ekler.
  pop = en üstündeki öğeyi kaldırır ve geri döndürür.
  top = yığının en üstündeki öğeyi geri döndürür, ancak yığından kaldırmaz
  empty = yığının boş olup olmadığını kontrol eder. Eğer yığın boşsa true, değilse false döndürür.

-queue : ilk giren ilk çıkar, bilet sırası

-priority : kuyruğa hangi sırayla girerse girsin önceiği en yüksek olan ilk çıkıyor


---------

stl'de contanierın ne olacağını template argümanı belirliyor

mesela stack kullanmak istiyoruz ama contanier olarak vector komposiztion edinmek istiyorum
fiilen o vectorde tutulsun diyebiliryouz,

ancak default template argümanı da var

stack ve queue default template deque
priority default template bir vector

------------

#include <stack>

int main()
{
using namespace std;

stack<int> mystack; // default görünümü
stack<int, deque<int>> mystack;

stack<int, vector<int>> mystack; //şimdi vector kullanılır

//bu yapı kalıtım yapısına kullanılır, 

mystack.c // contanier'a erişir protected olduğu için hata alırız
}

-----------

class NecStack : public std::stack<int> {
//...

public:
void foo()
{
c.assign
}
};

int main()
{
using namespace std;

stack<int, vector<int>> mystack;

}

------------

int main()
{
using namespace std;

stack<int> mystack;

mystack.push(2);
mystack.push(3);
mystack.push(7);
mystack.push(11);

cout << "size = " << mystack.size() << "\n";
cout << "mystack.top() = " << mystack.top() << "\n";
mystack.top()++;

while (!mystack.empty()) {
cout << mystack.top() << '\n';
mystack.pop();
}
}

---------------

arka tarafta nasıl işler

template <typename T, typename C = std::deque<T>>
class Stack {

public:
void push(const T& val)
{
c.push_back(val);
}

T& top()
{
return c.back();
}

void pop()
{
c.pop_back();
}

bool empty()const
{
return c.empty();
}

auto size()const
{
return c.size();
}

protected:
C c;
};

------------

//stack, queue, priority    olan init list yoktur

int main()
{
stack<int> mystack{4, 6, 7, 8, 9 };
}

-------------

stack bir contanier değil
------------

int main()
{
using namespace std;

deque dx{3, 5, 7, 9};
vector dvec{3, 5, 7, 9};

stack<int> mystack{ dvec };
}

-------------

//mülakatlarda aşağıdaki soru çok sık soruluyor
//bunu kendin çöz dedi
// ([{<  parantezlerin uyumlu olup olamdığına bakıcak

bool is_match(const std::string& s)
{

}

int main()
{
is_match("(a + [2x](val){{neco}})") //bu uyumlu mesela hepsi kapanmış
//is_match bool döndürücek eğer parantezler uyumlu ise true değil ise false
//yazı dolaşılacak açılanlardan birini görünce stack push edilir 
//açılan veya kapana değil ise geçicez, eğer açılanı ise copy edicez
//yazı bitince stack boş olucak
}

----------------

bool is_match(const std::string& s);

int main()
{
using namespace std;

stack<string> sx;

for (int i = 0; i < 10; ++i) {
auto name = rname();
sx.push(name);
std::cout << name << " eklendi\n";
}

std::cout << "size = " << sx.size() << '\n';
while (!sx.empty()) {
std::cout << sx.top() << '\n';
sx.pop();
}
}

-----------------

queue
------

//sadece son öğeye değil ilk öğeye de erişebiliriz

#include <queue>

int main()
{
using namespace std;

queue<string> names;

names.push("melike");
names.push("emre");
names.push("tamer");
names.push("furkan");
names.push("selim");
names.push("yasar");

std::cout << "kurukta" << names.size() << "kisi var\n";
std::cout << "kuyruk basi : " << names.front() << '\n';
std::cout << "kuyruk sonu : " << names.back() << '\n';

while (!names.empty()) {
cout << names.front() << "\n";
names.pop();
(void)getchar();
}
}

----------------

priority_queue: default template argümanı vector
---------------

int main()
{
using namespace std;

priority_queue<string> x; //default less parametresini alır

for (int i = 0; i < 10; ++i) {
auto name = rname();
x.push(name);
cout << name << " eklendi\n";
}

while (!x.empty()) {
std::cout << x.top() << "kuyruktan cikiyor\n"; //max_heap 'e göre çalışır
x.pop();
(void)getchar();
}
}

------------

template <typename T>
using minpq = std::priority_queue<T, std::vector<T>, std::greater<T>>;

int main()
{
using namespace std;

minpq<Date> x;

for (int i = 0; i < 10; ++i) {
x.push(Date::random());
}

while (!x.empty()) {
std::cout << x.top() << '\n';
x.pop();
//(void)getchar();
}
}

------------------

yukarıdaki sınıfları implemente etmeye çalış ilerlemini güçelndirir deid necati hoca

-----------------

template <typename T, typename C = std::vector<T>, typename Comp = std::less<typename C::value_type>>
class PrioritQueu {

};

========================================

associative contaniers
----------------------

set : sadece key tutulur, keye erişir, önceden seçilmiş değerlede o değerin olup olmamasına bakmak, varsa ona erişmek
ologn karmalıklıkta, bir anahtardan bir tane olabilir, tc'den tc'ye erişmek

multiset : bir anahtardan birden fazla olabilir, 

map : tutulanlar pair'ler, key value pairleri, anahtar ile bir value'a erişilir, tc'den isime erişir

multimap : bir keyden birden fazla olabilir

hepsi benzer işler yaparlar, 

arka planda binary search tree dediğimiz veri yapısı dediğimiz veri yapısıdır

------------

sette bir karşılaştırma kriterine ihtiyacımız var buradaki arama işlemleri silme işlemleri
bir comporatör kullanılıyor.

12 45 77 98 343

a == b // equality, 

burada kullanılan terim bu değil . Burada kullanılana equivalance denir

equivalance !(a < b) && (b < a)

--------

associative contanierslar eklenilecek konumu kendileri biliyor değere göre ekleme yapılıyor

öbür contanierslarda konum ile ekleme yapılır

mesela sequence contaniera 17 değeri ekle desek ekler ama nereye ekliyceğini bilmez

associative contaniers anahtarı ister nereye ekliyceğini bilir (ikili arama ağacı sayesinde), comportör kullanarak karşılaştırma yapa yapa konum bulunur


-------
1. template tutulcak öğe türü, 
2. template karşılaştırma kriteri
3. allocator parametre

//2. ve 3. için default kullanılır

#include <set>

int main()
{
using namespace std;

set<int, less<int>, allocator<int>>
set<int, greater<int>>
}

-----------

int main()
{
using namespace std;

set<int> myset {3,1,4,2,8,9,7 };

for (auto iter = myset.begin(); iter != myset.end(); ++iter)
cout << *iter << '\n';
}

----------

int main()
{
using namespace std;

set<int, greater<int>> myset {3,1,4,2,8,9,7 }; //defaultu less'dir

for (auto iter = myset.begin(); iter != myset.end(); ++iter)
cout << *iter << '\n';

for (int ival : myset ) { //range base for loop kullanılabilir 
cout << ival << " ";
}
}

------------

int main()
{
using namespace std;

set<string> myset; //küçükten büyüğe dolaşır
set<string, greater<string>> myset; //büyükten küçüğe sıralar

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

----------
//class yapısı ile yapımı

class scomp {
public:
bool operator()(const std::string& s1, const std::string& s2)const //burdaki constluğa dikkat et
{
return s1.size() < s2.size() || (s1.size() == s2.size() && s1 < s2);
}
};

int main()
{
using namespace std;

set<string, scomp<string>> myset; //büyükten küçüğe sıralar

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

------------
//fonksiyon ile yapımı
//aşağıdaki şekilde de olabilirdi

bool mycomp(const std::string& s1, const std::string& s2)
{
return s1.size() < s2.size() || (s1.size() == s2.size() && s1 < s2);
}
};

int main()
{
using namespace std;

set<string, decltype(&mycomp)> myset(mycomp); //büyükten küçüğe sıralar

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

---------------

int main()
{
using namespace std;

auto fcomp = [](const std::string& s1, const std::string& s2)
{
return s1.size() < s2.size() || (s1.size() == s2.size() && s1 < s2);
}
};

set<string, decltype(fcomp)> myset(fcomp);
set<string, decltype(fcomp)> myset; //cpp 23 ile bu şekilde yazılabilir

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

cout << "myset.size() = " << myset.size() << '\n';

for (const auto& s : myset) {
std::cout << s << 
}
}

---------------

çok sık yapılan bir hata

bool mycomp(int x, int y)
{

}

strict weak odering : karşılaştırma kriterimi operatör diyelim

a < b true ise
b > a false olmalı

a operator b 
b operator b

a < a false olmalı, 

//yukarıdakilerine dikkaet edilmeli

--------------

set multiset farkına bir daha bakıyoruz

int main()
{
using namespace std;

set<int> myset; 

rfill(myset, 100, Irand{0 ,200}); //her bir anahtardan bir tane var
//multiset olsaydı her bir anahtardan birden fazla olabilirdi

for(auto val : myset) {
cout << val << " ";
}
 
}

-------------
//insert fonksiyonu ile sete üye veya üyeler ekleyebiliriz

int main()
{
using namespace std;

multiset<int> myset;

myset.
//fonksiyonları incele
}

--------------
// aşağıdaki logoritmik karmaşıklık değildir, linear complexity
//setin kendi fonksyionu find logoritmik karmaşıklıkta

template <typename InIter, typename T>
InIter Find(InIter beg, InIter end, const T& val)
{
while (beg != end) {
if ( *beg == val)
return beg;
++beg;
}
return end;
}

int main()
{
using namespace std;

multiset<int> myset;
}

---------------

kritik olan üretimde de kullanılan fonksiyonlara bakıyoruz

int main()
{
using namespace std;

set<string> myset; //default olarak less parametresi alır
//multiset<string> myset; //mesela 2. bir nalan olabilirdi


myset.insert("ayse");
myset.insert({"ali", "zeki", "nuri", "derya"});
myset.insert(svec.begin(), svec.end());

cout << "size = " << myset.size() << '\n';

for (const auto& s : myset)
cout << s << ' ';
}

-------------

int main()
{
using namespace std;

set<string> myset {"derya", "ceyhun", "nalan", "tekin"};
print(myset);

cout << "eklenecek ismi girin: ";
string name{};

cin >> name;

cout << "size = " << myset.size() << '\n';

//set olduğu için mesela nalan eklemeye çalışsak eklemez

//sequnce contanier olsaydı iterator döndürücekti eklenmiş öğenin konumunu döndürücekti
//ancak eklenme grantisi yok bu nedenle iterator bool değeri döndürüyor

//iterator - bool
//ekleme gerçekleşirse bool değeri true olucak, iteratörde eklenmiş öğeye iteratör olucak
//eğer ekleme gerçekleşmemişse false,  iteratorüde var olan değeri olucak

//auto p = myset.insert(name); 
//pair<set<string>::iterator, bool> p = myset.insert(name); //bunlardan herhangi birini kullanabiliriz
auto [iter, inserted] = myset.insert(name); 

if (p.second) { //pair olduğu için first iteratör konumunu second true/false değerini tutar
std::cout << "ekleme yapildi...\n";
cout << "size = " << myset.size() << '\n';
cout << *p.first << "\n";
cout << "distance = " << distance(myset.begin(), p.first) << '\n';
print(myset);
}
else {
std::cout << name << "sette var\n";
cout << *p.first << "\n";
cout << "distance = " << distance(myset.begin(), p.first) << '\n';
}
}

-------------

int main()
{
using namespace std;

set<string> myset {"derya", "ceyhun", "nalan", "tekin"};
print(myset);

cout << "eklenecek ismi girin: ";
string name{};

cin >> name;

cout << "size = " << myset.size() << '\n';

auto iter = myset.insert("deniz").first;
myset.insert("deniz").first-> //bu şekilde işlemler yapabiliriz

------------
//eklemeyi aşağıdaki şekilde de yapabiliriz

int main()
{
using namespace std;

set<string> myset;

for (int i = 0; i < 20; ++i) {
myset.insert(rname());
print(myset);
(void)getchar();
}
}

------------

sette sorulan soru, ya var ya yok

multisette sorulan soru, ya yok ya n tane var

--------------

//aramaya yönelik sorulara bakıyoruz

int main()
{
using namespace std;

set<string> myset;

rfill(myset, 20, rname);
print(myset);
}

cout << "arancak isim: ";
string name{};

cin >> name;

if (auto iter = myset.find(name); iter != myset.end()) {
std::cout << "bulundu..." << *iter << "\n";
std::cout << distance : " << distance(myset.begin(), iter) << "\n";
}
else {
std::cout << "bulunamadi\n"
}
}

--------------

int main()
{
using namespace std;

set<string> myset;

rfill(myset, 10, rname);
print(myset);

cout << "aranacak isim: ";
string name{};

cin >> name;

if (myset.count(name)) { //eskiden böyle bir kullanım vardı, kaç tane olduğu sayılırdı

}

if (myset.contains(name) { //boolen döndürür cpp 20 ile geldi

}
}

-------------

int main()
{
using namespace std;

multiset<int> myset{2,2,2,25,6,7,7,7,7,9};

cout << myset.count(7); //geri dönüş değeri 7'den kaç tane var ise o olacak
}

-----------

int main()
{
using namespace std;

multiset<int> myset{2,2,2,2,6,7,7,7,7,9};

auto iter = myset.find(7);
auto n = distance(myset.begin(), iter);

cout << "n = " << n << '\n';
}

----------

int main()
{
using namespace std;

multiset<int> myset{2,2,2,2,6,7,7,7,7,9};

auto iterlower = myset.lower_bound(7); 
auto iterupper = myset.upper_bound(7); 

cout << distance(myset.begin(), iterlower) << '\n';
cout << distance(myset.begin(), iterupper) << '\n';
}

-----------

//setin silme fonksiyonları değerle silme de içeriyor

int main()
{
using namespace std;

multiset<int> myset{2,3,4,4,4,7,7,7,7,9};

print(myset);

myset.erase(myset.begin(), next(myset.begin());
myset.erase(myset.begin(), next(myset.begin(), 4); //bu şekilde de olur

print(myset);
myset.erase(prev(myset.end()));
print(myset);

}

----------

//değerle silme de vardır

int main()
{
using namespace std;

multiset<int> myset{2,3,4,4,4,7,7,7,7,9};

print(myset);

auto n = myset.erase(myset.begin(), next(myset.begin(), 4)); //ilk 4 sildi

}

----------

int main()
{
using namespace std;

multiset<int> myset{2,3,4,4,4,7,7,7,7,9};

print(myset);

auto n = erase(myset, 7); //cpp 20, 23 ile geldi
print(myset);
}


//////////////////////////////////////////// 2. Ders ////////////////////////////////////////

associative contanierslar tipik olarak binary search tree algoritmasını implemente ederler

ikili arama ağacı anahtarla erişimi logoritmik karmaşıklığa çevirir

set'in ağrılıklı uygulaması var mı? yok mu? uygulamasıdır

---------------

associative contanierslar'ın kafa karıştırıcı bir fonksiyonu

insert
------
konum ister normalde istememesi lazım ancak hint insert denilen bu yapı ile konum istenerek
daha iyi performans sağlanır, konum dğru ise gereksiz yere çalışmıycak yanlış ise bildiği konuma koyucak

int main()
{
using namespace std;

vector<string> svec {"eda", "naz", "tan" };
set<string> myset{"ayca", "berna", "derya", "meliha", "saliha" };

myset.insert(myset.begin(), "aliye"); //hint insert

copy(svec.begin(), svec.end(), inserter(myset, myset.begin()));

myset.emplace_hint(myset.begin(), 10, 'A'); //10 ve A argümanlarını perfect forwarding ederek nesneyi oluştur
}

---------------

modern cpp öncesi çok sorulan bir mülakat sorusu

int main()
{
using namespace std;

set<string> myset;
rfill(myset, 10, rname);
print(myset);

cout << "eski ve yeni ismi giriniz: ";
string old_name, new_name;
cin >> old_name >> new_name;

//sette mesela ali gitsin, yerine veli gelsin
//bu işlemi yaptır

//find ile bulup onu silip insert fonksiyonu ile yeni anahtar ekliyceksiniz

if (auto iter = myset.find(old_name); iter != myset.end()) { //myset end yazdırmayı dene son konum mu sondan bir sonra mı kontrol et
myset.erase(iter);
myset.insert(new_name);
std::cout << "anahtar degistirildi\n";
print(myset);
}
cout << "bulunamadi\n";
}

-------------------

yukarıdakinin yeni interface'i

//extrack: düğümün çıkarılması işlemini yapar
  
int main()
{
using namespace std;

set<string> myset;
rfill(myset, 10, rname);
print(myset);

cout << "size = " << myset.size() << '\n';
cout << "eski ve yeni ismi giriniz: ";
string old_name, new_name;
cin >> old_name >> new_name;

auto iter = myset.find(old_name);
auto handle = myset.extract(iter);
cout << "size = " << myset.size() << '\n';
(void)getchar();

if (handle.empty()) //handle boş olup olmadığına bu şekilde bakabiliria

handle.value() = new_name; //fonksyionun geri dönüş değerinin l value olduğu görülür, yani düğümdeki datayı döndürür
myset.insert(move(handle));

}


--------------

int main()
{
using namespace std;

set<string> myset;
rfill(myset, 10, rname);
print(myset);

cout << "size = " << myset.size() << '\n';
cout << "eski ve yeni ismi giriniz: ";
string old_name, new_name;
cin >> old_name >> new_name;

if (auto iter = myset.find(old_name); iter != myset.end()) {
auto handle = myset.extract(iter);
cout << "size = " << myset.size() << '\n';
(void)getchar();
handle.value() = new_name;
myset.insert(move(handle));
cout << "size = " << myset.size() << '\n'
print(myset);
}
else {
std::cout << "bulunamadi\n";  
}
}

----------

int main()
{
using namespace std;
rfill(myset, 20, Irand{0, 5});
print(myset);

auto iter = myset.lower_bound(3);

auto [iter.first, iter_last] = myset.equal_range(3);
}

--------------

unavalibel context'te lambda kullanılabiliyordu

int main()
{
using namespace std;

auto fcomp = [](int x, int y) {
return x % 100 < y % 100;
};

sizeof(decltype([]{})) //bu bir hata değil
}


----------
//yukarıdaki yapı sayesinde aşşağıdaki kullanılabilir

int main()
{
using namespace std;

set<int, decltype([](int x, int y) {
return x % 100 < y % 100;
}) > myset;
}

====================================================

MAP
----

sete insert ederken insert edilcek öğeyi geçeriz map'e pair geçmemiz lazım

first -> key
second -> value

map ve multimap seçimini doğru anlamak gerekir

mesela ingilizce türkçe sözlük için multimap kullanırız

-----------
1. template parametre : anahtarın türü
2. template parametre : o anahtara karşılık gelicek value türü
3. template parametre : karşılaştırma kriteri less key açılmını alır
4. template parametre : allocator'ın key const key açılımı

----------


int main()
{
using namespace std;

map<int, string> mx; //int değerlerinin küçükten büyüğe sıralanmasıyla olur

for (int i = 0; i < 10; ++i) {
mx.insert(pair{rand(), rname() });
}

for (const auto& p : mx) {
print("{:<12} {}\n", p.first, p.second);x
}
}

------------
//mülakatlarda sorulur

int main()
{
using namespace std;

map<int, string> mx; //int değerlerinin küçükten büyüğe sıralanmasıyla olur

for (int i = 0; i < 10; ++i) {
mx.insert(pair{rand(), rname() });
}

auto iter = mx.begin();

iter->fisrt = "furkanmert"; //hata, key değiştirilemez
const_cast<string&>(iter->fisrt) = "furkanmert"; //legal ancak ub
iter->second = 873443;

}

-------------

int main()
{
using namespace std;

map<string, int> mx{ {"deniz", 567}, {"ayca", 812}, {"yilmaz", 313}, {"deniz", 9999 }};

cout << "mx.size() = " << mx.size() << '\n';

}

----------

int main()
{
using namespace std;

map<string, int> mx{ {"deniz", 567}, {"ayca", 812}, {"yilmaz", 313}, {"bilge", 567 }}; // anahtardan birden fazla olabilir

cout << "mx.size() = " << mx.size() << '\n';

}

----------

mape öğe eklemenin yolları :

mape pair'ler eklenecek

int main()
{
using namespace std;

map<string, int> mx;

pair<string, int> p1{"tayfun", 767};

mx.insert(p1);
mx.insert(pair{"alican", 871});
mx.insert(pair{"veli", 219});
mx.insert(make_pair("deniz", 761));
mx.emplace("damla", 732);

//dolaşırken aşağıdakileri kullanabiliriz

for (auto iter = mx.begin(); iter != mx.end(); ++iter) {
print("{:<16} {}\n", iter->first, iter->second);
}

//... forrange

for (const auto& p : mx) {
print("{:<16} {}\n", p.first, p.second);
}
}

//... structure binding C++ 17, en çok bu kullanılır

for (const auto& [name, grade] : mx) {
cout << name << " " << grade << '\n';
}

-------------

int main()
{
using namespace std;

map<string, string> mymap;

for (int i = 0; i < 1000; ++i) {
mymap.emplace(rname(), rtown());
}

print(mymap, "\n");
}

------------

insert ile emplace farkı:
insert benden pair ister
emplace pair istemez

--------------

fonksiyonları :
-------------

int main()
{
using namespace std;

map<string, string> mymap;

for (int i = 0; i < 1000; ++i) {
mymap.emplace(rname(), rtown());

auto handle = mymap.extract("deniz");

handle.key; //keye erişir
handle.mapped; //mape erişir

}

--------------

int main()
{
using namespace std;

map<int, string>< mymap;

for (int i = 0; i < 10; ++i) {
mymap.emplace(Irand{0,100}(), rname());
}
print(mymap, "\n");

int key;

std::cout << "yasi girin: ";
cin >> key;

mymap[key] = "sadullah";
//mymap.at(key) = "sadullah"; //anahtar yok ise exception throw eder

print(mymap, "\n");
}

-----------

yukarıki yapının kullanıldığı idiyomatik bir yapı vardır

mülakatların fovori sorusudur

int main()
{
vector<string> svec;

rfill(svec, 10000, rname);

//her bir isimden kaç tane olduğunu bulmammız gerekiror ve bu bilgiyi bir yerde tutucaz

map<string, int> cmap;

for (const auto& name : svec) {
++cmap[name];
}

std::ofstream ofs{"out.txt"};
if (!ofs) {
std::cerr << "out.txt dosyasi olusturlamadi\n";
exit(EXIT_FAILURE);
}

for (const auto& [name, count] : cmap) {
print(ofs, "{:<18} {}", name, count);
}
}

------------

klasik bir mülakat sorusu daha vardır

//değerlerin sırasına göre yazmak istiyoruz

//vectöre taşıyarak yapabliriz

int main()
{
vector<string> svec;

rfill(svec, 10000, rname);

//her bir isimden kaç tane olduğunu bulmammız gerekiror ve bu bilgiyi bir yerde tutucaz

map<string, int> cmap;

for (const auto& name : svec) {
++cmap[name];
}

vector<pair<string, int>> myvec{cmap.begin(), cmap.end()};

sort(myvec.begin(), myvec.end(), [](const auto &p1, const auto& p2) {
return p1.second > p2.second;
});


std::ofstream ofs{"out.txt"};
if (!ofs) {
std::cerr << "out.txt dosyasi olusturlamadi\n";
exit(EXIT_FAILURE);
}

for (const auto& [name, count] : myvec) {
print(ofs, "{:<18} {}", name, count);
}
}

------------

int main()
{
using namespace std;

map<string,int> mymap;

for (int i = 0; i < 10; ++i) {
mymap.emplace(Irand{0, 70}(), rname());
}

print(mymap, "\n");

string old_key, new_key;

cout << "eski ve yeni anahtarları girin: ";
cin >> old_key >> new_key;

auto handle = mymap.extract(old_key)
if (handle) {
handle.key() = new_key;
cout << "anahtar degistirildi\n";
print(mymap, "\n");

};
}

-------------------

ödev:

int main()
{
using namespace std;

multimap<string, int> mymap;

string name{"deniz"};

//deniz key'leri icin value'lar birer arttırılıcak

}

--------

int main()
{
using namespace std;

multimap<double, int> mymap;

cout << typeid(mymap.key_comp()).name() << '\n';
cout << typeid(mymap.value_comp()).name() << '\n';

}

====================================================

hash table (çırpı tablosu) : bir çırpıda bulutyordan aklına gelsin
----------------------------

anahtarla arama yaparız ancak setten farklı olarak constant time' a çekmek istiyoruz

sette anahtarla arama logoritmik karmaşıklıkta, hast table'da amorties constant time'da

anahtarı indexe dönüştüren bir fonksiyon var

temel problem farklı anahtarları aynı index değerine hash edebilir

farklı anahtarlar aynı indexe eriştiğinde ikisininde erişmesini sağlamamız lazım

------

vectörde o indexli öğeye eriştiğimizde eğer o anahtarla çakışan başka bir anahtar yok ise bağlı listede 1 tane öğe olucak

eğer o anahtar yok ise bağlı liste boş olucak

eğer anahtar 3 taneye eriştiyse bağlı listede 3 tane olucak

bağlı listeleri tutan öğeler apit deniyo

int, double vs bütün türler için stl sağladığı hash fonksiyonunu kullanmalıyız

------

hash bütün türleri için explicit specilation sağlıyor

------
//int'leri hash ediceksin mesela

int main()
{
using namespace std;

hash<int> hasher;

size_t val = hasher(87562); //87562 hash değeri

cout << val << "\n"; //0 ile size_t max değeri arasında hash değeri üretiyor    


}

-------
//değerler biribiri ile alakasız çıkacaktır

int main()
{
using namespace std;

hash<int> hasher;

for (int i = 8'712'651; i < 8'712'690; ++i) {
print("hash value for {} is {}\n", i, hasher(i));
}
}

-------

int main()
{
using namespace std;

hash<string> hasher;

cout << hasher("deniz") << '\n';
cout << hasher("denis") << '\n';
cout << hasher("denizcan") << '\n';
cout << hasher("denizhan") << '\n';

-------

int main()
{
using namespace std;

int ival = 346369723;

cout << hash<int>{}(ival) << '\n';
}

---------

kendi sınıfımız için hasher oluşturmak istiyoruz
bunu yapmanın yollaru vardır

//en iyi seçenek boost::hash

struct DateHasher {
std::size operator()(const Date& dt)
{
std::hash<int> hasher;

return hasher(dt.month_day()) + hasher(dt.month()) + hasher(dt.year());
}
};

int main()
{
using namespace std;

Date mydate{17, 11, 2023 };

cout << DateHasher{}(mydate) << '\n';
++mydate;
cout << DateHasher{}(mydate) << '\n';
}

---------

2. bir yol

template <>
struct std::hash<Date> {
std::size operator()(const Date& dt)
{
std::hash<int> hasher;

return hasher(dt.month_day()) + hasher(dt.month()) + hasher(dt.year());
}
};

int main()
{
using namespace std;

Date mydate{17, 11, 2023 };

cout << DateHasher{}(mydate) << '\n';
++mydate;
cout << DateHasher{}(mydate) << '\n';
}

============================================

unordered_set

#include <unordered_set>

int main()
{
using namespace std;

unordered_set<int, hash<int>, equal_to<int>

unordered_set<Date> myset; //hata olur hash'in date açılımı yok

}

------------

class DateHasher {
std::size_t operator()(const Date&)const;

};

struct DateEqual {
bool operator()(const Date&, const Date&)const;
};

int main()
{
using namespace std;

unordered_set<Date, DateHasher> myset;
}

-------------

int main()
{
using namespace std;

auto flash = [](const Date&) { //hasher olarak burası
return 12u;
};

auto eq = [](const Date&, const Date&) { //karşılaştırma olarak burası kullanılır
return true;
};

unordered_set<Date, decltype(flash), decltype(eq)>
}

---------------

üye fonksiyonlara bakıyoruz

int main()
{
using namespace std;

unordered_set<int> myset(400); //400 tane buget ile başlasın demek

cout << myset.bucket_count() << "\n";
}

---------

int main()
{
using namespace std;

unordered_set<int> myset;

auto x = myset.hash_function();

}

--------

int main()
{
using namespace std;

unordered_set<string> myset;

for (int i = 0; i < 10; ++i) {
myset.insert(rname());
}

print(myset);

for (int i = 0; i < 10; ++i) {
string name; //derleyici bunun kolayca implemente edebilir. o yüzden içerde veya dışarda yazmamızım bir önemi yoktur içerde yazınca 10 kere ctor çağrılmaz
cout << "iism girin: ";
cin >> name;
if (auto iter = myset.find(name); iter != myset.end())
{

}
}
}

////////////////////////////////////////////// 3. Ders /////////////////////////////////////////

unordered_set yapıları sıralı değildir çünkü bu yapıların arkasında hash table veri yapısı vardır

hash_table : değerle erişmenin en kısa yoku, vektörel bir veri yapısı var arkada ve anahtarlarımız
bu anahtarlarımız bir hash fonksiyona ile indexe dönüşütürüyoruz
veri yapısı ile bu indexe erişim sağlıyoruz.

iyi bir hash fonksiyonu farklı anahtaeları farklı değerlere hash eder. bu çakışmayı azaltır

4 tane ayrı contanier vardır

bucket : her bir veri yapısına denir

yeteri kadar yüklendiği zaman bucket sayısı artıcaktır

--------------------

eğer default template argümanını seçersek o zaman equal to kullanılıyor o da '==' karşılaştırması yapıyor
başka bir karşılaştırma yapmak istiyorsak 3. parametre başka bir parametre gelicekç.

--------------------
kendi hasherimizi yapmak

struct Point {

Point() = default;
Point(double, double, double);
double mx{}, my{}, mz{};
};

int main()
{
using namespace std;

unordered_set<double> myset;

myset.insert(Point{2.3, 5.6, 78.9}); //sentaxx hatası olur hasher yok equal to ya cevap vermiyor

}

------------

//yukarıdakin kodun düzeltilmesi

struct Point {

Point() = default;
Point(double, double, double);
bool operator == (const Point&)const; //== kısmı
double mx{}, my{}, mz{};
};

template<> //hash kısmı
std::hash<Point> {
struct std::hash<Point> {
std::size_t operator()(const Point&)const  
{
std::hash<double> hasher;
return 
hasher(pt.mx) + hasher(pt.my) + hasher(pt.mz);  

}
};


int main()
{
using namespace std;

unordered_set<Point> myset;

myset.insert(Point{2.3, 5.6, 78.9}); 

}

-------------------

yukarıdaki gibi bir specialition oluşturmak istemiyorsak kendi türümüzü kendimiz oluştururuz

struct Point {
Point() = default;
Point(double, double, double);
bool operator == (const Point&)const; //== kısmı
double mx{}, my{}, mz{};
};

class PointerHasher {
std::size_t operator()(const Point&)const  
{
std::hash<double> hasher;
return hasher(pt.mx) + hasher(pt.my) + hasher(pt.mz);  
}
};


int main()
{
using namespace std;

unordered_set<Point, PointHasher> myset;

myset.insert(Point{2.3, 5.6, 78.9}); 

}

------------

//eşitlikte ayrı bir tür olabilir

struct Point {
Point() = default;
Point(double, double, double);
bool operator == (const Point&)const; //== kısmı
double mx{}, my{}, mz{};
};

class PointerHasher {
std::size_t operator()(const Point&)const  
{
std::hash<double> hasher;
return hasher(pt.mx) + hasher(pt.my) + hasher(pt.mz);  
}
};

struct PointEqual {
public:
bool operator()(const Point &, const Point&)const;
};

int main()
{
using namespace std;

unordered_set<Point, PointHasher, PointEqual> myset; //bu sefer 3. parametreye PointEqual geçilir

myset.insert(Point{2.3, 5.6, 78.9}); 

}

------------------

boost'un hash val fonksiyonunu kullanılması

struct Point {
Point() = default;
Point(double, double, double);
bool operator == (const Point&)const; //== kısmı
double mx{}, my{}, mz{};
};

class PointerHasher {
std::size_t operator()(const Point&)const  
{
return hash_val(pt.mx, pt.my, pt.mz);
}
};

struct PointEqual {
public:
bool operator()(const Point &, const Point&)const;
};

int main()
{
using namespace std;

unordered_set<Point, PointHasher, PointEqual> myset; //bu sefer 3. parametreye PointEqual geçilir

myset.insert(Point{2.3, 5.6, 78.9}); 

}

-----------------
//belli bir sıraya göre yazmaz
  
int main()
{
using namespace std;

unordered_set<string> myset;

for (int i = 0; i < 100; ++i)
{
myset.insert(rname() + ' ' + rfname())
}


for (const auto& name : myset) {
ofs << name << '\n'
}

cout << "aranacak ismi girin: ";
string name;
cin >> name;

}

---------------
aşağıdaki kodlar çok kötü bir kod
initialation asignment split'den uzak dur

string str;

str = 

////

T tx;

tx =

////

const T tx;

tx = 

/// aşağıdaki şekilde olur

const T tx = 
--------------

//hoca bir tablo oluşturuyor aşağıda, fonksyionlar daha iyi anlaşılcak

int main()
{
using namespace std;

unordered_set<string> myset;

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

//myset.max_load_factor(0.82); //max load değiştirme yeri

std::ofstream ofs{ "out.txt" };
if (!ofs) {
std::cerr << "out.txt dosyasi olusturulamadi\n";
exit(EXIT_FAILURE);
}

ofs << "bucket count = " << myset.bucket_count() << '\n';
ofs << "size          " << myset.size() << '\n';
ofs << "load factor = " << static_cast<float>(myset.size() / myset.bucket_count() << '\n';
ofs << "load factor = " << myset.load_factor() << '\n'; //load factörü veren fonksiyon
ofs << "max load factor = " << myset.max_load_factor() << '\n'; //degistirebiliceğimiz parametrelerden biridir, düşük olursa daha çabuk rehase yapılır

//bucket'lar dolaşılabiliyor

for (size_t i{}; i < myset.bucket_count(); ++i) {
print(ofs,"{:<6} {:<4}  ", i, myset.bucket_size(i));
for (auto iter = myset.begin(i)); iter != myset.end(i);    //her bir buckettaki öğeleri yazdırıyoruz
print(ofs, "{:18}", *iter);
}
ofs << '\n';
}

// myset.rehash() // bucket rehash eder
// myset.reserve() // öğe sayısı bu noktaya gelince rehash eder

------------------------

int main()
{
using namespace std;

unordered_set<string> myset;

for (int i = 0; i < 100; ++i) {
myset.insert(rname());
}

std::cout << "ismi girin: ";
string name{};
cin >> name;

if (myset.contains(name)) {
std::cout <<"bucket: " << myset.bucket(name) << "\n";
}
else {
std::cout << "bulunamadi\n";
}
}

-------------

int main()
{
using namespace std;


vector <int> ivec;
rfill(ivec, 100'000, Irand{0, 100});

unordered_map<int, int> cmap;

for (const auto val : ivec)
++cmap[val];
vector<pair<int, int>> myvec{cmap.begin(), cmap.end() };
sort(myvec.begin(), myvec.end());

if (!ofs) {
std::cerr << "out.txt dosyasi olusturulamadi\n";
exit(EXIT_FAILURE);
}

for (const auto [value, count] : cmap) {
print("{:<8}{}\n", value, count); 
}

}

===================================================

stl'in en önemli ve en zor başlık dosyalarından birini bakıyoruz

functional:
-----------

function adaptor (fonksiyon uyumlandırıcısı)
----------------

bizden collable alıp collable verir
!!pc'de fotosu var

bir çok function kaldırıldı cppref'den kontrol et

kalan fonksiyonlar:

reference_wrapper

std::bind
mem_fn
not_fn
std::invoke

-----------

int main()
{
int x = 10;
int y = 45;

int& r = x; //r ref. x' e bağlandır

r = y; //r ref. y' e bağlanmadı, x = y demektir
}

-----------

int main()
{
int* p[20];

std::vector<int *> myvec;
}

---------

int main()
{ 
int& p[20]; //referans olan dizi olamaz

std::vector<int*> myvec; //legal

std::vector<int&> myvec; //illegal

}

---------

//referans gibi olan bir sınıf oluştursaydım

class ReferenceWrapper {
  
};

int main()
{
std::vector<ReferenceWrapper> myvec;
}

----------
//bu kımı tam anlamadım
//nesneleri refernasmış gibi bir sınıf oluştursaydım
//refernas gibi olan nesneler tutuyoruz

template <typename T>
class ReferenceWrapper {
public:
ReferenceWrapper(T &t) : mp{ &t } {};

ReferenceWrapper& operator=(T& t)
{
mp = &t;
}

operator T&()
{
return *mp;  
}

T& get() //örtülü olarak kullanılmadığı yerde bu kullanılır
{
return *mp;
}

private:
T *mp;
};

template <typename T>
void func(T x)
{

}

template <typename T>
ReferenceWrapper<T> Ref(T& x) //bunun sayesinde sadece ref yazmak yeterli olacak
{
return ReferenceWrapper<T>{x};
}

int main()
{
int x = 12;

ReferenceWrapper<int> r(x);

cout << r;  

//bu kodun legal olmasının sebebi örtülü dönüşüm yapılması

string str(100'000, 'a');
func(str);
func<string&> (str) //böyle olmasını nasıl sağlarız 
func(ReferenceWrapper<string>(str)); 

int x = 79;

ReferenceWrapper r = x; //böyle bir kod yazılabilir mi? CTAD ile evet


}

Böyle bir sınıfın avantajları
-contanierlarda tutulur
-reindeble yaparım

----------------
//ReferenceWrapper ile örnek veriyoruz

#include <fuunctional>

template <typename T>
void foo(T x) //parametre ref değil o yüzden 20 yazar
{
x += 100;
}

int main()
{
int ival = 20;

int& r = ival;

foo(r);

cout << "ival = " << ival << '\n';
}

-----------

template <typename T>
void foo(T x) 
x += 100;
}

int main()
{
int ival = 20;

int& r = ival;

foo<int &>(r);
foo(ReferenceWrapper<int>{ival}); //bu şekilde de yazar
foo(ReferenceWrapper{ival}); //cidat gerçekleşir
foo(ref(ival)); //fabrika fonksiyonunu çağırabiliriz  

cout << "ival = " << ival << '\n';
}

------------

mülakatlarda çok sorulur

//ReferenceWrapper kullanıldığı tipik bir yerdir

struct BigPred {
bool operator()(int)
{

return true;
}

char buf[2 * 4096]{};
};



int main()
{
using namespace std;

BigPred pred;

vector<int> ivec(100'000);
vector<int> destvec;

copy_if(ivec.begin(), ivec.end(), back_inserter(destvec), pred); //bellek bloğu kopyalanır 

//code review yapmamız isteniyor

copy_if(ivec.begin(), ivec.end(), back_inserter(destvec), ref(pred)); //yüksek bellek bloğunun kopyalanmsı engellenmiş oldu


}

--------------------
#include <algorithm>

int main()
{
using namespace std;

vector<int> ivec(100);

generate(ivec.begin(), ivec.end(), [] { return rand() * 2; }); ); //vectorun range'ini foo geri dönüşü ile doldurdu
}

----------------

int main()
{
using namespace std;
mt19937 eng;

vector<unsigned int> uvec(10'000);
std::cout << "sizeof(eng) = " << sizeof(eng) << "\n";

generate(uvec.begin(), uvec.end(), ref(eng)); //kopyalamdan kurtulmuş olduk

}

--------------
//CTAD

int main()
{
using namespace std;

string name{ "necati ergin" };

std::list<string> mylist{"kutay", "tarik", "cemal", "melike", "damla", "tamer", "burak"};
print(mylist);

vector<string> myvec{mylist.begin(), mylist.end()};

vector<reference_wrapper<string>> myvec{ mylist.begin(), mylist.end() };

sort(myvec.begin(), myvec.end(), [](auto r1, auto r2) {
return r1.get() < r2.get();
});

for (const auto & s : myvec) {
cout << s.get() << " "; 
}

print(mylist)
}

----------------

int main()
{
using namespace std;

string name{ "necati ergin" };

std::list<string> mylist{"kutay", "tarik", "cemal", "melike", "damla", "tamer", "burak"};
print(mylist);
vector<reference_wrapper<string>> myvec{ mylist.begin(), mylist.end() };

mylist.sort();

}

-----------

int main()
{
using namespace std;

int x = 345, y = 469;

pair p(x, y);

p.first *= 10;
p.second *= 10;

cout << "x = " << x << '\n'; //345
cout << "y = " << y << '\n'; // 469

}

-----------

int main()
{
using namespace std;

int x = 345, y = 469;

pair<int&, int&> p(x, y); //bu yazım zorluğunu ortadan kaldrımak için aşağıdaki kullanılır

p.first *= 10;
p.second *= 10;

cout << "x = " << x << '\n'; //3450
cout << "y = " << y << '\n'; //4690

}

----------

int main()
{
using namespace std;

int x = 345, y = 469;

pair p(ref(x), ref(y));

p.first *= 10;
p.second *= 10;

cout << "x = " << x << '\n'; //3450
cout << "y = " << y << '\n'; //4690

}

---------------

referance wrapper r value bağlanamaz

int foo();

int main()
{
using namespace std;

referance_wrapper<int> x = foo(); //r value olduğu iiçn sentax hatası
}

--------------

//referance_wrapper incomplete içinde kullanılabilir

class Myclass;

void func(std::referance_wrapper<Myclass>);

int main()
{
using namespace std;

referance_wrapper<int> x = foo();
}

--------------

// bazı yerlerde tür dönüştürme otomatik devreye girer

int main()
{
using namespace std;

int x = 10;
int y = 45;

reference_wrapper r{ x };

++r;
r = y; // x = y demek değildir, atama reindendıble
++r; //r ve y nin adreslerini tutuyor r artarsa x ve y artar 

cout << "x = " << x <<"\n";
cout << "y = " << y <<"\n";

}

------------

int main()
{
using namespace std;

int x = 10;
int y = 45;

referance_wrapper r{ x };

r = y;

r.get() = y; //

cout << "x = " << x << '\n';
}

------------

int main()
{
using namespace std;

int x = 456;

auto r = cref(x); //const açılımı

r.get() = 6787;
}

------------

int main()
{
using namespace std;

int x = 456;

reference_wrapper<int> r = x; //ikisi aynı anlamda
auto r2 = ref(x);

reference_wrapper<const int> r3 = x; //ikisi aynı anlamda
auto r2 = cref(x);

}

==================================================

//zor bir konu

std::bind
---------

--------------

int foo(int x, int y, int z)
{
std::print("x = {} y = {} z = {}\n", x, y, z);
}

int main()
{
using namespace std;

auto f = bind(foo, 10, 20, 30);

f(); //f'i o şekilde çağırmayı sağlar
}

---------------

int main()
{
using namespace std;
using namespace placeholders;

auto f = bind(foo, 10, 20, _1);

f(99); 
}

--------------

int main()
{
using namespace std;
using namespace placeholders;

auto f = bind(foo, 10, _1, 20);

f(99); 
}

--------------

int main()
{
using namespace std;
using namespace placeholders;

auto f = bind(foo, _1, _1, _1);

f(99); 
}

--------------

int main()
{
using namespace std;
using namespace placeholders;

auto f = bind(foo, _1, 77, _2);

f(1, 5); 
}

------------

int main()
{
using namespace std;
using namespace placeholders;

auto f = bind(foo, _3, _1, _2);

f(10, 20, 30); 
}





