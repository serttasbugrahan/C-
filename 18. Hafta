///////////////////////////////////////////////////// 1. Ders ///////////////////////////////////////////////

tekrar

standart kütüphanenin operatör new fonksiyonu yerine kendi operatör new fonksiyonumu
yazabiliriz. 2 şekilde yapılır

-overload yazmak (1 tanesi hariç)
-sınıf için otomatik new ve delete fonksiyonu yazmak

eğer std::bad_alloc etmesini istemessek, fonksiyon yazıp set_new_handler ile kayıt edip, operatör new başarısız olduğunda fonksiyon çağırılacak


fonksiyonumuzun yapabiliceği birden fazla şey vardır
1- operator new başarılı olacağı seneryo oluşturur
2- başka bir fonksiyona delege eder
3- daha özel bir bad_alloc türüne exception throw edebilir
4- set_newhandlera nullptr ile çağrı yapar, operator new bad_alloc throw eder


------------------

delete ptr //ne yapar

önce operandı olan sınıf için dtor çağırır
sonra operator delete'e adresi geçer

-----------------------------------------------

//çok temel mülakat sorusu

malloc çağırılıyorsa free
new ise delete kullanılır

---------------------

new türleri:
------------

New T : yalın new
-----

class Nec {
public:
Nec();
Nec(int);
Nec(int, int);
Nec(const char*);

};

int main()
{
auto p1 = new Nec;
auto p2 = new Nec{}; //hepsi kullanılabilir
auto p3 = new Nec()
Nec* p4 = new Nec();
Nec* p4 = new Nec(234);
auto p5 = new const Nec(234);

}

-------------------

array new
---------
!! array new array delete ile delete edilir
!! array new ile oluşturulan yalın delete ile delete edilmesi ub

class Nec {
public:
Nec()
{
std::cout << "nec default ctor this = " << this << '\n';
}

~Nec()
{
std::cout << "nec default dctor this = " << this << '\n';
}

private:
unsigned char buf[256]{};
};

int main()
{
std::size_t n;

std::cout << "kac nesne : ";
std::cin >> n;

Nec* p = new Nec[n]; //dizinin her elemanı için ctor çağrılır

delete[] p; //bu şekilde olur
//delete p; //ub
}

---------

!! new ve delete modern c++ da çok nadir kullanılır, smart_pointer yerini almıştır

---------

placement new
-------------
// dikkat bu argümanlar ctora değil, operator new fonksiyonuna geçer
//bu şekilde kullanılan ifadelere placement new denir

new(x, y, z)Myclass ; //x,y,z argümanlarını gönder myclass sınıfın ctor çağır

-----------

void* operator new(std::size_t count, void* ptr); //bu overload edilemez

void* operator new(size_t, void* ptr)
{
return ptr;
}
bu fonksiyon ne yapar : bir adres yazarız bu adresi 2. parametreye gönderir, 1. parametrey sizeof gönderir

!! sadece fonksiyona geçtiğimiz adresin geri döndürülmesine 
ve böylece sınıf nesnesinin bizim verdiğimiz adreste hayata getirilmesini sağlar

istediğim bir adreste sınıf nesnesi oluşturabilirim, new ile neseyi hangi adreste oluşturmak istiyorsak o adresi ister
----------

class Nec {
public:
Nec()
{
std::cout << "nec default ctor this = " << this << '\n';
}

~Nec()
{
std::cout << "nec default dctor this = " << this << '\n';
}

private:
unsigned char buf[256]{};
};

int main()
{
unsigned char buffer[sizeof(Nec)];

std::cout << "buffer dizisinin adresi: " << static_cast<void*>(buffer) <<  '\n';

auto p = new(buffer)Nec
//Nec* p =

//delete p; //ub

//destructor ismi ile çağrılabilir

p->~Nec();
}
}

------------

void* operator new(size_t n, int x, int y)
{
std::cout << "my operator new called! n = " << n << "\n";
std::cout << "x = " << x  << '\n';
std::cout << "y = << y << '\n';

return std::malloc(n);
}

class Nec {
public:
Nec()
{
std::cout << "nec default ctor this = " << this << '\n';
}

~Nec()
{
std::cout << "nec default dctor this = " << this << '\n';
}

private:
unsigned char buf[256]{};
};

int main()
{
Nec* ptr = new(10, 20)Nec; //1. parametreye sizeof alır
}

---------------

int main()
{
using namespace std;

vector<Date> datevec;
datevec.emplace_back(12, 5, 1987); //placement new ile ilgili(emplace_back)
// 
}

---------------

başka bir new operatorü
-------------

void* operator new(std::size_t count, const std::nothrow_t& tag);

//1 tane argüman alır, size_t argüman almaz
//başarısızlık durumunda exception throw etmez, nullptr döndürür
//exception gönderilmesi uygun olmayan kısımlar içindir

int main()
{
using namespace std;

//nothrow_t
auto p = new(nothrow)Date{1,4,1987};

if (!p) {


}
} 

--------------------------------------------

neden new doğrudan kullanmak çok sakıncalı :

// Date *p;

//p
1- dinamik/ömürlü/statik ömürlü bir nesneyi mi gösteriyor? -bilemeyiz
2- nulptr değerinde mi? -bilemeyiz
3- delete etmeli miyim? -bilemeyiz
4- hangi delete ifadesini kullanmalıyım? -bilemeyiz
5- sadece delete yeterli mi? -bilemeyiz  

--------------

dinamik ömürlü nesneler için hangi hatalar yapılabilir ?

-dinamik ömürlü nesnenin adresini başka pointerlara kopyalama

Date *p1 = new Date(1, 4, 1987);

Date* p2 = p1;
//ya biri delete edilirken 2. dangling olucak
//delete edilmemesi

-----

-delete fonksiyonun exception nedeninden görülmemesi

void func()
{
auto p = new vector{2,4,7,9,1};

//foo(); //exception throw edebilir
//bar(); //exception throw edebilir

delete p;
}

int main()
{

}

==========================================================

yukarıdaki sorunların çoğunu akıllı pointer sınıfı ile çözebiliriz

-----------------------

smart pointer nesnelerin veya kaynakların ömrünü kontrol etmeye yarar

smart pointer dinamik ömürlü nesne kullanımını kolaylaştırır ve hata riskini azaltır

extra hiç maaliyeti yoktur

---------------------

eskiden auto_ptr vardı o çok başarısıs bir sınıfmış

------------------

2 tane smart pointer vardır

-unique_ptr
-shared_ptr
  -weak_ptr (doğrudan akıllı pointer değildir, shared yardımıcısı gibidir)

----------

unique_ptr : bir kaynağı/nesneyi sadece bir pointer gösterir başka pointer göstermesi yasaklanır
---------

-kopyalamaya kapalıdır, taşımaya açıktır

-başkasına devredebilir, nesnesin sahibi el değiştirebilir ancak tek sahibi olur her zaman

-unique_ptr kullanma oranı daha yüksektir

----------

shared_ptr : bir nesneyi gösteren birden fazla pointer olabilir
--------- 

-mesela nesnenin 3 tane pointer sahibi var hepsi hayatı sonlannırken sona kalan nesnenin hayatını bitirir


---------

eğer dinamik ömürlü nesnesin tek bir sahibi olmasını istiyorsam unique_ptr sınıfı türünden nesne ile onu yöneticem

farklı farklı kodların o nesneye erişimini sağlamak istiyorsam shared_ptr kullanıcam

-------------------------

#include <memory>

//normalde aşağıdaki gibi olmasını bekleriz ama öyle değildir

template <typename T>
class UniquePtr {
public:

~UniquePtr()
{
if (mp)
delete mp; //böyle olsaydı UniquePtr ile hayatlarını kontrol ettiğim nesnelerin hepsinin delete ifadesi ile bitirilmesi gerekirdi
}

private:
T* mp;
};

------------------

//yukarıdaki yapı yerine

template <typename T>
struct DefaultDelete {
void operator()(T* p)
{
delete p;
}
};

//D ==> deleter param
template <typename T, typename D = defaultDelete<T>>
//unique_ptr int açılımı aslında int, default_delete int açılımı

class UniquePtr {
public:

~UniquePtr()
{
if (mp) D{}(mp);
//delete mp; //yukarıdaki ifadeye dönüşür
}
private:
T* mp;
};

---------------------

//orjinali

int main()
{
using namespace std;

unique_ptr<Date> up1; //Date* sarmalar
unique_ptr<string> up2; //string* sarmalar

//unique_ptr 2 state'de olabilir
//1- boş olması, unique_ptr var ancak nesne yok ortada
//2- dolu olması, hayatı devam etmekte olan nesneyi sarmalar

//boş bir unique_ptr nesnesi 
//default init olabilir, unique_ptr<string> up2, hiçbir kaynak üstlenmemiş
//yani up dtor çağırıldığı zmaan hiçbir dtor çağrılmaz
}

-----------------

int main()
{
using namespace std;

unique_ptr<Date> up;

//boş mu dolu mu olduğunu operator bool fonksiyonu ile tespit ederiz
//boş olup olmamsı 3 yolla belirlenir
//1

if (up) {
//if (up.operator bool()) yazabilirdik
std::cout << "dolu\n";
}
else {
std::cout << "bos\n"; 
}
}

------------

//cout << (up ? "dolu" : "bos")

int main()
{
using namespace std;
//2
unique_ptr<Date> up{new Date{1,4, 1987}};

cout << (up ? "dolu" : "bos") << "\n";

}

------------

int main()
{
using namespace std;
//2
unique_ptr<Date> up{new Date{1,4, 1987}};

if (up == nullptr) {}
if (up != nullptr) {}
if (up.get()) {}
if (up.get() == nullptr) {}
}

-------------

//unique ptr dolu yapıcaz en tipik  yollarından birisi T* ctor yapmak

int main()
{
using namespace std;

unique_ptr<Date> up{new Date{1,4, 1987}};

//unique_ptr pointer gibi kullanılmasını sağlayan 2 tane şey var 
//1) *up

cout << *up << '\n';

//2) up->
cout << up->month_day() << "\n";

}

-------------

!! unique_ptr boş ise direferencing operatörünün operandı yapmak exception throw etmez, ub


int main()
{
using namespace std;

unique_ptr<Date> up;

try {
cout << *up << '\n'; //Ub
}
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n';
}
}

---------------

class Myclass {
public:
Myclass()
{
std::cout << "Myclass default ctor this = " << this << "\n";
}

~Myclass()
{
std::cout << "Myclass destructor this = " << this << "\n";
}
};

int main()
{
std::cout << "main basladi\n";
{
std::unique_ptr<Myclass> uptr{new Myclass};
} //delete edilecek burada
std::cout << "main devam ediyor\n";
}

---------------------------------

unique_ptr ile ilgili çok öenmli noktalar

1- unique_ptr sadece pointer sarmalar

2- unique_ptr exstra maaliyeti yoktur

------------

default ctor
T* ctor

make_uniqu
----------
unique_ptr falanca açılımı yerine MakeUnique çağırıp onun geri dönüş değeri ile argüman alabiliriz

template <typename T, typename ...Args>
std::unique_ptr <T> MakeUnique(Args&& ...args) //sonsuz parametre alabilir
{
return std::unique_ptr<T>(new T(std::forward<Args>(args)...))
}

int main()
{
using namespace std;

unique_ptr<Date> uptr{new Date{3, 5, 189}};
auto up = MakeUnique<Date>(3, 5, 1989);
}

-----------------

//orjinali

int main()
{
using namespace std;

unique_ptr<Date> uptr{new Date{3, 5, 189}};
auto up = make_unique<Date>(3, 5, 1989);
}

----------------------------------
//unique_ptr ile ilgili legal ve illegal yapılar

1) 

void foo(std::unique_ptr<std::string> up);

int main()
{
//parametresi unique_ptr olana T* geçemeyiz
foo(new std::string{"necati"]}); //illegal, ctor explicit, çünkü örtülü dönüşüme izin vermez

}

---

void foo(std::unique_ptr<std::string> up);

std::unique_ptr<std::string> bar()
{
return new std::string;
}

int main()
{
foo(new std::string{"necati"]}); //hata ctor explicit
}

-----------
2) 

// T* parametreli ctor var ancak T* atama operator fonksiyonu yok

int main()
{
using namespace std;

auto up = make_unique<Date>(2, 3, 1987);

cout << *up << "\n";

up = new Date{ 3, 6, 2003 }; //hata
}

-----------------------

!! unique ptr move only type, copy ctor veya copy assignment gereken yerlerde sentax hatası olur
copy olsa idi birden fazla kaynak gösterilebilecekti 

class Neco {
public:
Neco()
{
std::cout << "neco default ctor this = " << this << '\n';
}

~Neco()
{
std::cout << "neco default dtor this = " << this << '\n';
}

private:
unsigned char buffer[2048]{};
};

int main()
{
using namespace std;

unique_ptr<Date> x{new Date{}};

auto y = x; //copy ctor deleted
//unique_ptr y = x; //bu şekilde de olur
//unique_ptr<Date>z = x; //bu şekilde de olur

unique_ptr<Date> y{new Date{}};
unique_ptr<Date> x{new Date{}};
x = y; //hata
}

-------------

//çok sık yapılan bir hata

class Tamer {
public:
//dikkat sınıfın copy ctor, copy assignment deleted

private:
std::unique_ptr<Date> uptr;
};

int main()
{
Tamer tx;
Tamer tx;

tx = ty; //hata 
tx = std::move(ty); //legal

}

----------------

class Neco {
public:
Neco()
{
std::cout << "neco default ctor this = " << this << '\n';
}

~Neco()
{
std::cout << "neco default dtor this = " << this << '\n';
}

private:
unsigned char buffer[2048]{};
};

int main()
{
using namespace std;

{
auto up1 = make_unique<Neco>();
cout << "up1 = " << (up1 ? "dolu" : "bos") << '\n';
cout << "up2 = " << (up2? "dolu" : "bos") << '\n'; 

auto up2 = move(up1);

cout << "up1 = " << (up1 ? "dolu" : "bos") << '\n'; //up 1 boşa çıkar
cout << "up2 = " << (up2? "dolu" : "bos") << '\n'; 
(void)getchar();
}
std::cout << "main devam ediyor\n";

}

-----------

class Neco {
public:
Neco()
{
std::cout << "neco default ctor this = " << this << '\n';
}

~Neco()
{
std::cout << "neco default dtor this = " << this << '\n';
}

private:
unsigned char buffer[2048]{};
};

int main()
{
using namespace std;

//hem upx hemde upy dolu ise ne olur?
- upx önce kendi kaynağını delete eder
-upy kaynağı upx taşınır

//upx = std::move(upy);


}

----------------

taşıma semantiği ile ilgili sorular

std::unique_ptr<int> foo()
{
auto up = std::make_unique<int(24);

return up; // legal, otomatik ömürlü nesne return olursa l value to x value olur
//return move(up) //pesimistik move 
}

----------

void foo(std::unique_ptr<int>)
{

}

//r value geçebiliriz

int main()
{
using namespace std;

auto up = make_unique<int>(345);

foo(up); //hata, copy ctor deleted
foo(move(up)); //legal
foo(make_unique<int>(777)); //legal
foo(unique_ptr<int>(new int)); //legal, geçici nesne oluşturma ifadesi
}

---------------------------------

banko mülakat sorusu

-tanımsız davranış durumlarını tespit etmemiz

int main()
{
using namespace std;

auto p = new Date(3,5, 1987);

unique_ptr<Date> upx(p); //ub
unique_ptr<Date> upx(p); //ub

//2 unique_ptr'de aynı yapıyı sarmaladı tanımsız davranış var
}

-----

int main()
{
using namespace std;

auto p = new Date(3,5, 1987);

unique_ptr<Date> upx(p); 
{
unique_ptr<Date> upx(p); 
}
}

----------------------------

sınfın  birkaç tane önemli fonksiyonu var 
bunlardan bir tanesi

dinamik ömürlü nesneyi hayatını sonlandırıyor, unique_ptr dtor çağrılmasını beklemedne yapıyor

bunu yapmanın 3 tane yolu var

int main()
{
using namespace std;

auto up = make_unique<Date>(31,12,2023)
cout << "up = " << (up ? "dolu" : "bos") << '\n';

//delete edilmesini istiyoruz
up.reset(); //date için dtor çağrılır
up.reset(nullptr); //Bu şekilde de olur
up = nullptr; //Bu şekilde de olur
up = unique_ptr<Date>{}; //sağa taraf boş olduğu ve r value olduğu için yukarıdaki ile aynı etkiyi yapar
up = {}; //Bu şekilde de olur

cout << "up = " << (up ? "dolu" : "bos") << '\n';
}

-------

diğer fonksiyonlara bakıyoruz

int main()
{
using namespace std;

auto up = make_unique<Date>(31,12,2023)
cout << "up = " << (up ? "dolu" : "bos") << '\n';

up = new Date(1,1,2024); //bu hatayı düzeltmenin yolu vardır
up.reset(new Date(1,1,2024)); //legal olur
up = make_unique<Date>(1,1,2024); //aynı
}

-----------

sınıfın 3 tane fonksiyonunu birbiri ile karıştırma

int main()
{
using namespace std;

//up.reset();
//up.release(); //boşa çıkarır delete etmez

}

---------

int main()
{
using namespace std;

auto up = make_unique<Date>(31, 12, 2023);
cout << "up = " (up ? "dolu" : "bos") << '\n';

Date *p = up.release();
//dtor çağrılmaz
//boşa çıkar

cout << "up = 0 << (up ? "dolu" : "bos") << "\n";

delete p; //şimdi delete edildi
}

-----------

int main()
{
using namespace std;

auto up = make_unique<Date>(31, 12, 2023);
cout << "up = " (up ? "dolu" : "bos") << '\n';

auto x = move(up); //up boşaldı, x doldu, dtor çağrılmadı

unique_ptr<Date> x(up.relase()); //up boşaldı, x doldu, dtor çağrılmadı

}

///////////////////////////////////////// 2. Ders //////////////////////////////////////

class Myclass;

int main()
{
using namespace std;

unique_ptr<Myclass> //legal
}

kullanığımız fonksiyonların tekrarı :

uptr.release() //sarmaladığı adresi döndürür mülkiyeti bırakır, delete etmek gerekir

auto ptr = uptr.release()
auto ptr = uptr.get() //sarmaladığı adresi döndürüyor ne mülkiyeti bırakır ne de destroy eder

int main()
{
using namespace std;

auto uptr = make_unique<string>("alican korkmaz");

cout << uptr << "\n"; //sarmaladığı adresi çıkış akımına verir
cout << uptr.get() << "\n"; //aynı adres yazar

if (uptr) {}
if (uptr != nullptr) {}
if (uptr.get()) {} //hepsi aynı anlamda
if (uptr.get() != nullptr) {}
}

----------------

//hata yapılan bir yer

int main()
{
using namespace std;

auto uptr = make_unique<string>("alican korkmaz");

//auto p = uptr.release(); //hata olmaz
auto p = uptr.get(); //aynı pointerla 2 tane unique_ptr oluştumuş oluruz
//Bir tanesinin hayatı bittiğinde diğeri dangling pointer olur

unique_ptr<string> upx(p);
}

-----------------------------------------------------

deleter parametreye geçiyoruz

template <typename T>
struct DefaultDelete {
void operator()(T* p)
{
delete p;
}
};
//bu default delete yapısını değiştirerek custom edebiliyoruz


template <typename T, typename D = std::default_delete<T>>
class UniquePtr {

public:
~UniquePtr()
{
if (mp)
D{}(mp); //D sınıfının mp parametresi geçiyoruz
}
private:
T* mp;
};

-------------

struct SDeleter {
void operator()(std::string *p)const noexcept
{
std::cout << std::quoted(*p) << "delete ediliyor\n"; //daha sonra görüceğiz(quoted)
delete p;
}
};

int main()
{
using namespace std;
{
unique_ptr<string, SDeleter> uptr{new string{"tamer dundar"}};
}

std::cout << "main devam ediyor\n";
}

--------------

struct SDeleter {
void operator()(std::string *p)const noexcept
{
std::cout << std::quoted(*p) << "delete ediliyor\n"; //daha sonra görüceğiz(quoted)
delete p;
}
};

void fdeleter(std::string* p)
{
std::cout << std::quoted(*p) << "delete ediliyor\n"; //daha sonra görüceğiz(quoted)
delete p;
}

int main()
{
using namespace std;
{
unique_ptr<string, decltype(&fdeleter)> uptr{new string{"tamer dundar"}, fdeleter};
                  //-------------------
                  //direk bu türü de yazabiliriz
//unique_ptr<string, void(*)(string *)> uptr{new string{"tamer dundar"}, fdeleter};

//lambda expression olabilir
auto fdel = [](string* p) {
std::cout << std::quoted(*p) << "delete ediliyor\n"; //daha sonra görüceğiz(quoted)
delete p;
};
unique_ptr<string, decltype(fdel)> uptr{new string{"tamer dundar"}, fdel}; //cp20
}

std::cout << "main devam ediyor\n";
}

--------------
//unique ptr sadece new ifadelerini sonlandırmak için değildir
herhangi bir kaynağı sonlandırabiliriz

#include <cstdio>

int main()
{
using namespace std;

auto fdel = [](std::FILE* f) {
std::cout << "file is being closed!\n";
std::fclose(f);
};

{
std::unique_ptr<std::FILE, decltype(fdel)> uptr {fopen("melike.txt", "w"), fdel}; //cpp20 ile yazıyorsa fdel yazamaya gerek yok
fprintf(uptr.get(), "Melike Kaptan");
}//end scope

}

-----------------------

c++ daki ctor dtor karşılığı c 'de handle'dır

struct Data {

};

Data* createData(void);
void do_something(Data*);
void do_this(Data*);
void do_this(Data*);
void destroyData(Data*);

int main()
{
Data* handle = createData();
do_something(handle);
do_this(handle);
do_that(handle);
destroyData(handle);

//exception yakalansa da yine kaynak sızıntısı olucak
//buradaki problem unique_ptr ile çözülür
//clean up çağıran bir deleter oluşturulur
}

----------------
//unique_ptr sadece new ile alakalı değildir herhangi bir kaynağı sarmalayabiliriz, kaynak olmasına bile gerek yoktur
//buradan o sonuç çıkar

//güvenli şekilde c dizisini sarmaladık

struct Data {

};

Data* createData(void);
void do_something(Data*);
void do_this(Data*);
void do_this(Data*);
void destroyData(Data*);

int main()
{
auto fdel = [](Data* p) {
destroyData(p);
};

unique_ptr<Data, decltype(fdel)> uptr(createData());
do_something(uptr.get());

do_this(uptr.get());
do_that(uptr.get());
}

------------------
//burası biraz kafa karıştırıcı

struct Nec {
Nec()
{
std::cout <<" Nec default ctor this : " << this << '\n';
}
~Nec()
{
std::cout <<"Nec default dtor this : " << this << '\n';
}


char buf[256]{};
};

int main()
{
using namespace std;

unique_ptr<Nec> uptr(new Nec[4]);
//ub
//array new kullandıysak array delete kullanmamız lazım

//dilin aracı olmasaydı buunn için custom delete kullanırdık

auto fd = [](Nec* p) {delete[]p; };
unique_ptr<Nec, decltype(fd)> uptr(new Nec[4]);
*uptr //var, içerik var
uptr[2] // yok, index yok


//Yukarıdakini yapmaya hiç gerek yok bunun yerine unique_ptr partial spec.
unique_ptr<Nec[]> uptr(new Nec[4]);

*uptr //yok, içerik yok
uptr[2] // var, index var

}

-------------
//bu şekilde kullanılabilir

int main()
{
using namespace std;
unique_ptr<Date[]> uptr(new Date[4]);

for (int i = 0; i < 4; ++i) {
auto day = uptr[i].month_day();
}
}

-------------

//bu şekilde kullanılabilir

int main()
{
using namespace std;
unique_ptr<string[]> upx(new string[5]{"mert", "ali", "veli", "can", "bugra");

for (int i = 0; i < 5; ++i) {
cout << upx[i] << "\n";
}
}

-------------

struct Nec {
Nec()
{
std::cout << Nec default ctor this : " << this << '\n';
}
~Nec()
{
std::cout << Nec default dtor this : " << this << '\n';
}


char buf[256]{};
};

int main()
{
using namespace std;

auto up = make_unique<Nec[]>(5); //5 ctor, 5 dtor çağrılır
//unique_ptr<Nec[]> up = make_unique<Nec[]>(5);
}

---------------

int main()
{
using namespace std;

Date* p = new Date{4, 7, 1983}; //dinamik ömürlü nesne oluşturuldu
{
unique_ptr<Date> upx(p);
} //burada p dangling pointer
//p delete edilir, delete edilmesi demek bu noktadan sonra dangling pointer olması demektir
//p = nullptr; //bu gelirse unique_ptr boş olucak
(void)getchar();
unique_ptr<Date> upx(p); //dangling point

*upy //dref ettiğimiz için yine ub
}

---------------

//en çok kullanıcağımız yapılardan birisi unique_ptr contanierlarda tutmak
//smart pointer olmadan ne kadar zor olucağına dair bir örnek

int main()
{
using namespace std;
{
vector<Date*> dvec; //vector pointer açılımını oluşturduk
dvec.reserve(10); //10 kapasite oluşturduk

for (int i = 1; i <= 10; ++i) {
dvec.push_back(new Date{i, i, 2000 + i}); //10 tane dinamik ömürlü nesne adresi koyduk vektöre
}

//buraya gelindiğinde nesne delete olmaz operator delete çağrılmaz, dtor çağrılmaz
//doğru olması iiçn hayatı bitmeden vektörü dolaşıcak
for (auto p : dvec)
delete p;
}
dvec.erase(dvec.begin()); //vektörden 2 öğe sildik, burada ve aşağıda 
dvec.pop_back(); //dtor çağrılmadı
}

---------------
//unique_ptr dönüşütürüyoruz yukarıdakini 

int main()
{
using namespace std;
{
vector<unique_ptr<Date>> dvec;
dvec.reserve(10);

for (int i = 1; i <= 10; ++i) {
dvec.emplace_back(new Date(i, i, 2010 + i)); //vectore 10 tane dinamik ömürlü nesne koyduk
}

for (auto& up : dvec) { //copy ctor delete edildiği için auto up hatalı
cout << *up << '\n';
}

(void)getchar();
}
}

--------------

int main()
{
using namespace std;

auto uptr = vector<unique_ptr<Date>(1, 5, 1986);

dvec.push_back(uptr); //hata, L value

dvec.push_back(move(uptr)); //legal
}

------------

int main()
{
using namespace std;

vector<unique_ptr<Date>> dvec;

dvec.push_back(make_unique<Date>(1, 5, 1986)); //taşıma semantiği devreye girer
//legal, pr value expr
}

-----------

int main()
{
using namespace std;

vector<unique_ptr<Date>> dvec;

dvec.emplace_back(new Date{5,5,1965}); //legal
dvec.puch_back(new Date{5,5,1965}); //illegal, push_back'e unique ptr göndermem gerekir

dvec.push_back(unique_ptr<Date>{new Date{5, 5, 1965}}); //legal
}

-----------
//bu fonksiyon car* döndürmek yerine unique ptr car açılımı döndürebilir miydi
//onu yazıcaz alt kısımda

Car *createRandomCar()
{
    static std::mt19937 eng{std::random_device{}()};
    static std::uniform_int_distribution<int> dist{0, 6};

    switch (dist(eng))
    {
    case 0:
        return new Volvo;
    case 1:
        return new Audi;
    case 2:
        return new Tesla;
    case 3:
        return new Renault;
    case 4:
        return new Honda;
    case 5:
        return new Mercedes;
    case 6:
        return new HondaCivic;
    case 7:
        return new ModelX;
    }

    return nullptr;
}

int main()
{
using namespace std;


}

---------------

std::unique_ptr<Car> createRandomCar()
{
    static std::mt19937 eng{std::random_device{}()};
    static std::uniform_int_distribution<int> dist{0, 6};

    switch (dist(eng))
    {
    case 0:
        return std::make_unique<Volvo>();
    case 1:
        return std::make_unique<Audi>();
    case 2:
        return std::make_unique<Tesla>();
    case 3:
        return std::make_unique<Renault>();
    case 4:
        return std::make_unique<Honda>();
    case 5:
        return std::make_unique<Mercedes>();
    case 6:
        return std::make_unique<HondaCivic>();
    case 7:
        return std::make_unique<ModelX>();
    }

    return nullptr;
}

int main()
{
using namespace std;

for (int i = 0; i < 100; ++i) {
auto uptr = createRandomCar();
cout << *uptr << '\n';
uptr->start();
uptr->run();
uptr->stop();
(void)getchar();
}
}

-------------------

shared_ptr sınıfının unique_ptr parametreli ctoru var
dolayısıyla unique_ptr shared_ptr'a dönüşütürerek kullanabiliyoruz

yukarıdaki yapının geri dönüş değerini share_ptr' a verebiliriz
------------------

sink : mülkiyeti bir fonksiyona devretmek

void fsink(std::unique_ptr<Date> uptr)
{
std::cout << *uptr << '\n';

}

int main()
{
using namespace std;

fsink(make_unique<Date>(3, 6, 1987));
cout << "main devam ediyor\n";
}

--------------
//pass-through : fonksiyona nesneyi taşırızı aynı anda fonksiyonda geri dönüş değeri olarak bize nesneyi geri taşır

std::unique_ptr<Date> fsink(std::unique_ptr<Date> uptr)
{
std::cout << *uptr << '\n';

return uptr;
}

int main()
{
using namespace std;

{
auto cp = fsink(make_unique<Date>(3, 6, 1987));
cout << "main devam ediyor [1]\n";
(void)getchar();
}
cout << "main devam ediyor [2]\n";
}

=============================================================

shared_ptr
-----------

bir nesnenin  birden fazla sahibi olabilir, o nesneler o nesneyi paylaşımlı olarak kullanabilir
ama son shared_ptr sınıfı kaynağı geri vericek

//unique ile karşılaştırma işlemleri yapıyoruz

int main()
{

std::cout << "sizeof(unique_ptr<string>) = " << sizeof(unique_ptr<string>) << "\n"; //içinde 1 tane pointer tutar
std::cout << "sizeof(shared_ptr<string>) = " << sizeof(shared_ptr<string>) << "\n"; //içinde 2 tane pointer tutar

}
 
---------------

-control bloğu vardır

-shared ptr koyalamaya ve taşımaya açık

-adres hem shared_ptr nesnesinin içinde hemde control bloğu içinde tutuluyor 

-kontrol bloğunun ile shared ptr nesnesi oluşturulduğunda control block oluşturulması gerekiyor son shared ptr oluşturulduğundad da control bloğu oluşturulması gerekir
ve sonlanma işlemleri de aynı şekildedir

-unique ptr'ye göre bu nedenlerden daha maaliyetlidir

-yeni share_ptr hayata geldiğinde referans sayacı bir artıyor

-control bloğunda genel olarak deleter ve adres tutulur
--------------

template <typename T>
class SharedPtr {
//deleter sınıfın ctoruna argüman olarak geçiyoruz
//geçmessek default delete olur


};

int main()
{
using namespace std;
{
shared_ptr<Date> sp1(new Date{1, 2, 1999});

{
auto sp2 = sp1;
//dtor çağrılmaz çünkü 2 tane shared ptr vardı 1 tanesi hala hayatta
}

std::cout << "main devam ediyor [1]\n";
(void)getchar();
} //Burada 2. 'nin hayatı biter ve dtor çağrılır
std::cout << "main devam ediyor [2]\n";

}

----------------
//use_count : kullanılan sayaç

int main()
{
using namespace std;

shared_ptr<Date> sp1(new Date{1, 2, 1999});
cout << "use count = " << sp1.use_count() << '\n';
auto sp2 = sp1;
cout << "use count = " << sp1.use_count() << '\n'; //Hangi nesne ile alırsak alalım farketmez
cout << "use count = " << sp2.use_count() << '\n'; //Hangi nesne ile alırsak alalım farketmez

{
auto sp3 = sp2;
cout << "use count = " << sp1.use_count() << '\n';
cout << "use count = " << sp2.use_count() << '\n';
cout << "use count = " << sp3.use_count() << '\n';
}
cout << "use count = " << sp1.use_count() << '\n'; //2 ye düşer
cout << "use count = " << sp2.use_count() << '\n';
}

-----------------------------

void* operator new(std::size_t n)
{
std::cout << "operator new called n = " << n << '\n';
void *vp = std::malloc(n);
if (!vp) {
throw std::bad_alloc{};
}
std::cout << "the address of the allocated block is :  << vp << "\n";

return vp;
}

struct Nec {
char buf[512]{};
};

void foo()
{
std::cout << "foo cagrildi\n";
auto pnec = new Nec;
std::shared_ptr<Nec> sptr(pnec);
}

int main()
{
foo(); //source için ve control block için 2 kere operator new çağrılır çağrılır
}

---------------

aynı kaynağı gösteren shared_ptr nesneleri için aynı control bloğu kullanılır

--------------

//mülakatlarda çok sorulan bir soru

nasıl make_unique varsa make_shared içinde vardor

make_shared : shared ptr döndürür

void* operator new(std::size_t n)
{
std::cout << "operator new called n = " << n << '\n';
void *vp = std::malloc(n);
if (!vp) {
throw std::bad_alloc{};
}
std::cout << "the address of the allocated block is : " << vp << "\n";

return vp;
}

struct Nec {
char buf[512]{};
};

void bar()
{
std::cout << "bar cagrildi\n";
auto uptr = std::make_shared<Nec>;
}

int main()
{
bar();
}

//sadece 1 kere operator new cagrilir, derleyici optimizasyonudur
//make_shared sayesinde 2 ayrı blok yerine iksisini bir blok altına alan tek bir bloğunu allocate eder

---------------------

//type erasure (tür silme)  
//normalde ileri cpp kursunda anlatıyor

class Myclass{
public:
~Myclass()
{
std::cout << "Myclass dtor this :" << this << "\n";
}
};

struct MyclassDeleter {
void operator()(Myclass *p)const
{
std::cout << p << "the object at the address of " << p << "is being deleted\n";
delete p;
}
};

int main()
{
using namespace std;

{
shared_ptr<Myclass> sptr(new Myclass, MyclassDeleter{});
}
std::cout << "main devam ediyor\n";
}

//shared_ptr'de deleter ctor'a argüman olarak gönderiyoruz

---------------
//shared ptr 
-default ctoru var
-move ctoru var
-copy ctoru var

------------
//ne zmaan kontrol bloğu oluşturulur?
//shared ptr default ctor edilirse, kontrol bloğuna gerek yok
//kontrol bloğunun oluşturulması için ya nesne adresi ile share_ptr hayata  gelmeli
//unique_ptr share_ptr taşınması durumunda

int main()
{
using namespace std;

auto uptr = make_unique<Date>(1, 1, 2024);

shared_ptr<Date> sptr(move(uptr));
(void)getchar();
}

--------------

int main()
{
using namespace std;

{
shared_ptr<Myclass> sptr(new Date{1, 1, 2024});
auto sp2 = sp1;
auto sp3 = sp2;

cout << sp1.get() << "\n"; //get adresi döndürür
cout << sp2.get() << "\n";
cout << sp3.get() << "\n";
}

------------------

//boş mu dolu mu kontrolü

int main()
{
using namespace std;

shared_ptr<Date> sp;

cout << "sp = " << (sp ? "dolu" : "bos") << '\n';
}

-------------

int main()
{
using namespace std;

shared_ptr<Date> sp(new Date{5,6,1976});

cout << "sp = " << (sp ? "dolu" : "bos") << '\n';
}

---------------

int main()
{
using namespace std;

shared_ptr<Date> sp(new Date{5,6,1976});

sp. //inceke
}

------------

int main()
{
using namespace std;

shared_ptr<Date> sp1(new Date{5,6,1976});
shared_ptr<Date> sp2 = sp1;
shared_ptr<Date> sp3 = sp2;

cout << sp1.use_count() << '\n';
sp1.reset(); //son shared ptr değilse ref. sayacını azaltıyor
//sp1.reset(new );//bu şekilde de olur
cout << sp2.use_count() << '\n';
}

-----------

int main()
{
using namespace std;

shared_ptr<Date> sp1(new Date{5,6,1976});
shared_ptr<Date> sp2(new Date{1,1,1994});

cout << "use count for sp1 = " << sp1.use_count() << '\n';
cout << "use count for sp1 = " << sp2.use_count() << '\n';

sp1 = sp2;
(void)getchar();
cout << "use count for sp1 = " << sp2.use_count() << '\n';
}


-------------

void foo(std::unique_ptr<std::string>)

void bar(std::unique_ptr<std::string> & r)
{
r.reset(); //işlemi yapılabilir
}


//ikisi birbirinden farklıdır

------------

//shared ptr içinde bu geçerli

void bar(std::shared_ptr<std::string> & r) //ref sayac artaz
void bar(std::shared_ptr<std::string>  r) //ref sayac artar

////////////////////////////////////////// 3. Ders /////////////////////////////////////////////////////

tekrar
------

int main()
{
using namespace std;

shared_ptr<string> sptr(new string);

*sptr //gösterdiği nesneye erişiriz
//boş ise exception throw etmez

sptr.get() //sarmalana pointer get eder
sptr.reset() //hayatı sonlandırmıyor ancak refereance count 1 ise sonlandırır
if (sptr) //operator bool kullanılır
if (sptr.get())//nullptr kontrolü
}

==============================================

weak(zayıf)
------------

share_ptr'den weak_ptr nesnesi oluşturabiliyorum
share_ptr'den weak_ptr oluşturunca weak_ptr share_ptr referans sayacını arttırmıyor
bundan dolayıı ismi weak_ptr.


share_ptr kaynağın sonlanıp sonlanmadığını sınıyabiliyoruz

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';

weak_ptr wp(sptr);
//weak_ptr wp = sptr; //bu sınamayla bu ctor explicit olmadığını anlarız
cout << "sptr.use_count() = " << sptr.use_count() << '\n'; // 1 olur değişmez

}

---------------

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';
weak_ptr wp1 = sptr;
weak_ptr wp2 = sptr;
cout << "sptr.use_count() = " << sptr.use_count() << '\n';
cout << "sptr.use_count() = " << wp1.use_count() << '\n';
cout << "sptr.use_count() = " << wp2.use_count() << '\n';
auto wp3 = wp2;
cout << "wp3.use_count() = " << wp3.use_count() << '\n';
auto sptr2 = sptr; //burada ref sayacı artar
cout << "wp3.use_count() = " << wp3.use_count() << '\n'; 
}

--------------
//weak_ptr diref edilemez

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';
weak_ptr wp = sptr;

*wp //sentax hatası

if (we.expired()) { //bool döndürür
cout << "kaynak sonlandirilmis\n";
}
else {
cout << "kaynak halen hayatta\n";
}

}


-----------------

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';
weak_ptr wp = sptr;

sptr.reset(); //son kaynak sonlandır

if (we.expired()) { //true döndürür
cout << "kaynak sonlandirilmis\n";
}
else {
cout << "kaynak halen hayatta\n";
}

}

---------------

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';
weak_ptr wp = sptr;

wp.lock //shared ptr döndürür

shared_ptr<string> spx = wp.lock();
auto spx = wp.lock();
shared_ptr = wp.lock(); //CTAD
}

----------------

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';
weak_ptr wp= sptr;

//spt.reset(); //1 kaynak sonlanır

shared_ptr<string> spx = wp.lock();
if (spx != nullptr) {
cout << "kaynak sonlandirilmamis\n";
cout << spx.use_count() << '\n';  //2 döndürür
cout << *spx << "\n";
}
else {
cout << "kaynak sonlandirilmis;
}
}

weap_ptr diref edilmez ancak lock ile kullanılan 
shared_ptr diref edilir

---------------
//aşağıdaki şekilde de olur

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';
weak_ptr wp= sptr;

if (shared_ptr<string> spx = wp.lock()) {
//auto px = wp.lock()) //kullanılabilir
cout << "kaynak hayatta\n";
cout << "use_count " << spx.use_count() << '\n';
cout << "isim = " << *spx << "\n";
}
else {
cout << "kaynak sonlanmis\n";
}

------------------

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';
weak_ptr wp= sptr;

shared_ptr sp(wp); //kaynak sonlanmışsa exception throw eder
cout << "use_count = " << sp.use_count() << "\n";  
cout << "isim = " << *sp << "\n";
}

-------------

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';
weak_ptr wp= sptr;

sptr.reset();

shared_ptr sp(wp); //kaynak sonlanmışsa exception throw eder
cout << "use_count = " << sp.use_count() << "\n";  
cout << "isim = " << *sp << "\n";
}

--------------

int main()
{
using namespace std;

shared_ptr<string> sptr(new string{"bugrahan serttas"});

cout << "sptr.use_count() = " << sptr.use_count() << '\n';
weak_ptr wp= sptr;

sptr.reset();

try {
shared_ptr sp(wp);
}
catch (const std::bad_weak_ptr& ex) {
catch (const std::exception& ex) {
std::cout << "exception caught: " << ex.what() << '\n'; 
}

}

--------------------------

cyclic referans
--------------


struct B; //forward decleration

struct A {
std::shared_ptr<B> bptr;
//burası weak_ptr olsaydı hata olmazdı
A() {
std::cout << "A default ctor this = " << this << "\n";
}
~A() {
std::cout << "A destructor this = " << this << "\n";
}
};

struct B {
std::shared_ptr<B> bptr;
struct B {
B() {
std::cout << "B default ctor this = " << this << "\n";
}
~B() {
std::cout << "B destructor this = " << this << "\n";
}
};

int main()
{
using namespace std;

shared_ptr<A> spa(new A);
shared_ptr<B> spb(new B);

spa->bptr = spb;
spb->aptr = spa;
//dtor çağrılmaz

}

//saat 1 de köpekler ile ilgili örnek var


---------------------------------

shared_ptr önemli bir fonksiyonu daha var
biraz karışık

SRTP örüntüsünü bilmek gerekir

template <typename Der>
class Base {
void func()
{
//static_cast<Der*>(this);
static_cast<Der*>(this).foo(); //taban sınıflar türemiş sınıflara interface enjecte edip
//türemiş sınıfın fonksiyonlarını kullanabilir

}
};

class Der : public Base<Der> { //legal, 

};

-----------

bu kısmı hazır bir kod üzerinden anlatıyor

eğer bir sınıfın üye fonksiyonun içinde shared_ptr ile hayatı kontrol edilen * this nesnesini gösteren
shared_ptr'nin kopyasını çıkartmak isterseniz sınıfınızı 
CRTP örüntüsü ile kalıtım yoluyla std::enable_shared_from_this
sınıfından elde etmelisiniz

class Nec {

public:
void func()
{
shared_ptr<Nec> spx(this); //bu şekilde ref artmaz, ub olur
}
};

int main()
{
using namespace std;

shared_ptr<Nec> sptr(new Nec);

sptr->func();
}

---------------

class Nec {

public:
void func()
{
shared_ptr<Nec> spx(this); 
};

int main()
{
using namespace std;

Nec* ptr = new Nec;
shared_ptr<Nec> sp1(ptr);
shared_ptr<Nec> sp2(ptr); //ub olur

cout << sp1.use_count() << '\n';
cout << sp2.use_count() << '\n';

(void)getchar();
}

---------------

class Nec {

public:
void func()
{
shared_ptr<Nec> spx(this); 
cout << spx.use_count() << "\n"; //2 olmaz, ub olur
(void)getchar();
//bu kısmı nasıl yapıcaz peki?? altta kod var
}
};

int main()
{
using namespace std;


//func içinde bu fonksiyon hangi dinamik ömürlü nesne
için çağrıldıysa o dinamik ömürlü nesneyi gösteren share_ptr'nin 
kopyasını çıkartmak referance count 2 yapmak

shared_ptr<Nec> sptr(new Nec);
sptr->func();
}

------------
!! BU KISIMLARI TEKRAR İZLE 

using namespace std;


class Nec : public std::enable_shared_from_this<Nec>{
public:
void func()
{
auto spx = shared_from_this();
cout << "spx.use_count() = " << spx.use_count() << "\n"; //1
}
};

int main()
{
using namespace std;

shared_ptr<Nec> sptr(new Nec);

cout << "sptr.use_cont() = " << sptr.use_count() << "\n"; //2
sptr->func();
cout << "sptr.use_cont() = " << sptr.use_count() << "\n"; //1
}

----------------

using namespace std;


class Nec : public std::enable_shared_from_this<Nec>{
public:
void func()
{
auto spx = shared_from_this();
cout << "spx.use_count() = " << spx.use_count() << "\n"; //1
}
};

int main()
{
auto p = new Nec; //exception throw eder

p->func();
}

------------------------

aynı nesneyi birden fazla contanierda tutup ayrı işlemler yapabiliyoruz

#include <list>
#include<memory>
#include <iostream>
#include <vector>
#include <algorithm>
#include "date.h"

//vector ve list shared_ptr tutar aynı kaynağı gösterirler

using namespace std;

int main()
{
list<shared_ptr<Date>> mylist;

mylist.push_back(make_shared<Date>(2, 5, 1999));
mylist.push_back(make_shared<Date>(4,9,1993));
mylist.push_back(make_shared<Date>(22,11,1997));
mylist.push_back(make_shared<Date>(7,10,2004));
mylist.push_back(make_shared<Date>(12,12,1991));

vector<shared_ptr<Date>> myvec(mylist.begin(), mylist.end());

sort(myvec.begin(), myvec.end()); //adresleri sınar

sort(myvec.begin(), myvec.end(), [](auto p1, auto p2) {
return *p1 < *p2;
});

for (auto sp : myvec)
cout << *sp << "\n";
(void)getchar();
std::system("cls");

cout << "\n";

}

----------------------

programcıların karıştırma ihtimalinin yüksek olduğu nokta

class Myclass {

private:
std::vector<std::string> myvec; //non statşc member number, herbiri için ayrı olucak
//static std::vector<std::string> myvec; //bu şekilde hepsi aynı vectorü kullanılır
};

int main()
{
Myclass m1; //static olursa aynı vectörü kullanılır
Myclass m2;
Myclass m3;

//n tame myclass nesnesi 1 vektöü, diğerleri başka bir vektörü kullansın
//alttaki kodda cevabı

}

------------------

class Myclass {

private:
std::shared_ptr<std::vector<std::string>> myvec; 
};

int main()
{
Myclass m1; 
Myclass m2;
Myclass m3;

Myclass m4, m5, m6;
}

---------------

//kod 1.54. dakikada


----------------------------------------------------

operator new fonksiyonu overload edilebilir

overload edersek new çağrılan her yerde biizm fonksiyonumuz çağrılcak

----------

!! sınıfların için oluşturulan operator new fonksiyonlarının
operator delete fonksiyonların static anahtar sözcüğü kullanılmasa bile
sınıfın static fonksiyonudur

class Myclass {
public:
void* operator new(size_t n); //static
void operator delete(void *)noexcept; //static
};

------------
#include <cstdlib>

class Myclass {
public:
Myclass()
{
std::cout << "default ctor this : " << this << '\n';
}

~Myclass()
{
std::cout << "dtor this : " << this << '\n';
}

void* operator new(size_t n)
{
std::cout << "Myclass::operator new n : " << n << "\n";
auto p = std::malloc(n);
if (!p) {
throw std::bad_alloc{};
}
std::cout << "adress of the allocated block is" << p << '\n';
return p;
}

void operator delete(void *)noexcept;
{
std::cout << "Myclass::operator delete vp : " << vp << "\n";
std::free(vp);
}

void func()
{
std::cout << "Myclass func() this " << this << '\n';
}
private:
unsigned char buffer[512]{};
};

int main()
{
auto  p = new Myclass;

p->func()

delete p;
}

--------------------

//ders son 20 dk ödev veriyor ona bak

--------------------

::new //bu şekilde global olan çağrılır
::delete //bu şekilde global olan çağrılır

