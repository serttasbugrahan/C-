/////////////////////////////////////////////1. Ders/////////////////////////////////////////////////////

class hatırlatma:
----------------

class Nec {
public:
  void func(int);
};

int main(void)
{
Nec mynec;
auto p = &mynec;

//mynec.func(13);
(*p).func(34);
p->func(46); 
}

---------------------
protected : kalıtım ile işimize yarıycak

--------------------
// sınıfın üye fonksiyonları sınıfın private bölümüne erişebilir

class Nec {
public:
void func(Nec &r);
private:
int mx, my;
};

//nec.cpp
Nec gnec;
void Nec::func(Nec &r)
{
mx++;
r.mx = 56;
--gnec.my;
}

------------

//nec.h
class Nec {
public:
  void func() //ODR çiğnenmez
  {
    ///
  }
private:
  int mx, my;
};

-----------
constexpr int foo(int x)
{
return x * x;
}

int main()
{
int a[foo(10)];

constexpr auto val = foo(5); //bu şekilde derleme zamanında çalışma garantisi olur

std::array<int, foo(29)> ar{};
}

---------------------------------------------------
!! bu şekilde headder ve cpp dosyalarında yazılır class

//bugra.h
#ifndef BUGRA_INCUDED
#define BUGRA_INCUDED

class Myclass {
public:
  void foo(int);
private:
  void bar(int, int);
};

#endif

//bugra.cpp
#include "bugra.h"

#define PUBLIC
#define PRIVATE

PUBLIC void Myclass::foo(int x)
{

}

PRIVATE void Myclass::bar(int x, int y)
{
///...
}

------------------------------------------------------------

this keyword:
-------------

- 'this' is a keyword

- 'this' is a pointer, hangi nesne için çağrıldıysa o nesnenin adresini kullanır

- herhangi bir başlık dosyasını eklememize gerek yoktur

- sadece non-static'de kullanılır, global(free function) veya static de kullanılamaz

void foo()
{
this; //hata verir
}

----

class Myclass {
void func()
{
this; //hata vermez
}

static void foo()
{
this; //hata verir
}
}

----
!! hangi nesne için çağrıldıysa o nesnenin adresini kullanır

class Myclass {
public:
void foo()
{
std::cout << "this = " << this << '\n';
}
private:
int mx{}, my{};
};

int main()
{
Myclass m;

std::cout << "&m = " << &m << '\n'; //aynı adres yazar
m.foo(); 
Myclass* pm = &m; //aynı anlama gelir
pm->foo();
}

----

- this is a pr value  

class Myclass {
public:
void foo();
private:
int mx{}, my{};
};

void Myclass::foo()
{
Myclass m;
this = &m; //sentax hatası olur
}

----

class Myclass {
public:
void foo();
private:
int mx{}, my{};
};

void Myclass::foo()
{
Myclass mz;
*this = mx; //hata olmaz

(*this).mx = 56;
this->mx =56;
Myclass::mx = 56;
mx = 56; //hepsi aynı anlama gelir
}

int main()
{
Myclass m;
m.foo();
}


!! non-static üye fonksiyonu içinde this fonksiyon hangi nesne iiçn çağrıldıysa onun adresi olur
                                    ----

!! non-static üye fonksiyonu içinde *this fonksiyon hangi nesne iiçn çağrıldıysa onun kendisi  olur
                                    ------

-------------------

this kullanımının önemli olduğu alanlar

class Myclass {
public:
void foo();
private:
int mx{}, my{};
};

void gfunc1(Myclass* p)
{

}

void gfunc2(Myclass& r)
{

}

void Myclass::foo()
{
//gfunc çağırmanın tek yolu this çağırmaktır
gfunc1(this);
gfunc2(*this);

}

int main()
{
Myclass m;
m.foo();
}

----------

C# java gibi dillerde fluent API terimi vardır
c++'da bunun yerine chainig terimi kullanılır

class Myclass {
public:
Myclass& foo();
Myclass& bar();
Myclass& baz();

private:
int mx{}, my{};
};

Myclass& Myclass::foo()
{
++mx;
++my;

return *this;
}

Myclass& Myclass::bar()
{
++mx;
++my;

return *this;
}

Myclass& Myclass::baz()
{
++mx;
++my;

return *this;
}
int main()
{
Myclass m;

//m.foo();
//m.bar();
//m.baz(); //bu şekilde yazmak yerine aşğıdaki gibide yazılabilinir

//m.foo().bar().baz();   //channing
}

--------

int main()
{
using namespace std;

int x{34};
int y{323};
double dval{4565.1};

cout << x << y << dval; //channing örneği

cout.operator<<(x)..operator<<(y).operator<<(dval); //301 ile aynı anlamda 
}

---------

this pointerını mecburi kılan kısımmlar:
!! bir üye fonksiyonu içinde nesnenin kendisini veya adresini global bir fonksiyona göndermemiz gerektiği 
zaman kullanırız

class Tamer {
public:
Tamer* foo() {return this};
Tamer* bar() {return this};
Tamer* baz() {return this};
};

int main()
{
Tamer* p = new Tamer;

p->bar()->foo()->baz();
}

!! bu durumlar dışında this keywordü çok kullanma, çirkin bir görüntü

----------------------------------------------------

const member function:
---------------------
!! burası çok önemli 

Mutator : Değiştirici
Accessor : Erişimci

void func(T *);
void foo(T &);

void func(const T*);
void foo(const T&);

class Fighter {
public:
  void shoot();
};

---

class Nec{
public:
  void foo(); //mutator, non-cost member function
  void foo()const; //accessorx, const member function
};

---------------------------------
sentaks kuralları: 

a) const üye fonksiyonları içinde 
sınıfın non-static veri elemanlarına atama yapamayız

b) const üye fonksiyonu içinde non-const üye fonksiyonu doğrudan ismi ile çağırılamaz ( const T* ==> T* olmaz)

c) const sınıf fonksiyonları için sadece sınıfın const üye fonksiyonlarını çağırabiliriz

class Myclass {
public:
void foo()const
{
(*this).mx = 56; //hata olur
mx = 34; //hata, 371 ile aynı anlamda

Myclass m;
auto b = mx; //Legal
m.mx; //legal

bar(); //illegal, const T* ==> T* olmaz
}

void bar()
{
foo(); //legal
}

private:
int mx;

};

---

class Myclass{
public:
void foo()const
{
bar(); //burada hata olmaz
//const fonksiyonlar const çağırabilir
}
void bar()const;

private:
int mx;
};

int main()
{
}

------

class Myclass{
public:
void foo()const;
void bar()const;

private:
int mx;
};

int main()
{
Myclass m;
m.foo(); //hata olmaz
m.bar(); //hata olmaz

}

----

class Myclass{
public:
void foo()const;
void var();

private:
int mx;
};

int main()
{
const Myclass m;
m.foo(); //hata olmaz
m.bar(); //hata olur //const t* ==> t* dönüşüm yoktur

}

----

class Myclass{
public:
Myclass* foo()const
//const Myclass* foo() //böyle yaparsak hata olmaz, const t* ==> const t* dönüşüm olur
//const Myclass* foo()const //böyle yaparsak hata olmaz
{
return this; //hata olur const t* ==> t* dönüşüm olmaz
}

private:
int mx;
};

int main()
{
const Myclass m;

m.bar(); 

}

-----

class Myclass{
public:
Myclass& foo()

{
return *this; //hata olmaz 
}

private:
int mx;
};

int main()
{
const Myclass m;

m.bar(); 
}

-----

class Myclass{
public:
const Myclass& foo()
//Myclass& foo()const //hata olur
{
return *this; //hata olmaz, t& ==> const t& dönüşüm var
}

private:
int mx;
};

int main()
{
const Myclass m;

m.bar(); 
}

-----

class Myclass{
public:
void foo(); //burası nesneyi değiştirmek istiyor

private:
int mx;
};

int main()
{
const Myclass m; //burası kendini değiştirmek istemiyor
m.foo(); //hata olur
}

-------

class Myclass{
public:

private:
};

void foo(Myclass*); //function overloading olur
void foo(const Myclass*);
void foo(Myclass* const); //function redaclaration

-------

class Myclass{
public:

private:
};

void foo(Myclass*); //function overloading olur
void foo(const Myclass*);

int main()
{
Myclass m;

foo(&m); //549 çağrılı
}

-----

class Myclass {
public:
void foo();
void foo()const; //ovarloading olur

private:
};

int main()
{
Myclass m;
m.foo();//562 çağrılır

const Myclass m;
m.foo(); //564 çağrılır
}

------

#include <iostream>
#include <string>

int main()
{
using namespace std;

const string name{ "TAMER"};

std::cout << name << '\n';
auto c = name[0];
name[0] = 'K'; //buraya hata verir
std::cout << name >> '\n';
}

-----

class String {
public:
char & front();
const char & front()const;
};

int main()
{
string name;
name.front() = 'A'; // hata olmaz

}

-----

class String {
public:
char & front();
const char & front()const;
};

int main()
{
const string name;
name.front() = 'A'; // hata olur

const string name;
auto val = name.front();

}

------

int main()
{
using namespace std;
string name{ "mert" };
//const string name{ "mert" }; //bu şekilde hata olır

name.front() = 'b'; //Hata olmaz
name.back() = 'k';
}

-----

mülakatlarda en sık sorulan sorulardan birisi

class Fighter {

public:
void foo()const
{
m_age++; //hata olur 
//++debug_call_count; //sentax hatası olur, bunu aşmak için mutable kullanılır

}
private:
  std::string m_name;
  int m_age;
  int power;
  //int debug_call_count; //üye fonskiyonların kaç kez çağrıldığına bakacak
  mutable int debug_call_count;

!! mutable sayesinde artık debug_call_count değiştirilmesi hata olmaz
};
int main()
{

}

----------------------------------------------------------
// bir sınıf nesnesinin hayata gelmesi için sınıfn üye fonksiyonunun çağrılması gerekir

constructor (kurucu işlev): sınıf nesnesini hayata getiren fonksiyon
destructor (sonlandırıcı işlev): sınıf nesnesinin hayatını bitiren fonksiyon

constructor:
-sınıfın non-static member function olmalı global olamaz
-constructor keyfi olarak isimlendirilemez, sınıfın ismi ile aynı olmalı
-geri dönüş değeri yoktur


/////////////////////////////////////////////////////////2. Ders///////////////////////////////////////////////////

















