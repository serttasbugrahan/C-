//////////////////////////////////////////// 1. Ders //////////////////////////////////////////////////////

giriş/çıkış işlemleri
---------------------

formatlı giriş çıkış işlemleri ne demektir ?

int x = 3'453'456

0101 0101
1001 1001
0010 1001
1001 1111

-bytları olduğu gibi bir işlem yapmadan alıp verme işlemine formatsız giriş çıkış işlmeleri denir

-bu bytlar insan anlıycağı şekile dönüştürülüyor ise yazı formuna dönüştürülüyor ise formatlı giriş çıkış işlemi demektir

-----------

giriş çıkış işlemlerinin nereye yazılacağı seçilir, dosya yazma, bellekte tutma vb.

giriş çıkış işlemlerini yöneten nesneleri nasıl kullanırız, nasıl işlemler yaparız (cout, cin )

--------------------------

ios_base : ortak interface toplandığı taban sınıf

basic_istream : giriş işlemleri var

basic_ostream : çıkış işlemleri var

basic_iostream : ikisinin toplamı

basic_streambuf : arka plandaki bufferlama işlemini yapar

----------------------

! birkaç önemli ipucu

int main()
{
//std::ostream yazınca aşağıdakini yazarız aslında

std::basic_ostream<char, char_traits<char>>

}

-----------
//mülakatların basic sorusu

int main()
{
cout //standart output kontrol eder, sınıf türünden bir nesnedir, fonksiyon ismi değildir
cin //standart input kontrol eder, sınıf türünden bir nesnedir, fonksiyon ismi değildir
}

-----------


cout : ostream sınıf türünden 

cout ostream sınıf türünden nesne 
ostream sınfı basic_ios kalıtım yoluyla edeilir
basic_ios ios_base sınıfınfan kalıtım yoluyla elde edilir  

-----------

int main()
{
using namespace std;

cout. //burada çıkanlar cout, basic_ios ve ios_base sınıfından gelen nesnelerdir
}

------------

int main()
{
using namespace std;

cout.operator<< //bunlar ostream sınıfının üueleri
cin.operator //bunlar istream sınıfının üueleri
}

-----------
std::basic_ios<char> //açılımı ios demektir

int main()
{
using namespace std;
ios
}

------------

                                       ios_base
                                    
                              //kalıtım yolyla aşağıdaki elde edilir
                                    
                                    basic_ios<c,t>
                                    
                              //sanal kalıtım yoluyla aşağıdaki elde edilir
                                    
                    basic_istream                            basic_ostream
                char açılımı istream                        char açlımı ostream

                             //çoklu kalıtım yolyla aşağıdaki elde edilir

                                   
         basic_istring_stream                              basic_ostring_stremm
  (bellek üstünde okuma yazma yapmak için)      (bellek üstünde okuma yazma yapmak için)      
                           
                                    basic iostream
                                    basic_stringstream


-------------

ilk olarak anlamamız gerekn yerden başlıyoruz

şimdi formatlı giriş çıkış işlemlerine bakıyoruz

bazı fonksiyonlar free bazılar member functiondır

int main()
{
using namespace std;

cout << "mert sirakaya\n";
operator<<(cout, "mert sirakaya\n";
cout.operator bool("mert sirakaya\n");
}

--------------

class ostream {

public:
ostream& operator<<(int);
ostream& operator<<(double);
ostream& operator<<(float);
ostream& operator<<(ostream&(*)(ostream&));

};

-----------

int main()
{
using namespace std;

cout << 'A';
operator<<(cout, 'A'); //burada çağrılan gloabal operator left shift fonksiyonu

cout.operator<< '(A)'; //parametresi int olan karakter kodu
}

-------------

int main()
{
using namespace std;

cout << endl;
cout.operator<< (&endl);
}

------------

//zekice bir hile var

int main()
{
using namespace std;
int val = 5;
double dval = 4.8761;
string name{"tamer dundar" };

cout << "necati " << ival << " " << dval << " " << name << endl;  //sonuç olarak aynı işlemleri yapar
operator<<(operator<<(operator<<(operator<<(cout,  "necati ").operator<< (ival), " ").operator<< (dval),  " "), name).operator<< (endl);

}

--------------

c++'da int ve double yazdıran farklı fonksiyonlardır
c de aynı fonksiyonlar

---------------

int main()
{
using namespace std;

cout << bitset<<32>(76787678u); //global operator fonksiyonudur
//ancak int double yazdıran üye fonksiyonaldır
}

--------------

! önemli bir kısıma geçiyouz

istram ve ostream'in bir format state'i var

format state : stream nesnesi bir giriş ya da çıkış işlemi formatlı olarak yapılacağında 
kendi format state'ine bakarak ne şekilde bir formatalama uygulıycağını seçiyor

cout << 8787878 << '\n'; //neden onluk sistemde yazdı
//çünkü burada çağrılan format state'ine bakar 10'luk sistemde olucağını seçer

her farklı tür için default format state vardır

 bu format state nasıl set ve get edilir ona bakıyoruz

--------------

boolen (on-off flag)

int main()
{
using namespace std;

cout << (10 > 5);
}

on-off flags:
-------------

on                off        default
true-false        1 / 0      off  

0X ABC            0x abc      off 

//bunlar nasıl değiştirilir peki

formatlama state tutan fmtflags vardır

--------------

int main()
{
using namespace std;

cout.setf(ios::boolalpha); // formta state değiştirir
}

------------

int main()
{
using namespace std;

cout.flags(); //fmt flag türünden get ediyor

cout.setf(ios::boolalpha);
cout.setf(cout.flags() | ios::boolalpha);
}

-----------

//boolalpha 1 0 testi

int main()
{
using namespace std;

cout << bitset<32>(cout.flags()) << "\n";
cout.setf(ios::boolalpha);
cout << bitset<32>(cout.flags()) << "\n";

if (cout.flags() & ios::boolalpha) {
cout << "true false olarak yazar\n";
}
//defaultu else kısmına girer
else {
cout << "1 0 olarak yazar\n";
}
}

-----------------

int main()
{
using namespace std;

cout << true << false << "\n"; // 1 0  yazar çünkü defaultu böyle
cout.setf(ios::boolalpha);
cout << true << false << "\n";
}

//peki eski haline nasıl getiriceğiz

-----------------

int main()
{
using namespace std;

cout << true << false << "\n"; // 1 0  yazar çünkü defaultu böyle
cout.setf(ios::boolalpha); //biti set eder
//cout.flags(cout.flags() & ~ios::boolalpha); //setf açılmış hali

cout << true << false << "\n";
cout << true << false << "\n";

//cout.unsetf(ios::boolalpha); //Biti reset eder
//cout.flags(cout.flags() & ~ios::boolalpha); //unsetf açılmış hali

cout << true << false << "\n";
}

--------------

int main()
{
using namespace std;
int ival = 567532;

cout.setf(ios::showpos);
cout << ival << "\n";
cout.unsetf(ios::showpos);
cout << ival << "\n";
}

---------------

int main()
{
using namespace std;
int ival = 567532;

cout.setf(ios::boolalpha | ios::showpos);

}

-------------------

int main()
{
using namespace std;

double dval = 4.;
cout.setf(ios::showpoint);
cout << dval << "\n";

}

---------------

ios_base::boolalpha
ios_base::showpos
ios_base::showpoint
ios_base::showbase
ios_base::uppercase

---------------

int main()
{
using namespace std;

cout.setf(ios::hex, ios::basefield);
cout.setf(ios::showbase);
cout.setf(ios::uppercase);
cout.setf(ios::showbase | ios::uppercase); //bu şekilde ikiside aynı anda yapılabilir

cout << 47805;
}

--------------

int main()
{
using namespace std;

cout.setf(ios::hex, ios::basefield);

--------------
constexpr std::ios_base::fmtflags necflag{ std::ios::showbase | std::ios::showpoint };

int main()
{
using namespace std;

cout.setf(necflag);
cout.unsetf(necflag);
}


----------------

bazı formatlama birden fazla değer alabiliyro

//sayı sisteminin ne olduğu

dec hex oct

int main()
{
using namespace std;

bitset<32>(ios::basefield) << "\n"; //dec hex oct olduğunu gösteren bitler bunlardır

}

--------------

int main()
{
using namespace std;

cout << bitset<32>(ios::basefield) << "\n";
cout << bitset<32>(ios::dec) << "\n";
cout << bitset<32>(ios::oct) << "\n";
cout << bitset<32>(ios::hex) << "\n";

}

---------------

int main()
{
using namespace std;
int ival = 54807;

cout << ival << "\n";

cout.setf(ios::hex, iosbasefield); //1.parama göre birle, 2. parama göre sıfırla

cout << ival << "\n";

cout.setf(ios::oct, ios::basefield);

cout << ival << "\n";

cout.setf(ios::dec, ios::basefield);

}

--------------

int main()
{
using namespace std;

//cout.setf(ios::hex, ios::basefield); //sadece hex biti set edilir

if (cout.flags() & ios::dec) {
std::cout << "dec biti set edilmis\n";
}
if (cout.flags() & ios::hex) {
std::cout << "hex biti set edilmis\n";
}

if (cout.flags() & ios::oct) {
std::cout << "oct biti set edilmis\n";

}

//sadece 10 16 ve 8 lik sayı sisteminde yazma var

-----------

int main()
{
using namespace std;

cout.setf(ios::uppercase);
cout.setf(ios::showcase);
cout.setf(ios::hex, ios::basefield);

for (int i = 13576, i < 14000; ++i)
cout << i << "\n";
}

--------------------------------------------
//bu kısmı ezberlemeye çalışma işin düştüğü zaman cpp ref bak dedi necati hoca

gerçek sayıların formatlama biçimleri
--------------------

a) fixed : noktalı yazmak
b) scinetific : 10^ şekilde
c) büyüklüğüne bağlı : implementasyon yukarıdakilerden birini seçer
d) precision : nokta gösterilmesi


ios::fixed
ios::scinetific

int main()
{
using namespace std;

cout.setf(ios::fixed, ios::floatfield);
//cout.setf(ios::scinetific, ios::floatfield);
//cout.setf(ios::fixed | ios::floatfield);


cout << "ios::fixed : " << (cout.flags() & ios.fixed ? "set" : "unset") << "\n";
cout << "ios::scinetific  : " << (cout.flags() & ios.scinetific ? "set" : "unset") << "\n";

cout << 7324.72345 << "\n";
cout << 987678987678.87678 << "\n";
}

--------------------

outfit (yazma alanı genişliği): yazılan yazıuı belli bir karakter alanına yazmak içinn kullanılır, yazıları hizaya sokmak için yapılır


furkan.....434
damla......3232
can........34333
nurattin...232
giyasettin.232 //sola dayalı

..........furkan //sağa dayalı

//iostream kütüphanesinde ortalama yoktur, std::formatta vardır, necati hoca buna c++ gençlik günahlarından brisi diyor

bunun yerine 'internal' vardır.

tam sayıları söz konusu olduğunda işaret sola gelir
+    45
-    235
+    

bunları temsil eden

ios::left
ios::right
ios::internal  ios::adjustfield

cout.setf(ios::left, ios::adjusfield);
cout.setf(ios::right, ios::adjusfield);
cout.setf(ios::internal, ios::adjusfield);


------------

int main()
{
using namespace std;

auto n = cout.width(); //yazma alanı genişliğini get eder

cout << "n = " << n << '\n';
}

------------

int main()
{
using namespace std;

auto c = cout.fill('-');

cout << static_cast<int>(c) << "\n";
auto c = cout.fill();
cout << static_cast<int>(c) << "\n";

}

--------------

int main()
{
using namespace std;

//cout.setf(ios::right, ios::adjustfield); //zaten default sağa dayalı yazmaya gerek yok
cout.width(24);

cout << "neco" << "furkan";
}

------------

int main()
{
using namespace std;

cout.setf(ios::right, ios::adjustfield); 
cout.fill('.');
cout.width(24);

cout << "neco" << "furkan";
}

------------

int main()
{
using namespace std;

cout.setf(ios)

for (int i = 0; i < 20; ++i) {
cout.width(12);
cout << rname();
cout.width(20);
cout << rfname();
cout.width(20);
cout << rtown();
cout << '\n';
}
}


-------------------------

bu karmaşık yapı yerine ostream manipülatörü vardır

class ostream {

pubcli:
ostream& operator<<(int);
ostream& operator<<(double);
ostream& operator<<(float);
ostream& operator<<(ostream&(*fp)(ostream&))
{
return fp(*this)
}
}

cout << endl

-------------
//aşağıdakilere ostream manipilatörü deniyor

std::ostream& Boolalpha(ostream& os)
{
os.setf(ios::boolalpha);
return os;
}

std::ostream& NoBoolalpha(ostream& os)
{
os.unsetf(ios::boolalpha);
return os;
}

int main()
{
using namespace std;

cout << Boolalpha << (10 > 5)  << NoBoolalpha << (10 > 5); 
}

//bunlar standart olduğu için o şekilde yazmaya gerek yok

--------------

int main()
{
using namespace std;

int x = 0xBABA;

cout << x << hex << x << '\n' << oct << x << dec << '\n';
cout << x;

}

--------------
//hex manipilatörünü bu şekilde yazabiliriz

std::ostream& Hex(std::ostream& os)
{
os.setf(ios::hex, ios::basefield);

return os;
}

int main()
{
using namespace std;


}

------------
//kendi manipilatörümüzü yazabiliriz

std::ostream& nhex(std::ostream& os)
{
os.setf(std::ios::uppercase | std::ios::showbase);
os.setf(std::ios::hex, std::ios::basefield);
return os;
}

int main()
{
using namespace std;

cout << 47802 << " " << nhex << 47802 << "\n";
}

------------

endl de bu şekilde bir fonksiyondur

std::ostream& Endl(std::ostream& os)
{
os.put('\n');
os.flush(); //bunun ciddi maaliyeti vardır
return os;
}

!! her yerde endl kullanılmaz

----------

//şık bir manipilatör yazıyoruz

std::ostream& dl(std::ostream& os)
{
return os << "\n-------------------------------"; 
}

int main()
{
using namespace std;

cout << 12 << dl << "ali" << dl << 23.5 << dl << "furkan";
}

----------------

void func(std::ostream& os)
{
os << boolalpha << hex << uppercase << showcase;
///.
}

int main()
{
func(cout);
}

----------------

yukarıda cout manipüle edildi cout bende kullanıyorum ancak onun format statei değişti

fromat state değiştiriceğimiz ancak eski haline de geri getireceğimiz durumda ne yapmamız gerekir

bunun 2 yolu vardır
-şık yok
-düz yol
-pek bilinmeyen yol
-------------
-düz yol

void func(std::ostream& os)
{
auto flg = os.flags();
auto width = os.width();
auto fc = os.fill();
auto precision = os.precision();

os << boolalpha << hex << uppercase << showcase;

os.flags(flg);
os.width(width);
os.fill(fc);
os.precision(precision);
}

------------

-şık yol: RAII Kullanmak

RAII : ctor kaynağı edinir ctor kaynağı geri verir

------------

//mülakatta raıı idiomu sorulsa bunu verebilirsin

class FmtGuard {
public:
FmtGuard(std::ostream& os) : m_os{os} mflags{os.flags()}, 
mwidth(os.width()) {}

~FmtGuard()
{
os.flags(mflags);
m_os width(mwidth);
}

private: 
std::ostream& m_os;
std::ios::fmtflags mflags;
std::size_t mwidth;
};

void func(std::ostream& os)
{
FmtState state { os };
os << boolalpha << hex << uppercase << showcase;

}

----------------

-pek bilinmeyen yol

int main()
{
using namespace std;

ostream mycout(cout.rdbuf());

mycout << uppercase << hex << showbase << boolalpha;

mycout << 47802 << " " << (10 > 5) << "\n";
cout << 47802 << " " << (10 > 5) << "\n";

}

-----------------

#include <iomanip>

int main()
{
using namespace std;

for (int i = 0; i < 10; ++i) {
cout << setw(12) << rname << setw << 30 << rfname() << rand() << '\n';
//setw parametreli manipilatör
 
}
}

---------------

parametreli manipilatörler

-set
-setprecision
-setfill


---------------

//zor bir soru

//bir mülakata girdik ve bziden parametreli bir manipilatör yazmamız istendi
//a-yukarıdaki kodu legal yap
//b- sp manipilatörü 5 için 5 space boşluk

//yasar......ali...........veli...................mert  //nokta yerne space



int main()
{
using namespace std;
cout << left << "\n";

cout << "yasar" << sp(5) << "ali" << sp(12) << sp(20) << "mert" << '\n';
}

----------

class sp
{
public:
    sp(std::size_t val) : mval(val) {}
    friend std::ostream &operator<<(std::ostream &os, const sp &x)
    {
        for (int i = 0; i < x.mval; ++i)
        {
            os.put(' ');
        }
        return os;
    }

private:
    std::size_t mval;
};

int main()
{
    using namespace std;
    cout << left << "\n";

    cout << "yasar" << sp(5) << "ali" << sp(12) << "mert" << '\n';
}

/////////////////////////////////////////////////// 2. Ders /////////////////////////////////////////////////

tekrar

bazı özellikler boolen

.setf(ios::boolalpha);
.unsetf(ios::boolalpha); //eski haline geri döner

ios::showbase
ios::uppercase
ios::skipws
ios::showpoint

cout.setf(ios::hex, ios::basefield);
cout.setf(ios::left, ios::adjustfield);

cout.setf(ios::fixed, ios::floatfield);

//sadece çıkış akımı için değil giriş akımı içinde geçerlidir

int main()
{
using namespace std;

std::cout << "bir tam sayi girin: ";
int x{};

cin.setf(ios::hex, ios::basefield);
cin.setf(ios::oct, ios::basefield);
cin >> x;

cout << "x = " << x << '\n';
}

------------------

int main()
{
using namespace std;

std::cout << "2 tam sayi girin: ";
int x{}, y{};

cin >> hex >> x >> oct >> y >> dec >> z;

cout << "x = " << x << '\n';
cout << "y = " << y << '\n';
cout << "z = " << z << '\n';

}

---------------------
//hiçbiri yazmaz

int main()
{
using namespace std;

if (cin.flags() & ios::hex) { std::cout  << "hex set\n"; }
if (cin.flags() & ios::dec) { std::cout  << "dec set\n"; }
if (cin.flags() & ios::oct) { std::cout  << "oct set\n"; }

int x{};

cout << "bir sayi girin: ";
cin >> x; //012, 10 ,0x10

cout << "x = " << x << "\n";
}

--------

//ilginç bir özellik daha var
//hem istream tarafında hem ostream tarafında

//parametreli bir manipilatör bu yzüden <iomanip> ihtiyaç duyar

#include <iomanip>

int main()
{
using namespace std;
int x;

cin >> setbase(ios::hex) >> x;

cin >> hex >> x; //yukarıdaki ile aynı anlamda
}

------------

unitbuf : bufferlama olmadan yazılmasına denir 
nounitbuf 

int main()
{
using namespace std;

cout.setf(ios::unitbuf);
cout << unitbuf;
cout << (cout.flags() & ios::unitbuf ? "set" : "unset") << "\n";
}

-----------

int main()
{
using namespace std;

unitbuf(std::cout); //sentax hatası olmaz, ADL
endl(std::cout);//sentax hatası olmaz, ADL
flush(std::cout);//sentax hatası olmaz, ADL

}

------------

std::ostream& Flush(std::ostream& os)
{
return os.flush();
}

int main()
{
using namespace std;

cout << Flush << "\n";
}

------------

ends : null karakter koyar

-----------

int main()
{
using namespace std;

cout << right << setw(12) << setfill('!') << 45
}

-----------

//geri kalan manipilatörleri https://en.cppreference.com/w/cpp/io/manip sayfasından kontrol et

------------

format kütüphanesini öğren bunlar hantal biraz diyor necati hoca
ileri cpp kursunda onları anlatıyor

====================================================

                                          ios_base
                                                                        
                                        basic_ios (Template)
                                                                        
                    basic_istream                            basic_ostream

                                          basic_iostream
                                              |
                                              |
                                              |
                                              |
      basic_istring_stream                    |                 basic_ostring_stream
    (bellek üsütnde  okuma)                   |                (bellek üsütnde yazma)
                                      basic_string_stream
                               (bellek üsütnde hem okuma hem yazma)



----------------------------

C tekrarı
---------

#include <csdio>

c dilinde sprintf, sscanf 

int main()
{
int x = 5;
double dval = 4.5;
char name[] = "melike";
char buffer[256];

sprintf(buffer, "x = %d dval = %f name = %s", x, dval, name); //belleğe yazar

printf("%s\n", buffer);
}

-----------

scanf ne yapar : bellekten okuma işlemi yapar

int main()
{
int x, y, z;

printf("3 sayi giriniz: ");
scanf("%d%d%d", &x, &y, &z);

printf("x = %d y = %d z = %d\n", x, y, z);
}

-----------

int main()
{
int x, y, z;

char buf[]= "123 456 790";
sscanf(buf, "%d%d%d", &x, &y, &z); //değerleri bellekten alır

printf("x = %d y = %d z = %d\n", x, y, z);
}

----------------------------

//bunlar yerine c++ da 

int main()
{
using namespace std;

ostringstream : yazma
istringstream : okuma
stringstring : okuma ve yazma
}

------------

ostringstream sınıfı ile başlıyoruz

int main()
{
using namespace std;

ostringstream 
basic_ostring_stream<char> //yukarıdaki ile aynı anlamda, typedef sayesinde olur
}

----------
//ne işe yarar

int main()
{
using namespace std;

ostringstream os;
int amount = 200'000;

os << "benim" << amount << "dolarim var\n"; //os kontrol ettiği bellek alanına yazıldı

//bu ne işe yarar

auto s = os.str();
reverse(s.begin(), s.end());

cout << s << "\n";
}

-------------

int main()
{
using namespace std;

ostringstream os;

for (int i = 0; i < 10; ++i) {
os << i;
}

cout << os.str(); //bellekten hepsini yazacaktır
}

-------------

int main()
{
using namespace std;

int day, mon, year;

cout << "tarihi giriniz: ";
cin >> day >> mon >> year;

//03_05_1987.txt üzerine yazsa idik çok masraflı olurdu

ostringstream oss;

oss.fill('0');
oss << setfill('0') << setw(2) << day << '_' << setw(2) << mon << '_' << year << ".txt";  

cout << "[" << oss.str() << "]\n";

}

--------------

int main()
{
using namespace std;

ostringstream oss;

for (int i = 1; i < 10; ++i) {
oss << "necati" << i << ".txt";
cout << oss.str() << "\n";
}
}

---------------

int main()
{
using namespace std;

for (int i = 1; i < 10; ++i) {
ostringstream oss; //bu şekilde farklı olur
oss << "necati" << i << ".txt";
cout << oss.str() << "\n";
}
}

---------------
#include <sstream>

int main()
{
using namespace std;

ostringstream oss;

for (int i = 1; i < 10; ++i) {
oss << "necati" << i << ".txt";
cout << oss.str() << "\n";
oss.str(""); //bu şekilde de olur
}

----------------

//mülakatlarda sorulan bir soru

class date {
public:
date(int day, int mon, int year) : day_(day), mon_(mon), year_(year) {}
friend std::ostream& operator<<(std::ostream&, const Date& dt)
{
return os << dt.day_ << "-" << dt.mon_ << "-" << dt.year_;
}

private:
int day_, mon_, year_;

};

int main()
{
date mydate{11, 12, 2023 };

// cout << mydate << "\n"; //normaalde bu şekilde yazılır

cout << left << setw(40) << mydate << "mustafa\n"; //bu kod beklenildiği gibi çalışır mı? -hayır
//yazma alanı genişliği sadece ilk öğeyi kapsar
}


------------

//aşağıdaki şekilde çözülür

class date {
public:
date(int day, int mon, int year) : day_(day), mon_(mon), year_(year) {}
friend std::ostream& operator<<(std::ostream& os, const Date& dt)
{
std::ostringstream ostr;
ostr << dt.day_ << "-" << dt.mon_ << "-" << dt.year_;
return os << ostr.str();
}

private:
int day_, mon_, year_;

};

int main()
{
date mydate{11, 12, 2023 };

cout << left << setw(40) << mydate << "mustafa\n"; 
}

----------------

int main()
{
using namespace std;

ostringstream oss;

oss << hex << uppercase << showbase;

oss << 47802 << " " << 54807;

cout << oss.str() << "\n";
}

---------------

//şaşırtıcı bir kod
//enter basıldığı zaman ekrana yazılan kodları toplar

int main()
{
using namespace std;

cout << "toplanacak sayilari girin: ";

string str;
getline(cin, str)
cout << "[" << str << "]\n";

istringstream iss{str};
int ival;
int sum{};
while (iss >> ival) {
sum += ival;
}

cout << "toplam = " << sum << '\n';
}


----------------------
#include <sstream>

//girilen sayıları küçükten büyüğe sırala

int main()
{
using namespace std;

cout << "sayilar giriniz ";

string str;
getline(cin, str); //Boşluklar dahil string nesnesini aldı

istringstream iss{str};

int ival;

vector<int> ivec;

while (iss >> ival) {
ivec.push_back(ival);
}

sort(ivec.begin(), ivec.end());

for (const auto val : ivec)
cout << val << " ";
}

------------------
#include <sstream>

//tokenızing yapılması (kelimeler ayrıştıma)

int main()
{
using namespace std;

cout << "bir cumle girin: ";
string str;

getline(cin, str);
istringstream iss{str};

string word;

while (iss >> word) {
cout << word << '\n';
}
}

--------------
#include <sstream>
#include <random>
#include <iterator>

int main()
{
using namespace std;

cout << "bir cumle girin: ";
string str;

getline(cin, str);
istringstream iss{str};

string word;
vector<string> svec;
while (iss >> word) {
svec.push_back(move(word));
}

//ilginç bir algoritma

mt19937 eng;

for (int i = 0; i < 20; ++i) {
(void)getchar();
system("cls);
shuffle(svec.begin(), svec.end(), eng);
copy(svec.begin(), svec.end(), ostream_iterator<string>(cout, " "));
}
}

---------------------------------------------

contition state

streamin bir sağlık durumu vardır
sağlık iyiyse okuma yazma yapar değilse yapamaz

nasıl format state var ise contiton state vardır

//format state ==> fmtflgas var
//condition state ==> iostate

-------------

int main()
{
cout << typeid(ios::base::iostate).name()
}

-------------

stream sınıflarının bool döndüren fonksiyonları vardır

.good() //true dönerse, streamde hata yok
.eof() //true dönerse, stream'de karakter olmamasına rağmen okuma işlemi yapınca döner
.fail() //true dönerse, akımda hata var
.bad() //true dönerse, ciddi bir hata var stream kullanılmaz durumda

----------

int main()
{
using namespace std;

cout << boolalpha;

cout << "cin.good() : " << cin.good() << '\n';
cout << "cin.eof() : " << cin.eof() << '\n';
cout << "cin.fail() : " << cin.fail() << '\n';
cout << "cin.bad() : " << cin.bad() << '\n';

}

------------

int main()
{
using namespace std;

cout << boolalpha;
int x{};

cin >> x;

cout << "cin.good()      : " << cin.good() << '\n';
cout << "cin.eof()       : " << cin.eof() << '\n';
cout << "cin.fail()      : " << cin.fail() << '\n';
cout << "cin.bad()       : " << cin.bad() << '\n';
cout << "operator bool() : " << (cin ? true : false) << "\n";
cout << "operator!()     : " << (!cin ? true : false) << "\n";
}

// streamde karakter olmayışı, 'ctrl + z + enter'  ile test yap

--------------

int main()
{
using namespace std;

// ios::goodbit
// ios::eofbit
// ios::failbit
// ios::badbit

cout << ios::goodbit;
cout << ios::failbit;
cout << ios::badbit;
cout << ios::failbit;

}

---------------
using namespace std;

void print_state(const ios& s)
{
const auto stream_state = s.rdstate();

if (stream_state == 0) { cout << "stream is ok no bit set\n";}

if (stream_state & ios::failbit) { cout << "failbit set\n";}
if (stream_state & ios::eofbit) { cout << "eofbit set\n";}
if (stream_state & ios::badbit) { cout << "badbit set\n";}

}

int main()
{

int x;
cin >> x;
print_state(cin);

cin.clear(); //Hata bayraklarını sıfırlar akımı good durumuna getirir
print_state(cin);
}

----------------

void print_state(const ios& s)
{
const auto stream_state = s.rdstate();

if (stream_state == 0) { cout << "stream is ok no bit set\n";}

if (stream_state & ios::failbit) { cout << "failbit set\n";}
if (stream_state & ios::eofbit) { cout << "eofbit set\n";}
if (stream_state & ios::badbit) { cout << "badbit set\n";}

}

int main()
{
using namespace std;

int x;

while (cin >> x) {
//while(cin.operator>> (x).operator bool()) //aynı anlamda
cout << x << " * " << x << " = " << x * x << "\n";
}
}

-----------------

int main()
{
using namespace std;

if (cin) {
std::cout << "ok\n";
}

if (cin.operator!() {
cout << "not ok\n"
}

if (!cin.good() {
cout << "not ok\n"
}

}

-----------------
#include <iomanip>

void print_state(const ios& s)
{
const auto stream_state = s.rdstate();

if (stream_state == 0) { cout << "stream is ok no bit set\n";}

if (stream_state & ios::failbit) { cout << "failbit set\n";}
if (stream_state & ios::eofbit) { cout << "eofbit set\n";}
if (stream_state & ios::badbit) { cout << "badbit set\n";}
}

int main()
{
using namespace std;

cout << "bir tam sayi girin: ";

int x{};

while (!(cin >> x)) {
if (cin.eof()) {
std::cout << "ama hic giris yapmadiniz ki\n";
cin.clear();
cout << "tekrar deneyin\n";
}
else {
cin.clear();  
string sline;
getline(cin, sline);
cout << quoted(sline) <<  "gecerli bir sayi degil... tekrar deneyin\n";
}
}

std::cout << "girdiginiz sayi" << x << "\n";
}

//ctrl z enter ile test yap

--------------------

void print_state(const ios& s)
{
const auto stream_state = s.rdstate();

if (stream_state == 0) { cout << "stream is ok no bit set\n";}

if (stream_state & ios::failbit) { cout << "failbit set\n";}
if (stream_state & ios::eofbit) { cout << "eofbit set\n";}
if (stream_state & ios::badbit) { cout << "badbit set\n";}
}

int main()
{
cin.clear(ios::failbit | ios::eofbit | ios::badbit); //3 biti birden set etti

print_state(cin);
}

---------------

int main()
{
istringstream iss{"12 45 78"};

int ival;

iss >> hex >> ival;

if (iss) {
std::cout << "stream iyi durumda\n";
}
else {
std::cout << "stream hata durumda\n";
}
}

----------------

exception throw etmezler
exception throw daha sonra koyulmuştur dile çünkü

---------------
//exception hale getirebiliyoruz
//sınıfın exception isimli fonksiyou vardır

int main()
{
using namespace std;

auto cstate = cin.exceptions();

cout << cstate << "\n";
}

---------------

int main()
{
cin.exceptions(ios::eofbit); //eofbit set edilirse exception throw edilsin
cin.exceptions(ios::failbit); //failbit set edilirse exception throw edilsin
cin.exceptions(ios::failbit); //failbit set edilirse exception throw edilsin

}

----------------

int main()
{
using namespace std;

//cin.exceptions(ios::failbit);
//cin.exceptions(ios::eofbit);

try
{
    std::cout << "bir sayi girin : "; //ali
    cin >> x;
}
catch(const std::exception& e)
{
    std::cout << "exceptions caught: " << e.what() << '\n';
}

-----------------

using namespace std;

void func(std::istream& is)
{
auto state = is.exceptions();

//is.exceptions(ios::failbit);

is.exceptions(state);
}

--------------------------------

int main()
{
using namespace std;

istream_iterator<int> iter{cin};
istream_iterator<int> end{};

}

-----------------
#include <numeric>

int main()
{
using namespace std;

cout << "sayilar giriniz: ";
cout << accumulate(istream_iterator<int>{cin}, istream_iterator<int>{}, 0) << "\n";
cout << *max_element(istream_iterator<int>{cin}, istream_iterator<int>{}) << "\n";
}

-----------------

int main()
{
using namespace std;

cout << "sayilar giriniz: ";

vector<int> ivec(istream_iterator<int>{cin}, istream_iterator<int>{});

cout << "toplam " << ivec.size() << "tane sayi girdiniz\n";
sort(ivec.begin(), ivec.end());
cout << "girdiğiniz sayilar\n";

for (const auto ival : ivec) {
std::cout << ival << " ";
}
}

-------------------

int main()
{
string str{"2.3 5.6 6.7 4.5 1.2 4.4 3.9"};
istringstream iss(str);

vector<double> dvec {istream_iterator<double>{iss}, istream_iterator<double>{}};

for (auto dval : dvec)
cout << dval << "\n";
}

------------------

//çok kullanılan idiyomatik yapı

template <typename T>
void func(T x, T y)
{
std::cout << "x = " << x << "\n";
std::cout << "y = " << y << "\n";
}

int main()
{
using namespace std;

string s1{"alican"}, s2{"tamer"};

func(3.4, 2.3);
func(s1, s2);
}

----------------


template <typename T>
void func(T x, T y)
{
std::cout << "x = " << x << "\n";
std::cout << "y = " << y << "\n";
}

int main()
{
using namespace std;

func(12, {}); //

string s1{"furkan"};
func(s1, {});


}

------------------

programcılar aşağıdaki idiomu gördüğü zaman şaşırır

int main()
{
string str{"2.3 5.6 6.7 4.5 1.2 4.4 3.9"};
istringstream iss(str);

vector<double> dvec {istream_iterator<double>{iss}, {}}; //default ctor edilmiş stream gözükür
 
}

/////////////////////////////////////////// 3. Ders ///////////////////////////////////////

#include <iterator>

int main()
{
using namespace std;

istream_iterator<int> iter{cin};

int val{};

val = *iter;

cout << "val = " << val << '\n';
++iter;
val = *iter;
++iter;
cout << "val = " << val << '\n';
++iter;
val = *iter;
cout << "val = " << val << '\n';
}

--------------

#include <sstream>
#include <algorithm> //copy algoritması için ekledik

int main()
{
using namespace std;

istringstream iss{"burak kose damla kubat furkan mert melike kaplan"};

copy(istream_iterator<string>{iss}, istream_iterator<string>{}, 
ostream_iterator<string>{cout, "\n"});
}

---------------

#include <sstream>
#include <algorithm> 
#include <numeric>

int main()
{
using namespace std;

istringstream iss{"12 34 56 78 90 3 876 63 847 24 661 88"};

copy(istream_iterator<int>{iss}, istream_iterator<int>{}, 
ostream_iterator<int>{cout, "\n"});

// copy(istream_iterator<int>{iss},{}, ostream_iterator<int>{cout, "\n"}); //bu şekilde yazılabilir template argüment detection

auto sum = accumulate(istream_iterator<int>{iss}, istream_iterator<int>{}, 0);

cout << "sum = " << sum << '\n';
}

----------------

int main()
{
using namespace std;

istringstream iss{"12 34 56 78 90 3 876 63 847 24 661 88"};

auto max = *max_element(istream_iterator<int>{iss}, istream_iterator<int>{});
cout << "max == " << max << '\n';
}

----------

int main()
{
using namespace std;

istringstream iss{"12 34 56 78 90 3 876 63 847 24 661 88"};

copy_if(istream_iterator<int>{iss}, istream_iterator<int>{}, ostream_iterator<int>{cout, "\n"},
[](int x) {return x % 2 == 0;});
}

--------------------------

//ilginç bir fonksiyon ile devam ediyoruz

int main()
{
using namespace std;

ostream oss{cout.rdbuf()}
}

---------

int main()
{
using namespace std;

ostream os_hex{cout.rdbuf()}};
ostream os_oct{cout.rdbuf()}};

os_hex << hex << uppercase << showbase;
os_oct << oct << showbase;

Irand myrand{3455678, 999999};

for (int i = 0; i < 10; ++i) {
auto val = myrand();
cout << val << '\n';
os_hex << val << '\n';
os_oct << val << '\n';
(void)getchar();

}
}

---------------

class Ostream {

public:
Ostream& operator<<(int);
Ostream& operator<<(float);
Ostream& operator<<(std::streambuf *); //bu ne yapar

}

-------------

int main()
{
using namespace std;

ostringstream oss;

for (int i = 0; i < 10; ++i) {
oss << i << " ";
}

cout << oss.rdbuf() << "\n";

}

---------------

//mülakatlarda necaati hocanın sorduğu soru

//bir dosyayı standart outputa yazdırmak istiyoruz
//main.cpp yazdırmak mesela

int main()
{
using namespace std;

ifstream ifs{"odevler.cpp"};

cout << ifs.rdbuf();
}

-------------

//dosyanın kopyasını da çıkarabiliriz

int main()
{
using namespace std;

ifstream ifs{"odevler.cpp"};

ofstream ifs{"man.cpp"};

ofs << ifs.rdbuf();
}

============================================================

Dosya işlemleri
===============

ostream sınıfından kalıtım yoluyla elde edilmiş ofstream sınıfı var

std::ofstream : yazma işlemi yapacağımız dosyaları kontrol etmek istediğimizde kullanırız

-------

istream sınıfından kalıtım yoluyla elde edilmiş ifstream sınıfı var

std::ifstream : dosyaları okuma amaçlı kullanıcaksak

--------

iostream sınıfından kalırım yoluyla elde edilmiş fstream 

std::fstream : hem okuma hem yazma işlemlerini yapar


------------------------------

// 2 seçenek vardır

- ya dosya nesnesi oluşturup (ifstream, ofstream nesnesini oluturucağız fakat daha sonra open fonksiyonuna çağrı yaparak fonksiyonu çağırıcağız)
- ya da ctor doğrudan dosya açmasını sağlıycaz

bu 2 seçenekte bizden 
açılacak dosya ismi ve açış modu (her zmana default param. alır) ister

------------------------------

modern c++ öncesinde c_str() kullanılıyordu

------------

int main()
{
using namespace std;

std::string filename{ "furkanmert.txt" };

// ofstream ofs{filename.c_str()}; //bu kodlar eski
}

-----------

int main()
{
using namespace std;

std::string filename{ "furkanmert.txt" };

//ios_base::openmode //aşağıdakiler yapılabilir
//ios_base::in
//basic_ios<char>::in
//ios::in 


ofstream ofs{ filename};
}

-----------------------
dosyanın açıs modunun belirlenmesi:
//hepsnin default argümanı var

ios::in //eğer in parametresi geçersek okuma amaçlı açma
ios::out //yazma
ios::app //append / sona yazma
ios::trunc //truncate
ios::ate //at end
ios::binary //binary olarak açmak için

"r" //read
"w" //write
"a" //app

----------------

int main()
{
using namespace std;

ofstream ofs{"ali.txt", ios::trunc | ios::oust };
ofstream ofs{"ali.txt"}; //Yukarıdaki ile aynı anlamda

ifstream ofs{"ali.txt"};
ifstream ofs{"ali.txt", ios::in}; //aynı anlamda

}

---------------------

//c ile karşılaştırma

fopen ios::openmode

in, equivalent of "r"

out, equivalent of "w"

app, equivalent of "a”

out|in, equivalent of "r+" //hem okuma hem yazma

out|in|trunc, equivalent of "w+" //yazma 

out|in|app, equivalent of "a+" //doysa yok ise açılacak 

binary|in, equivalent of "rb" 

binary|out, equivalent of "wb"

binary|app, equivalent of "ab"

binary|out|in, equivalent of "r+b"

-------------------

int main()
{
using namespace std;

ofstream ofs{"bugra.txt"}; //default olarak yukarıdaki yazıldı

//dosya açılıp açılmadığını kontrol et açılmayabilir

if (!ifs) {
//if (ifs.fail()) //bu şekilde de olabilir
//if (!ifs.good()) //bu şekilde de olabilir
cerr << "cannot open file\n";
return 1;
}
std::cout << "file opened successfully";
}

----------------
//karıştırılan bir yer

open //dosya açma

is_open // bool döndürür, açık dosya var mı?

-----------------

int main()
{
using namespace std;

ifstream ifs;

boolalpha(cout);

cout << "ifs.is_open() = " << ifs.is_open() << "\n";

ifs.open("main.cpp");

cout << "ifs.is_open() = " << ifs.is_open() << "\n";

ifs.close();
cout << "ifs.is_open() = " << ifs.is_open() << "\n";
}

--------------
//aşağıdaki şekilde de öğrenilebilir

int main()
{
using namespace std;

ofstream ofs{"bugra.txt"}; //default olarak yukarıdaki yazıldı

if (!ifs.is_open()) {
cerr << "cannot open file\n";
return 1;
}

std::cout << "file opened successfully";
}

---------------
!! dosya kapatmaya gerek yoktur RAII idiomu sayesinde dtor dosyayi kapatır

int main()
{
using namespace std;

ofstream ofs{"bugra.txt"};

if (!ofs) {
cerr << "dosya olusturulamadi\n";
return 1;
}

for (int i = 0; i < 100; ++i) {
ofs << i << " ";
}
}

-----------
//daha erken kapatmak istrsek nested scope kullanabiliriz

int main()
{
using namespace std;

{
ofstream ofs{"bugra.txt"};

if (!ofs) {
cerr << "dosya olusturulamadi\n";
return 1;
}

for (int i = 0; i < 100; ++i) {
ofs << i << " ";
}
}
}

-----------

//close fonksiyonu çağırabilir ya da

int main()
{
using namespace std;

ofstream ofs{"bugra.txt"};

if (!ofs) {
cerr << "dosya olusturulamadi\n";
return 1;
}

for (int i = 0; i < 100; ++i) {
ofs << i << " ";
}
ofs.close();
}

//Yeni bir dosya açabiliriz ancak good durumda olması gerekir

---------------

int main()
{
using namespace std;

ofstream ofs{"bugra.txt"}; //dosya oluşturur

if (!ofs) {
cerr << "dosya olusturulamadi\n";
return 1;
}

for (int i = 0; i < 100; ++i) {
ofs << i << '\n';
}
}

---------------

int main()
{
using namespace std;

ofstream ofs{"bugra.txt"}; //dosya oluşturur

if (!ofs) {
cerr << "dosya olusturulamadi\n";
return 1;
}

Irand myrand {0, 300'=00};

for (int i = 0; i < 10'000; ++i) {
ofs << myname() << " " << myfname() << " " << rfname() << " " << rtown() << '\n';
}
}

---------------
#include <iomanip>

int main()
{
using namespace std;

ofstream ofs{"bugra.txt"}; //dosya oluşturur

if (!ofs) {
cerr << "dosya olusturulamadi\n";
return 1;
}

Irand myrand {0, 300'000};

ofs << left;

for (int i = 0; i < 10'000; ++i) {
ofs << setw(12) << myname() << " " << myfname() << " " << rfname() << " " << rtown() << '\n';
}
}

---------------

cpp 20 kullanılıyorsa format kütüphanesini kullan



----------------------------

biraz format kütüphanesine bakıyoruz

int main()
{
using namespace std;

int x = 10, y = 20, z = 56;

cout << format("{} {} {}\n", x,y,z);
cout << format("{2} {0} {1}\n", x,y,z);
cout << format("{}\n", true); //default format state true durumda
}


--------------------------
format sıralaması aşağıdaki şekildedir

[fill]align] [sign][#][0][width][.precision][type]
//doldurma, hizalama, işaret, dies, başını 0 ile besleme, genişliş, precision , tür
--------------------------
#include <format>

int main()
{
using namespace std;

ofstream ofs{"bugra.txt"}; //dosya oluşturur

if (!ofs) {
cerr << "dosya olusturulamadi\n";
return 1;
}

Irand myrand {0, 300'000};

ofs << left;

for (int i = 0; i < 10'000; ++i) {
ofs << format("{:<9} {:<16} {:<20} {}", myrand(), rname(), rfname(), rtown());
//hizalama ve width seçtik sadece diğerlerini default yaptık
//cpp 23 ile prrint geldi
//print(ofs, "{:<9} {:<16} {:<20} {}", myrand(), rname(), rfname(), rtown());
}
}

-------------------

ilk 100'000 asal sayıyı primes.txt dosyasina formatli olarak yazin

constexpre int n = 100'000;

int main()
{
using namespace std;

std::ofstream ofs{"primes.txt"};
if (!ofs) {
std::cerr << "out.txt dosyasi olusturulamadi\n";
exit(EXIT_FAILURE);
}

int x{2};
int prime_count{};

while (prime_count < n) {
if (isprime(x)) {
if (prime_count && prime_count % 10 == 0)
ofs << '\n';
ofs << std::format("{:<12}", x);
++prime_count;
}
++x;
}
}

-----------------

int main()
{
using namespace std;

vector<string> svec;
rfill(svec, 10000, rname);

std::ofstream ofs{"names.txt"};
if (!ofs) {
std::cerr << "out.txt dosyasi olusturulamadi\n";
exit(EXIT_FAILURE);
}

/*for (const auto& name: svec) {
ofs << name << '\n';
}*/

/*size_t len{};
std::cout << "uzunlugu kac olanlar: ";
cin >> len;

copy_if(svec.begin(), svec.end(), ostream_iterator<string>{ofs, '\n'}, [len] (const string &s){
return s.lenght() == len && s.front() == 'a';
});*/


copy(svec.begin(), svec.end(), ostream_iterator<string>{ofs, '\n'});
}

-------------------

int main()
{
using namespace std;

std::ofstream ofs{"names.txt"};
if (!ofs) {
std::cerr << "out.txt dosyasi olusturulamadi\n";
exit(EXIT_FAILURE);
}

generate_n(ostream_iterator<string>{ofs, "\n"}, 1000, []{return rname() + ' ' + rfname();})

}

-----------------------------------

okuma işlemleri:

formatlı okuma

int main()
{
using namespace std;

ifstream ifs{"primes.txt"};
if (!ifs) {
cerr << "dosya acilamadi\n";
return 1;
}

int ival;

//while ((ifs >> ival).operator bool ()
while (ifs >> ival) { //dosyadan okuyup birer boşlukla standart outputa yazarız
cout << ival << ' ';
}
}

------------------

int main()
{
using namespace std;

ifstream ifs{"primes.txt"};
if (!ifs) {
cerr << "dosya acilamadi\n";
return 1;
}

string word;

while (ifs >> word) {
cout << word << ' ';
}
}

-------------------------

ofstream ifstream kopyalamaya karşı kapalı taşımaya karşı açık

-----------------------

void func(std::ifstream);

int main()
{
using namespace std;

ifstream ifs{"kutay.txt"};
if (!İfs) {
cerr << dosya acilamadi\n";
return 1;
}

func(ifs); //Hata
func(move(ifs); //legal
}

-----------------------
nutility.h fonksiyon ekliyourz



std::ifstream open_text_file(const std::string& filename);

nutility.cpp:

std::ifstream open_text_file(const std::string& filename);
{
std::ifstream ifs{filename};
if (!ifs) {
throw std::runtime_error{filename + "dosyasi acilamiyor!\n"};
}

return ifs; //Hata yok
//return move(ifs) //pesimistik move olur hatalı
}

----
.h
std::ofstream create_text_file(const std::string& filename);
.cpp
std::ofstream create_text_file(const std::string& filename)
{
std::ofstream ofs{filename};
if (!ifs) {
throw std::runtime_error{filename + "dosyasi olusutulamıyor!\n"};
}

return ofs
}

int main()
{
using namespace std;

try
{
    auto ofs = create_text_file("serhat.txt");
    auto ofs = open_text_file("serhat.txt");

}
catch(const std::exception& e)
{
    std::cerr << e.what() << '\n';
}
}

-----------------

int main()
{
using namespace std;

int ival = 2345;
string name {"serhatistin"};

ostringstream oss;

oss << name << '_' << ival << ".txt";

cout << oss.str() << "\n";
}

------------
//aşağıdaki şekilde olabilir

int main()
{
using namespace std;

int ival = 2345;
string name {"serhatistin"};

auto filename = (ostringstream{} << name << '_' << ival << ".txt").str

cout << filenmae
}

--------------

int main()
{
using namespace std;

int ival = 2345;
string name {"serhatistin"};

ofstream{"out.txt"} << "bugun hava cok soguk"; //gecerli

}

--------------

int main()
{
using namespace std;

std::ofstream ofs{"out.txt"};
if (!ofs)
{
std::cerr << "ot.txt dosyasi olusturulamadi\n";
exit(EXIT_FAILURE);
}

for (int i = 0; i < 10; ++i) {
ofs << Date::random() << '\n';
// cout << //bu şekilde yapssak standart outputa yazar
}
}

-----------------

diğer okuma yazmaişlemlerine bakıyoruz

c kodu yazıyoruz

int main()
{
using namespace std;

FILE* f = fopen("main.cpp", "r");
if (!) {
fprintf(stderr, "dosya acilamadi\n");
return 1;
}

int c;

while ((c = fgetc(f)) != EOF) {
putchar(c);
}
fclose(f);
}

------------
yukarıdakini c++ kodu yazpıyoruz

int main()
{
using namespace std;

ifstream ifs{"main.cpp"};

if (!ifs) {
cerr << "dosya acilamadi\n";
return 1;
}

int c;

while ((c = ifs.get()) != EOF) {  
//cout << c; //bu şekilde karakter kodunu yazar
cout << static_cast<char>(c);
//cout.put((char)c); //bu şekilde de olur
}
}

-------------------
yukarıdaki kod bu şekilde de yazılır

int main()
{
using namespace std;

ifstream ifs{"main.cpp"};

if (!ifs) {
cerr << "dosya acilamadi\n";
return 1;
}

char c;

while (ifs.get(c))
cout.put(c);

}

---------------

int main()
{
using namespace std;

auto ifs open_text_file("kutay.txt");

char c;

while (ifs.get(c))
cout.put(c);
}

---------------

int main()
{
using namespace std;

auto ifs open_text_file("kutay.txt");

char c;

cout << ifs.rdbuf();
}

-----------------

getline : satır satır okumak için

int main()
{
using namespace std;

auto ifs = open_text_file("kutay.txt");

string sline;

getline(ifs, sline);

cout << "[" << sline << "]";
}

----------------

int main()
{
using namespace std;

auto ifs = open_text_file("kutay.txt");

string sline;

while (getline(ifs, sline)) {
cout << sline;
(void)getchar();
}
}

---------------

int main()
{
using namespace std;

auto ifs = open_text_file("kutay.txt");

string sline;

while (getline(ifs, sline)) {
reverse(sline.begin(), sline.end());
cout << sline;
getchar();
}
}

----------------
//mülakatlarda getline bilinip bilinmediğini öğrenmek için yapılır

int main()
{
using namespace std;

auto ifs = open_text_file("kutay.txt");

string name;

while (getline(ifs, name, 'i')) { //extract eder stringe almaz yani siler i harfi olan yerleri
cout << name << '\n';
}
}

---------------

//bu sık dosya işlemlerinde ihtiyaç duyulan özellikler

//dosyadaki satırları contaniera atmak

//sıralı olarka yazdırmak : vektöre atanır satır satır, sonra sort ile sıralanır

int main()
{
using namespace std;

vector<string> linevec;

linevec.reserve(10'000u);

auto ifs = open_text_file("kutay.txt");
string sline;

while (getline(ifs, sline)) {
linevec.push_back(sline);
}

/*
while (getline(ifs, sline)) {
linevec.push_back(move(sline)); //bu şekilde yapılabilir
}
*/

sort(linevec.begin(), linevec.end());
copy(linevec.begin(), linevec.end(), ostream_iterator<string>{cout, "\n"});
}

-----------------------

//mülakatlarda kod rewiuv yaptırılıyor

-----------------------

//.txt' de k100'000 asal sayıyı primvec isimil vectöre al nasıl yazılır

int main()
{
using namespace std;

auto ifs = open_text_file("primes.txt");

vector<int> ivec;
ivec.reserve(100'000);

int ival;

while (ifs >> ival) { //>> bu işareti anlamaya çalış neden kouyuyor, geçen derste ilk defa kullandı sanırım
ivec.push_back(ival);
}
}

---------------

//aşağıdaki şekilde de yapılabilir

int main()
{
using namespace std;

auto ifs = open_text_file("primes.txt");


vector<int> ivec{istream_iterator<int>{ifs}, {}};

cout << "ivec.size() = " << ivec.size() << '\n';
}

--------------
//bu şekilde de yapılabilir

int main()
{
using namespace std;

auto ifs = open_text_file("primes.txt");

vector<int> ivec;
ivec.reserve(100'000);

ivec.assign(istream_iterator<int>{ifs}, {});

}

-------------------------------------------
//bunu tekrar et videodan

formatsız okuma yazma

!! formatsız okuma yazma yapılacak ise dosya binary modda açılmalı

int main()
{
using namespace std;

ofstream ofs{"primes.dat", ios::binary };

int prime_count = 0;
int x = 2;

while(prime_count < 1'000'000) {
if (isprime(x)) {
ofs.write(reinterpret_cast<char*>(&x), sizeof(int))
++prime_count;
}
++x;
}
}





