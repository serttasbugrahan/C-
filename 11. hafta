//////////////////////////////////////////////////////////////////////1. Ders//////////////////////////////////////////////////////////////////////////

int main()
{
using namespace std;

string name{ "mert" };
string surname{ "kaptan" };

auto s = name + ' ' + surname + "oglu";
//operator+(operator+(name, ' '), surname), "oglu");
}

-------

c++ içindeki c'yi bilmeyenlerin yaptığı bir hata

int main()
{
using namespace std;
string name{ "mert" };

const char* p = "can";
name + "yasar" + "can"; //
"yasar" + p + name //hata 2 pointer toplanıyor
}

--------

int main()
{
using namespace std;
int x{}, y{};

int* p1 = &x;
int* p2 = &y;

p1 + p2;
}

---------------------------------

string sınıfı yazılardan sayılara
sayılardan yazılara dönüşüm olanapı verir

int main()
{
using namespace std;

to_string()
int ival{};
cout << "bir tam sayi giriniz: ";
cin >> ival;

auto str = to_string(ival);
cout << '|' << str << '|';

}

-------

int main()
{
using namespace std;

int ival{};
cout << "bir tam sayi giriniz: ";
cin >> ival;

string str;
int x = 56;
str = x; //operator=(char)
}

--------

int main()
{
using namespace std;

string s{ "ali23874furkan" };
cout << "|" << s << "|\n";
try
{
auto ival = stoi(s)
auto ival = stoi(s)
  cout << "ival = " << ival << "|\n";
}
catch(const std::exception& ex)
{
	std::cout << "expection caught: " << ex.what() << '\n';
}
}

-----------

int main()
{
using namespace std;

string s{"23874furkan" };

size_t idx{};
auto ival = stoi(s, &idx);

cout << "ival = " << ival << '\n';
cout << "idx = " << idx << '\n';
}

------------
//aşaüıdaki örnekler sadece string sınıfına özel değildir 
containerlara özeldir

#include <algorithm>

int main()
{
using namespace std;

string str;

std::cout << "bir yazi girin: ";
getline(cin, str);
char c = 'e';
auto n = count(str.begin(), str.end(), c)

cout << "n = " << n << '\n'; 
}

--------

#include <algorithm>

int main()
{
using namespace std;

string str;

std::cout << "bir yazi girin: ";
getline(cin, str);

cout << "|" << str << "|\n";
reverse(str.begin(), str.end());
cout << "|" << str << "|\n";
}

---------

int main()
{
using namespace std;
string str;

std::cout << "bir yazi girin: ";
getline(cin, str);

cout << "|" << str << "|\n";

auto n = erase(str, 'e');

cout << "|" << str << "|\n";
cout << "n = " << n << "|\n";

}

=======================================================================

expection handling
-------------------

kod yanlış yazılmış ==> programming errors (cpding errors)

kodlama hataları ile başa çıkmanın en temel yolu assertions (doğrulama)

assertions (doğrulama)
    dynamic assertions (runtime)
    static assertions (compile time)

---------

c dilinde aşağıda ki şekilde yapıyorduk

#
assert(x > 0);

void func(int *ptr)
{
assert(ptr != NULL);
assert(b != 0);
int x = a / b;
}

-------

c11 ile gelen static assert

static_assert(sizeof(int) > 2);

int main()
{

}

----------------
geleneksel hata işleme:
-----------------------

eğer fonksyion işini yapamadığını 
kendisini çağıran koda bir şekilde bildiriyorsa buna geleneksel hata işleme nedir

1. dezavantaj : iş gören kod ile hata işleyen kodun iç içe geçmesi
kodun anlaşılması vs. her şey zorlaşır

2. dezavantaj : hatanın fonksiyon tarafından kendisini çağıran koda bildirilmesi

f1 ==> f2 ==> f3 ==> f4 ==> f5, bu fonksiyonlar birbirini çağırdığı için hata f1 hatası her yerde gözükebilir

böyle bir durumda f5'te gözüken hata f1' e geçmeli

f1 ==> f2 ==> f3 ==> f4 ==> f5
<-----------------------------

3.dezavantaj : zorlayıcı bir mekanizmanın olmaması

------------

en büyük risk ctor'lardır çünkü geri dönüş değeri yoktur

----------------------------------

expection handling araçları : çalışma zamanı hatalarının ele alınması
-----------------------------

throw 
try 
catch

--------

throw : işimi yapamamakla ilgili bilgiyi size ieticek bir nesne oluşturdum ve bu nesneyi size göderiyorum
   throw statement	

try block : bir hata göderilirse ben bu hatayı yakalamakla görevliyim demektir
try {

}

catch block : hataya müdahale eden kodu temsil ediyor (exception handler)

---------

try {
f1();
}
catch(int) { //birden fazla catch olabilir

}
catch(long) { //long türünden ise buraya

}
catch(double) { //double türünden ise buraya

}

--------
to catch an exception
uncaught exception
--------

bit hata nesnesi gönderildi
ve bu hata nesnesi yakalanamadi
bu durumda ne olur?

uncaught exception olur bu durumda
std::terminate çağrılır, std::terminate'de 
abort çağırır

---------

using terminate_handler = void (*)();
typedef void (*terminate_handler)();

terminate_handler set_terminate(terminate_handler);

------------------

void f4()
{
	std::cout << "f4 cagrildi\n";
	throw 1; // program burada biticek
	std::cout << "f4 sona erdi\n ";
}

void f3()
{
	std::cout << "f3 cagrildi\n";
	f4();
	std::cout << "f3 sona erdi\n";
}

void f2()
{
	std::cout << "f2 cagrildi\n";
	f3();
	std::cout << "f2 sona erdi\n";
}

void f1()
{
	std::cout << "f1 cagrildi\n";
	f2();
	std::cout << "f1 sona erdi\n";
}

int main()
{
	std::cout << "main basladi\n";
	f1();
	std::cout << "main sona erdi\n";
}

---------------

void myabort()
{
	std::cout << "myabort cagrildi\n";
	exit(EXIT_FAILURE);
}
void f4()
{
	std::cout << "f4 cagrildi\n";
	throw 1; // program burada biticek
	std::cout << "f4 sona erdi\n ";
}

void f3()
{
	std::cout << "f3 cagrildi\n";
	f4();
	std::cout << "f3 sona erdi\n";
}

void f2()
{
	std::cout << "f2 cagrildi\n";
	f3();
	std::cout << "f2 sona erdi\n";
}

void f1()
{
	std::cout << "f1 cagrildi\n";
	f2();
	std::cout << "f1 sona erdi\n";
}

int main()
{
set_terminate(&myabort);
std::cout << "main basladi\n"
f1();
std::cout << "main sona erdi\n"
}

------------

//exception main içinde de yakalanabilir

void myabort()
{
	std::cout << "myabort cagrildi\n";
	exit(EXIT_FAILURE);
}
void f4()
{
	std::cout << "f4 cagrildi\n";
	throw 1; // program burada biticek
	std::cout << "f4 sona erdi\n ";
}

void f3()
{
	std::cout << "f3 cagrildi\n";
	f4();
	std::cout << "f3 sona erdi\n";
}

void f2()
{
	std::cout << "f2 cagrildi\n";
	f3();
	std::cout << "f2 sona erdi\n";
}

void f1()
{
	std::cout << "f1 cagrildi\n";
	f2();
	std::cout << "f1 sona erdi\n";
}

int main()
{
std::cout << "main basladi\n";
try { //eğer try bloğu içinde çalışan koddan hata nesnesi göderilirse
f1();
}
catch(int) { //ve gönderilen hata nesnesinin türü int ise programın akış
//buraya çekilicek
std::cout << "hata yakalandi(catch(int)\n";
}

std::cout << "devam ediyor\n";
}

!! dönüşüm olmaz catch int ise throwda int olmak zorunda

-------------

void myabort()
{
	std::cout << "myabort cagrildi\n";
	exit(EXIT_FAILURE);
}
void f4()
{
	std::cout << "f4 cagrildi\n";
	throw 1; // program burada biticek
	std::cout << "f4 sona erdi\n ";
}

void f3()
{
	std::cout << "f3 cagrildi\n";
	f4();
	std::cout << "f3 sona erdi\n";
}

void f2()
{
	std::cout << "f2 cagrildi\n";
	f3();
	std::cout << "f2 sona erdi\n";
}

void f1()
{
	std::cout << "f1 cagrildi\n";
	f2();
	std::cout << "f1 sona erdi\n";
}

int main()
{
std::cout << "main basladi\n";
try { 
}
catch(int) { 
std::cout << "hata yakalandi(catch(int)\n";
}
catch(unsigned int) { 
std::cout << "hata yakalandi(catch(int)\n";
}
catch(float) { 
std::cout << "hata yakalandi(catch(int)\n";
}
catch(double) { 
std::cout << "hata yakalandi(catch(int)\n";
}
std::cout << "devam ediyor\n";
}

---------------------

2 ayrı throw vardır

throw; //rethrow

throw MathError{} //matematik ile ilgili bir hata

throw std::bad_alloc{} //allocation ile ilgili bir hata var demek

-------------------

	       ExceptionBase

MathException  StringException  FileException
		    FileReadException FileWriteException



--------------------

void myabort()
{
	std::cout << "myabort cagrildi\n";
	exit(EXIT_FAILURE);
}
void f4()
{
	std::cout << "f4 cagrildi\n";
	throw DivideByZero{};
	std::cout << "f4 sona erdi\n ";
}

void f3()
{
	std::cout << "f3 cagrildi\n";
	f4();
	std::cout << "f3 sona erdi\n";
}

void f2()
{
	std::cout << "f2 cagrildi\n";
	f3();
	std::cout << "f2 sona erdi\n";
}

void f1()
{
	std::cout << "f1 cagrildi\n";
	f2();
	std::cout << "f1 sona erdi\n";
}

int main()
{
std::cout << "main basladi\n";
try { 
}
catch(DivideByZero&) //değişkeni kullanmıycan isim verme
{ //upcasting vardır ExBase& dahil hepsini yakalayabilir
std::cout << "hata yakalandi\n";
}
std::cout << "devam ediyor\n";
}

-----------------

//out_of_range ==> logic_error ==> exception

void f4()
{
	std::cout << "f4 cagrildi\n";
	std::string str{"emrecan"};

	auto c = str.at(456);
	std::cout << "f4 sona erdi\n ";
}

void f3()
{
	std::cout << "f3 cagrildi\n";
	f4();
	std::cout << "f3 sona erdi\n";
}

void f2()
{
	std::cout << "f2 cagrildi\n";
	f3();
	std::cout << "f2 sona erdi\n";
}

void f1()
{
	std::cout << "f1 cagrildi\n";
	f2();
	std::cout << "f1 sona erdi\n";
}

int main()
{
std::cout << "main basladi\n";
try { 
f1();
}
catch(const std::exception& ex) //bütün hataları yakalar
//    const std::logic_error& ex) //logic hataları yakalar	
//    const std::out_of_range& ex) //out_of_range hataları yakalar	
{
std::cout << "hata yakalandi\n" << ex.what() << "\n";
}

std::cout << "devam ediyor\n";
}

--------------
//bu yapı lojik açıdan yanlış çünkü en üsttteki genel olarak yakaladağı için
aşağıdakilere şans bırakmaz
int main()
{
std::cout << "main basladi\n";
try { 
f1();
}
catch(const std::exception& ex) 
{
std::cout << "hata yakalandi\n" << ex.what() << "\n";

}
catch const std::logic_error& ex)
{
std::cout << "hata yakalandi\n" << ex.what() << "\n";

}
catch const std::out_of_range& ex) 	
{
std::cout << "hata yakalandi\n" << ex.what() << "\n";
}

std::cout << "devam ediyor\n";
}

-------------

özel bir catch yapısı

int main()
{
std::cout << "main basladi\n";
try { 
f1();
}
catch(...)  //catch all, hangi türden olursa olsun tüm hataları yakalar
{
}

