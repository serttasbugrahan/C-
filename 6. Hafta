/////////////////////////////////////////////1. Ders///////////////////////////////////////////////

sınıfların statik veri elemanlarına devam
-----------------------------------------

class Nec {
public:
static int mx; //bunu kullanmak için nesne elemanına gerek yok
};

int main()
{
Nec n1, n2;
n1.mx = 10;
n2.mx = 56;
auto p = &n1;
p->mx = 854;
}

----------
!!tanımda static anahtarını kullanırsak sentax hatası olur
!! array ise arrayin boyutunu yazmaya gerek yok
//nec.h

class Nec {
public:
static int a[];
};

----------

incloplete type : türün varlığından haberdar ancak henüz onun tanımını görmemişse ise

//forward declaration
class Myclass;

int main()
{
//1 incoplete type
}

----
class Neco foo(class Ali);

int main()
{

}

---------------

incomplete type ile neler yapabiliriz?

//fonksiyon bildirimlerinde kullanarabiliriz

class Neco;

Neco foo(Neco);
Neco& bar(Neco&);
Neco* baz(Neco *, int);

//type alias declaration yapabiliriz

typedef Neco* NecoPtr;
typedef Neco& NecRef;
using NecoPtr = Neco *;

//pointer ya da referans değişkenler tanımlayabiliriz

class Ali;

Ali * foo();
Ali& bar();
void baz(Aki &r);

int main()
{
Ali *p = foo();
Ali& r = bar();
baz(r);
}

//extern bildirimi yapabiliriz

class Emre;

extern Emre ge;
extern Emre ga[];

//sınıfların static veri elemanlarında kullanılabilinir

class Nec;

class Myclass {

static Nec snec;
};

//C dili için

struct Data {
int mx;
struct Data sdata; //sentax hatası olur kendi türünden elemanı olamaz
static Data sdata; //legal
};

//c++ dili için

class Nec {
int mx;
Data sdata; //illegal
static Data sdata; //legal
};

!! void is an incomplete type

-------------------

incomplete type ile neler yapılamaz ?

//değişken tanımlayamayız

class Nec;

int main()
{
Nec mynec; //hata
}

//

class Mert;

class Nec {

private:
Mert mx; //hata
}

//pointer değişken tanımlayabiliriz ama içerik ve ok operatörü ile kullanamayız

class Mert;

Mert* foo();

int main()
{
Mert* p == foo();
*p //hata
p-> x = 5; //hata
}

//sizeof operatörünün operandı yapamam

class Mert;

Mert* foo();

int main()
{
sizeof(Mert);
}

-------------

sınıfların static elemlarına dönüyoruz...

class Myclass {

static int x; //bu bir tanımlama değil bunu bir tanım haline getirmek için bazı kurallar var
};

-------

class Myclass {
public:
static int x;
};

int main()
{
Myclass::x = 5; //bu şekilde tanımı yapılabilinir
}

--------

neco.h
int x = 0; //odr ihlal edilir
inline int x = 0;  //odr ihlal edilmez, eskiden bu sadece fonksiyonlar için bir haktı (c++17 öncesi)

-------
//header-only library

class Myclass {
static std::vector<int> x{1,2,4,6,8}; //geçersiz
inline static std::vector<int> x{1,2,4,6,8}; //geçerli

};

-------

class Myclass {

public:
static std::string version;
};

int main()
{
Myclass::version = "1.02.05"; //linked hatası olur
}

-----

class Myclass {

public:
inline static std::string version; //hata kalkar
};

int main()
{
Myclass::version = "1.02.05"; 
}

-----------------------

inline kısa bir tekrarı:

global değişkenler tanımlandıkları zaman odr uymak zorundalar

bir projede birden fazla kaynak dosyada aynı global değişkeni tanımlayamayız 

eğer bir isim dış bağlantıda ise bütün kaynak dosyalarda aynı varlığa ilişkin olmalı

odr: varlıkların birden fazla bildirimi olabilir ama tek tanımı olmak zorunda

//emre.h

void func(int) //odr ihlal edilir

int x = 10; //odr ihlal edilir, başka dosyalar bu dosyayı include ettiğinde odr çiğnenmiş olur

ama inline kullanırsak bundan bir tane olucak demektir

//ali.h
inline void func(int x) //odr ihmal edilmiycek
{

}

//ali.cpp
inline void func(int x)
{

}   

//veli.cpp
inline void func(int x)
{

}   

//hasan.cpp
inline void func(int x)
{

}   

!! birden fazla dosyada kullanılmasına rağmen odr ihmal edilmemiş olur

//myclass.h
class Myclass {

inline static int sx = 10; //cpp(17) ile geldi
};

---------------------

//myclass.h
class Myclass {

static const int sx = 6;
};

!! sınıfların static, const ve intergral type veri elemanlarına sınıf içinde
ilk değer verilebilir

class Nec {
static const double x = 6; //bu şekilde olmaz int olması gerekir
};


-----

class Nec {
static constexpr double x = 5.4; 
//constexpr değişkenler
//tıpkı constexpr fonksiyonlarda olduğu gibi implcitly inline
};

-----

  class Nec {
  public:
  static int mx;
  };
  
  int main()
  {
  Nec mynec; //isim aramanın başarılı olabilmesi içib bu şekilde veya aşağdaki şekilde yapılmalı
  Nec *p{&mynec};
  Nec::mx;//ya da bu şekilde
  
  p->mx
  //mynec.mx
  }

----------

class Nec {
public:
static int mx;
};

int Nec::x{}; //Nec'in x'i 0 değeri ile başlar

int main()
{
Nec n1;
Nec n2;
Nec n3;
Nec n4;

++n1.x;
++n2.x;
++n3.x;
++n4.x;

std::cout << "Nec::x = " << Nec::x << '\n';
}

-------------

class Nec {
public:
void func()
{
x = 5; //hepsi legal
Nec::x = 5;
this-> = 5;
}
private:
static int x;
};

-------

class Nec {
public:

void foo()const
{
x = 6; //legal staticden dolayı
}
void func()
{
x = 5; //hepsi legal
Nec::x = 5;
this-> = 5;
}
private:
static int x;
};

-------

class Nec {
public:
Nec(int i) : x(i) {} //illegal
private:
static int x;
};


--------
  class Nec {
public:
int x;
static int y;
  
private:

};

int x = 5;
int Nec::y = x; //hata

--------

class Nec {
public:
int x;
static int y;
  
private:

};

Nec g;
int x = 5;
int Nec::y = g.x; //legal

-------------------------------------------------

sınıfların static üye fonksiyonları (static member functions):
--------------------------------------------------------------

//static üye fonksiyonları
a) class scope'dadır

class Nec {
public:
static void foo() //global fonksiyon ama class scobe'a alınmış demek
{

}
private:
int mx;
};

void bar()
{
Nec mynec;
mynec.mx = 5; //erişim hatası
}


int main()
{
bar(); //bar bu şekilde çağrılır
Nec::foo(); //foo bu şekilde çağrılır
}

--------

class Nec {
public:
static void foo() 
{
Nec mynec;
mynec.mx = 5; //sınıfın member fpnksiyonu erişebilir
}
private:
int mx; //hata olmaz
};

void bar()
{

}

--------

class Nec {
public:
static void foo() const{} //hata olur, buradaki const gizli parametre değişkenini niteler

}
private:
int mx;
};

------

class Nec {
public:
static void foo()
{
this; //this kullanımı hertürlü sentax hatası olur
}

private:
int mx;
};

--------
//sınfların static veri elemanları sınıfların non-static veri elemanlrını bu şekilde kullanamaz
class Nec {
public:
static void foo()
{
mx = 5; //Hata, this olmadan böyle bir şey yapamayız
}
private:
int mx;
};

--------

class Nec {
public:
static void foo()
{
Nec mynec;
mynec.mx = 5; //bu şekilde legaldir
}
private:
int mx;
};

---------

class Nec {
public:
static void foo()
{
mx = 5; //legal
Nec::mx = 5; //legal
}
private:
static int mx;
};

-------

class Nec {
public:
static void foo()
{

}

void bar()
{
foo(); //legal
Nec::foo(); //aynı anlamda , Nec'in foo()'su demektir  
}
private:
static int mx;
};

------

class Nec {
public:
static void foo()
{

}
};

int main()
{
Nec mynec;
mynec.foo(); //legal
}

-------

class Nec {
public:
static void foo()
{

}
void bar()
{
this->foo(); //legal
}
};

------

class Nec {
public:
static void foo()
{

}
void bar const()
{
foo(); //legal
}
};

-------

class Nec {
public:
static void foo()
{
bar() //illegal
Nec mynec
mynec.bar();//legal
}
void bar()
{

}
};

----------

class Nec {
public:
static void foo()
{

}
void bar()
{
this->foo(); //legal
}
};

--------
//mülakatlarda sorulan tipik bir soru

class Nec {
public:
static double foo()
{
return 3.9;
}
static int ival;
};


int foo()
{
return 2;
}

int Nec::ival = foo(); //isim arama kurallarından dolayı ilk baş class scope'da aranır

int main()
{
std::cout << Nec::ival << '\n';
}


--------------------------------

static veri elemanlarının kullanıldığı alanlar:
----------------------------------------------

class Person {
std::vector<int> x; //her personun ayrı bir int dizisi var
static std::vector<int> x; //bu şekilde personların ortak bir int nesnesi olur
};

-------------
mesela student sınıfında öğrencinin sınavlardan aldığı notların ortalamsını veren fonksiyon olsa
bu fonksiyon non-static olması gerekir her öğrencinin ayrı olabilmesi içn
öğrencilere toplamda kaç tane sınav yapılmış bunu static yapmamız gerekir
-------------
//mülakatlarda sorulabilinen temalar

//named contructor

class Myclass {
public:
static Myclass create_Object();
};

int main()
{
auto m1 = Myclass::create_object();
}

-------------

class Complex {

public:
Complex(double r, double i); //bu şekilde hata olur aynı isimden dolayı
Complex(double a, double d);

};

------

class Complex {
public:
static Complex create_polar(double a, double d)
{
return Complex(a, d, 0);
}

static Complex create_cartesian(double r, double i);
{
return Complex(r, i);
}

private:
Complex(double, double); //cartesian
Complex(double, double, int); //polar
};


int main()
{
auto c1 = Complex::create_cartesian(3.5, 1.2);   
auto c2 = Complex::create_polar(.2352, 4.5767);   
}

----------
//dinamikmmürlü nesne zorunluluğu 
//private ypmaz isek herkes istediği gibi nesne oluşturabilir

class DynamicOnly {

public:
DynamicOnly(const DynamicOnly&) = delete;
DynamicOnly& operator=(const DynamicOnly&) = delete;

Dynamic* create_object()
{
return new DynamicOnly{};
}

private:
DynamicOnly();
};



----------------------------

singleton :tasarım desenidir bir sınıf türünden tek bir nesne olucak ve o nesneye global bir erişim olucak

mesela 1 tane server var, 2 tane olması program domaine aykırı bu durumda sigleton kullanılır, servere singleton ismi verilir

class Singleton {

public:
Singleton(const Singleton&) = delete; //copyalamayı engellemk için yaptık
static Singleton* get_instance() //static olduğu için bu fonksiyonu çağrılması için bir nesneye ihtiyaç olmaz
{
if (!mp)
mp = new Singleton();

return mp;
}

void foo();
void bar();
void baz();
private:
inline static Singleton* mp{};
Singleton();
};

int main()
{
Singleton::get_instance()->baz();
Singleton::get_instance()->foo();

}


----------
//başka bir singleten implementasyonu
Meyer's singleton:
-----------------

lazy initialization : nesneyi kullanma ihtiyacı olmadan nesneyi oluşturmuyoruz
thread-safe : singleten nesnesini birden fazla kez oluşturma ihtimali yoktur

class Singleton {

public:
static Singleton& instance()
{
static Singleton object;
return object;
}
private:
Singleton();
};

-----------

//hayatta olan nesnelerin sayılması

class Myclass {

public:
Myclass()
{

//....
++live_object_count
++lived_object_count
}
~Myclass()
{
--live_object_count;
}

static int get_live_count() //const olamaz static üye fonksyonlarının const'luğu diye bir şey olamaz
{
return live_object_count;
}

private:
inline static int live_object_count{};
inline static int lived_object_count{};
}

----------

//bir oyun prgramı var her bir fighter nesnesi diğer figter nesnesine erişebilicek

class Fighter {
public:
void call_fighter_for_help()
{

}
};

int main()
{
Fighter f1{"emrecan"};
Fighter f2{"mehmet"};
Fighter f3{"damla"};
Fighter f4{"ali"};
Fighter f5{"mert"};

f3.call_fighters_for_help(); //düşmanlar etramı sardı mehmet, emrecan, ali, mert yardıma gelin yazısı yazsın
}

//bir tane veri yapısı (container) olucak hayata gelen her nesnenin adresini o veri yapısına eklememiz gerekir

!! static üye fonksiyonlarının this pointerı yoktur









