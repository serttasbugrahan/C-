/////////////////////////////////////////////1. Ders///////////////////////////////////////////////

sınıfların statik veri elemanlarına devam
-----------------------------------------

class Nec {
public:
static int mx; //bunu kullanmak için nesne elemanına gerek yok
};

int main()
{
Nec n1, n2;
n1.mx = 10;
n2.mx = 56;
auto p = &n1;
p->mx = 854;
}

----------
!!tanımda static anahtarını kullanırsak sentax hatası olur
!! array ise arrayin boyutunu yazmaya gerek yok
//nec.h

class Nec {
public:
static int a[];
};

----------

incloplete type : türün varlığından haberdar ancak henüz onun tanımını görmemişse ise

//forward declaration
class Myclass;

int main()
{
//1 incoplete type
}

----
class Neco foo(class Ali);

int main()
{

}

---------------

incomplete type ile neler yapabiliriz?

//fonksiyon bildirimlerinde kullanarabiliriz

class Neco;

Neco foo(Neco);
Neco& bar(Neco&);
Neco* baz(Neco *, int);

//type alias declaration yapabiliriz

typedef Neco* NecoPtr;
typedef Neco& NecRef;
using NecoPtr = Neco *;

//pointer ya da referans değişkenler tanımlayabiliriz

class Ali;

Ali * foo();
Ali& bar();
void baz(Aki &r);

int main()
{
Ali *p = foo();
Ali& r = bar();
baz(r);
}

//extern bildirimi yapabiliriz

class Emre;

extern Emre ge;
extern Emre ga[];

//sınıfların static veri elemanlarında kullanılabilinir

class Nec;

class Myclass {

static Nec snec;
};

//C dili için

struct Data {
int mx;
struct Data sdata; //sentax hatası olur kendi türünden elemanı olamaz
static Data sdata; //legal
};

//c++ dili için

class Nec {
int mx;
Data sdata; //illegal
static Data sdata; //legal
};

!! void is an incomplete type

-------------------

incomplete type ile neler yapılamaz ?

//değişken tanımlayamayız

class Nec;

int main()
{
Nec mynec; //hata
}

//

class Mert;

class Nec {

private:
Mert mx; //hata
}

//pointer değişken tanımlayabiliriz ama içerik ve ok operatörü ile kullanamayız

class Mert;

Mert* foo();

int main()
{
Mert* p == foo();
*p //hata
p-> x = 5; //hata
}

//sizeof operatörünün operandı yapamam

class Mert;

Mert* foo();

int main()
{
sizeof(Mert);
}

-------------

sınıfların static elemlarına dönüyoruz...

class Myclass {

static int x; //bu bir tanımlama değil bunu bir tanım haline getirmek için bazı kurallar var
};

-------

class Myclass {
public:
static int x;
};

int main()
{
Myclass::x = 5; //bu şekilde tanımı yapılabilinir
}

--------

neco.h
int x = 0; //odr ihlal edilir
inline int x = 0;  //odr ihlal edilmez, eskiden bu sadece fonksiyonlar için bir haktı (c++17 öncesi)

-------
//header-only library

class Myclass {
static std::vector<int> x{1,2,4,6,8}; //geçersiz
inline static std::vector<int> x{1,2,4,6,8}; //geçerli

};

-------

class Myclass {

public:
static std::string version;
};

int main()
{
Myclass::version = "1.02.05"; //linked hatası olur
}

-----

class Myclass {

public:
inline static std::string version; //hata kalkar
};

int main()
{
Myclass::version = "1.02.05"; 
}

-----------------------

inline kısa bir tekrarı:

global değişkenler tanımlandıkları zaman odr uymak zorundalar

bir projede birden fazla kaynak dosyada aynı global değişkeni tanımlayamayız 

eğer bir isim dış bağlantıda ise bütün kaynak dosyalarda aynı varlığa ilişkin olmalı

odr: varlıkların birden fazla bildirimi olabilir ama tek tanımı olmak zorunda

//emre.h

void func(int) //odr ihlal edilir

int x = 10; //odr ihlal edilir, başka dosyalar bu dosyayı include ettiğinde odr çiğnenmiş olur

ama inline kullanırsak bundan bir tane olucak demektir

//ali.h
inline void func(int x) //odr ihmal edilmiycek
{

}

//ali.cpp
inline void func(int x)
{

}   

//veli.cpp
inline void func(int x)
{

}   

//hasan.cpp
inline void func(int x)
{

}   

!! birden fazla dosyada kullanılmasına rağmen odr ihmal edilmemiş olur

//myclass.h
class Myclass {

inline static int sx = 10; //cpp(17) ile geldi
};

---------------------

//myclass.h
class Myclass {

static const int sx = 6;
};

!! sınıfların static, const ve intergral type veri elemanlarına sınıf içinde
ilk değer verilebilir

class Nec {
static const double x = 6; //bu şekilde olmaz int olması gerekir
};


-----

class Nec {
static constexpr double x = 5.4; 
//constexpr değişkenler
//tıpkı constexpr fonksiyonlarda olduğu gibi implcitly inline
};

-----

  class Nec {
  public:
  static int mx;
  };
  
  int main()
  {
  Nec mynec; //isim aramanın başarılı olabilmesi içib bu şekilde veya aşağdaki şekilde yapılmalı
  Nec *p{&mynec};
  Nec::mx;//ya da bu şekilde
  
  p->mx
  //mynec.mx
  }

----------

class Nec {
public:
static int mx;
};

int Nec::x{}; //Nec'in x'i 0 değeri ile başlar

int main()
{
Nec n1;
Nec n2;
Nec n3;
Nec n4;

++n1.x;
++n2.x;
++n3.x;
++n4.x;

std::cout << "Nec::x = " << Nec::x << '\n';
}

-------------

class Nec {
public:
void func()
{
x = 5; //hepsi legal
Nec::x = 5;
this-> = 5;
}
private:
static int x;
};

-------

class Nec {
public:

void foo()const
{
x = 6; //legal staticden dolayı
}
void func()
{
x = 5; //hepsi legal
Nec::x = 5;
this-> = 5;
}
private:
static int x;
};

-------

class Nec {
public:
Nec(int i) : x(i) {} //illegal
private:
static int x;
};


--------
  class Nec {
public:
int x;
static int y;
  
private:

};

int x = 5;
int Nec::y = x; //hata

--------

class Nec {
public:
int x;
static int y;
  
private:

};

Nec g;
int x = 5;
int Nec::y = g.x; //legal

-------------------------------------------------

sınıfların static üye fonksiyonları (static member functions):
--------------------------------------------------------------

//static üye fonksiyonları
a) class scope'dadır

class Nec {
public:
static void foo() //global fonksiyon ama class scobe'a alınmış demek
{

}
private:
int mx;
};

void bar()
{
Nec mynec;
mynec.mx = 5; //erişim hatası
}


int main()
{
bar(); //bar bu şekilde çağrılır
Nec::foo(); //foo bu şekilde çağrılır
}

--------

class Nec {
public:
static void foo() 
{
Nec mynec;
mynec.mx = 5; //sınıfın member fpnksiyonu erişebilir
}
private:
int mx; //hata olmaz
};

void bar()
{

}

--------

class Nec {
public:
static void foo() const{} //hata olur, buradaki const gizli parametre değişkenini niteler

}
private:
int mx;
};

------

class Nec {
public:
static void foo()
{
this; //this kullanımı hertürlü sentax hatası olur
}

private:
int mx;
};

--------
//sınfların static veri elemanları sınıfların non-static veri elemanlrını bu şekilde kullanamaz
class Nec {
public:
static void foo()
{
mx = 5; //Hata, this olmadan böyle bir şey yapamayız
}
private:
int mx;
};

--------

class Nec {
public:
static void foo()
{
Nec mynec;
mynec.mx = 5; //bu şekilde legaldir
}
private:
int mx;
};

---------

class Nec {
public:
static void foo()
{
mx = 5; //legal
Nec::mx = 5; //legal
}
private:
static int mx;
};

-------

class Nec {
public:
static void foo()
{

}

void bar()
{
foo(); //legal
Nec::foo(); //aynı anlamda , Nec'in foo()'su demektir  
}
private:
static int mx;
};

------

class Nec {
public:
static void foo()
{

}
};

int main()
{
Nec mynec;
mynec.foo(); //legal
}

-------

class Nec {
public:
static void foo()
{

}
void bar()
{
this->foo(); //legal
}
};

------

class Nec {
public:
static void foo()
{

}
void bar const()
{
foo(); //legal
}
};

-------

class Nec {
public:
static void foo()
{
bar() //illegal
Nec mynec
mynec.bar();//legal
}
void bar()
{

}
};

----------

class Nec {
public:
static void foo()
{

}
void bar()
{
this->foo(); //legal
}
};

--------
//mülakatlarda sorulan tipik bir soru

class Nec {
public:
static double foo()
{
return 3.9;
}
static int ival;
};


int foo()
{
return 2;
}

int Nec::ival = foo(); //isim arama kurallarından dolayı ilk baş class scope'da aranır

int main()
{
std::cout << Nec::ival << '\n';
}


--------------------------------

static veri elemanlarının kullanıldığı alanlar:
----------------------------------------------

class Person {
std::vector<int> x; //her personun ayrı bir int dizisi var
static std::vector<int> x; //bu şekilde personların ortak bir int nesnesi olur
};

-------------
mesela student sınıfında öğrencinin sınavlardan aldığı notların ortalamsını veren fonksiyon olsa
bu fonksiyon non-static olması gerekir her öğrencinin ayrı olabilmesi içn
öğrencilere toplamda kaç tane sınav yapılmış bunu static yapmamız gerekir
-------------
//mülakatlarda sorulabilinen temalar

//named contructor

class Myclass {
public:
static Myclass create_Object();
};

int main()
{
auto m1 = Myclass::create_object();
}

-------------

class Complex {

public:
Complex(double r, double i); //bu şekilde hata olur aynı isimden dolayı
Complex(double a, double d);

};

------

class Complex {
public:
static Complex create_polar(double a, double d)
{
return Complex(a, d, 0);
}

static Complex create_cartesian(double r, double i);
{
return Complex(r, i);
}

private:
Complex(double, double); //cartesian
Complex(double, double, int); //polar
};


int main()
{
auto c1 = Complex::create_cartesian(3.5, 1.2);   
auto c2 = Complex::create_polar(.2352, 4.5767);   
}

----------
//dinamikmmürlü nesne zorunluluğu 
//private ypmaz isek herkes istediği gibi nesne oluşturabilir

class DynamicOnly {

public:
DynamicOnly(const DynamicOnly&) = delete;
DynamicOnly& operator=(const DynamicOnly&) = delete;

Dynamic* create_object()
{
return new DynamicOnly{};
}

private:
DynamicOnly();
};



----------------------------

singleton :tasarım desenidir bir sınıf türünden tek bir nesne olucak ve o nesneye global bir erişim olucak

mesela 1 tane server var, 2 tane olması program domaine aykırı bu durumda sigleton kullanılır, servere singleton ismi verilir

class Singleton {

public:
Singleton(const Singleton&) = delete; //copyalamayı engellemk için yaptık
static Singleton* get_instance() //static olduğu için bu fonksiyonu çağrılması için bir nesneye ihtiyaç olmaz
{
if (!mp)
mp = new Singleton();

return mp;
}

void foo();
void bar();
void baz();
private:
inline static Singleton* mp{};
Singleton();
};

int main()
{
Singleton::get_instance()->baz();
Singleton::get_instance()->foo();

}


----------
//başka bir singleten implementasyonu
Meyer's singleton:
-----------------

lazy initialization : nesneyi kullanma ihtiyacı olmadan nesneyi oluşturmuyoruz
thread-safe : singleten nesnesini birden fazla kez oluşturma ihtimali yoktur

class Singleton {

public:
static Singleton& instance()
{
static Singleton object;
return object;
}
private:
Singleton();
};

-----------

//hayatta olan nesnelerin sayılması

class Myclass {

public:
Myclass()
{

//....
++live_object_count
++lived_object_count
}
~Myclass()
{
--live_object_count;
}

static int get_live_count() //const olamaz static üye fonksyonlarının const'luğu diye bir şey olamaz
{
return live_object_count;
}

private:
inline static int live_object_count{};
inline static int lived_object_count{};
}

----------

//bir oyun prgramı var her bir fighter nesnesi diğer figter nesnesine erişebilicek

class Fighter {
public:
void call_fighter_for_help()
{

}
};

int main()
{
Fighter f1{"emrecan"};
Fighter f2{"mehmet"};
Fighter f3{"damla"};
Fighter f4{"ali"};
Fighter f5{"mert"};

f3.call_fighters_for_help(); //düşmanlar etramı sardı mehmet, emrecan, ali, mert yardıma gelin yazısı yazsın
}

//bir tane veri yapısı (container) olucak hayata gelen her nesnenin adresini o veri yapısına eklememiz gerekir

!! static üye fonksiyonlarının this pointerı yoktur

/////////////////////////////////////////////////////2. Ders/////////////////////////////////////////////


delegatiing ctor: 
-----------------

modern c++'dan önce bir ctorun işini başka bir ctor'a havale etme şansı yoktu

çoğu zaman sınıfların ctor'lari overload ediliyor
ancak overload edilen ctor'ların bazen ortak bir kodu oluyor
unutmayınız ki kod tekrarı her türlü belayı beraberinde getirir
eski c++'da ctor'ların ortak kodu bir fonksiyon şeklinde tanımlanıyor
ve ctor'lar bu fonksiyonu çağırıyordu

class Myclass(int x) 
{
public:
Myclass(int) : Myclass(x, x, x)
{

}

Myclass(int, int) : Myclass(x, x, 0)
{
common_code_init();
}

Myclass(int x, int y, int z) : mx(x), my(y), mz(z)
{
//belki ortak kod
}

Myclass(const char*p) : Myclass(std::atoi(p))
{

}

Myclass(double d) : mx(static_cast<int>(d)), my{0} mz{0} //hata

private:
int mx, my, mz;
};

-----------------------------------------------------------

friend bildirimleri : bir sınıfın bir koda kendi privated ve protected üyelerini erişme hakkı veriyor
---------------------
!! ilerde daha detaylo öğrenilecek

//derleyici normalde erişim engeli koyucaktı ancak ben falanca kod için benin private bölümüme erişim hakkı veriyorum 

//friend bildirimleri hemen her zmaan sınıfın kendi kodlarına veriliyor

//eğer client kodlara friend bildirimi ile erişim veriyor isek orayı tekrar kontrol etmemiz gerekir

sınıfın 
a) global fonksiyonaları (free functions) private bölüm erişimez
b) yardımcı türler

--------------

class Myclass {

private:
int mx{};
void foo();
};

void ff(Myclass m)
{
m.foo(); //error
Myclass myc;
myc.mx = 5; //access error
}

---------

class Myclass {
public:
friend void ff(Myclass);
private:
int mx{};
void foo();
};

void ff(Myclass m)
{
m.foo(); 
Myclass myc;
myc.mx = 5; 
}

-----------

!! friend bildirimini public veya friend bildiriminde yapmanın farkı yoktur

-----------

class Myclass {
public:
friend int foo(Myclass);
private:
int mx{};
void foo();
};

int main()
{
Myclass m;
foo(m); //ADL
}

---------

class Myclass {
public:
//hidden firend
friend int bar(Myclass, int x) //istisnai bir durum
{
return x * x;
}
private:
int mx{};
void foo();
};

----------
//Erg::foo

class Nec {

private:
friend void Erg::foo(int); //bu şekilde olmaz
};

bu şekilde verebilmesi için complete type olması gerekir

------

class Erg{
public:
void foo(int);
};

class Nec {

private:
friend void Erg::foo(int); 
int mx; //private
};

void Erg::foo(int x)
{
Nec necx;
necx.mx = x; //bu şekilde sentax hatası olmaz
}

---------

sınıfın ctor'ına friendlik verilebilinir

class Erg {
public:
Erg();
Erg(int);
};

class Nec {

private:
friend Erg::Erg(); //legal
friend Erg::Erg(int); //legal
int mx; //legal
};

----------

bir sınıf bir başka sınıfa "friend"'lik verebilir
bu durumda friend bildirimine konu sınıf incoplete type olabilir

----------

class Nec {
private:
friend class Erg; //bu şekilde class anahatar sözcüğü ile kullanıldığı zaman legal
int mx;
};

class Erg {
public:
void foo(Nec nec)
{
nec.mx = 20; //legal
}
void bar()
{
Nec* p = new Nec;
auto val = p->mx; //legal
}
};

-------------

!! A sınıfı B sınııfına friendlik verirse B sınıfınına A sınıfında friendlik verdiği anlamına gelmiyor  

!! A sınıfı B'nin private bölümüne erişemez

!! 
A B'ye friend'lik vermiş olsun
B C'ye friendlik vermiş olsun
C A'nın private bolumune erişemez
//friend bildirimleri gecisken degil





