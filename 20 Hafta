////////////////////////////////////////////////////// 1. Ders ///////////////////////////////////////////



en çok yapılan hatalar:
-----------------------

-değişkenleri const yap

eğer değişken değeri hesaplama sonucu ortaya çıkıyorsa aşağıdaki şekilde yapılabilir

//IIFE
int main()
{
using namespace std;

int a = 5;
int b = 6;
int c = 9;

const auto ival = [&]() {
auto x = a * b + c;
if (x > 100)
x += 5;
else 
x -= 5;

return x - a - b;
}();
}

-------------------

void func(std::vector<std::string> svec) //copy elision olmassa copy ctor çağrılır bu yapıda, bu da çok maaliyetli bir durumdur
{

}

//onun yerine const ve ref yap

void func(const std::vector<std::string> &svec)
{

}

-------------------
//ref gerektirmeyen durumlar

-içerde kopyasını çıkartıcaksak
-ctor aldığı sınıf nesnesi ile veri elemanın init yapıyorsa

class Frk {

public:
Frk(std::vector<std::string> vec) : mvec(std::move(vec)) {}
private:
std::vector<std::string> mvec

}


-------------------

out parametrelerde kaçının 

void func(std::vector<std::string>&); //böyle değil
std::vector<std::string> func(); //Böyle yap


---------------------

her execption yaklamaya çalışma

exception yakalıycaksan handler et, programın  akışını oradan devam ettirme

---------------------

tür eş ismi ve namespace alias kodda kullanmak önemlidir

yoksa aşağıdaki şekilde çirkin kodlar olur

vector<vector<cc::neco<int>>::iterator //bunu kimse anlamaz, onun yerine bunun kulllanımına dair tür eş ismi verirsek ortalığı daha rahatlatmış oluruz

-----------------------

uzun fonksiyonlar yazmak sakıncalı

fonksiyon uzunluğu 20-25 satıdan uzun olmasın,

farklı sorumluluları aynı koda yüklemeyin

-----

void do_something()
{
if (expr) { //kodu okuyan bu expr bilmek zorunda değildir

}
}

//onun yerine aşağıdaki uygulanabilir

if (is_not_valid_state())
do_this;

------------------------

ananim namespace kullan

//bugra.cpp

namespace {
int foo(int);
int g = 46;
class Helper {

};
}

============================================

--------------

string_view ve regex mülakatlara girmeden bilinmesi gerekn konular necati hoca sölüyor

---------------


dosya işlemlerine devam...

--------------

std::ifstream open_binary_file(const std::string& filename)
{
std::ifstream ifs{ filename, std::ios::binary};
if (!ifs) {
throw std::runtime_error{ filename + "dosyasi acilamiyor!\n" };
}
return ifs;
}

std::ifstream create_binary_file(const std::string& filename)
{
std::ifstream ofs{ filename, std::ios::binary};
if (!ifs) {
throw std::runtime_error{ filename + "dosyasi olusturulamiyor!\n" };
}
return ifs;
}

--------------

#include "nutility.h"
#include <fstream>

int main()
{
using namespace std;

auto ofs = create_binary_file("primes10000.dat"); //dosya binary modda açmak için yapılır
constexpr size_t n = 10'000u;
int x{};
int prime_count{};

auto ofs = create_binary_file("primes10000.dat");

while (prime_count < n) {
if (is_prime(x)) {
ofs.write(reinterpret_cast<char*>(& x), sizeof(int));
++prime_count;
}
++x;
}

// ofs.close(); //istediğimiz zaman dosyayı kapatabiliriz
// ofs.open("ali.txt"); //sonrasında başka bir dosya da açabiliriz
// { } kullanarak dosyanın daha erkende kapanmasını sağlayabiliriz
}

----------------

void func()
{
//code
//code

//statement1
//statement2

//sadece ben statement 1 ve statement 2 yürütülürken hayatta olan bir nesne istiyorum (kritik bölgeyi daraltma)

}


----------

#include <mutex>

std::mutex mtx;

void func()
{
//code
//code

lock_guard lock{ mtx }; //aşağıdaki kodlar kilit altında
//statement1
//statement2
//sadece ben statement 1 ve statement 2 yürütülürken hayatta olan bir nesne istiyorum (kritik bölgeyi daraltma)

}

-----------

include <mutex>

std::mutex mtx;

void func()
{
//code
//code
//code

{
lock_guard lock{ mtx };
//statement1
//statement1
}

//statement1
//statement2
//statement3
}

-------------------------

//10 000  tane asal sayısı okuyan program

int main()
{
using namespace std;

auto ifs = open_binary_file("primes10000.dat");

int x{};

while (ifs.read(reinterpret_cat<char*>(&x), sizeof(x))) {
cout << x << "\n";
}

----------------

int main()
{
using namespace std;

auto ifs = open_binary_file("primes10000.dat");

vector<int> ivec(10000);

//öyle bir kod yazki vector nesnesi ilk1 10'000 asal sayıyı tutsun

ifs.read(reinterpret_cast<char*>(ivec.data()), 10'000 - sizeof(int));

for (const auto val : ivec) {
cout < val;
(void)getchar();
}
}

----------------

//c kursunda yazılan bir kodu c++ dilinde yazıyoruz

//komut satirindan calistirilacak

//dbol ali.exe 1000 //ali.exe böler

//17500 byte
//parca001.par 1000
//parca017.par 1000
//parca018.par 500


//dbir veli.exe //veli.exe bölme

-----------------------------

//saat 1.12 de hızlı tekrar et
#include <cstdlib>

//komut satırında çalıştırabilmke için main'in parametre değişkenkerine sahip olması gerekiyor

//dbol ali.exe 1000

int main(int argc, char* argv[])
{
using namespace std;

if (argc != 3) {
cerr << "kullanim: <dbol> <dosya ismi> <byte sayisi>\n";
return 1;
}

char c;
int file_count{};
int byte_count{};

auto ifs = open_binary_file(argv[1]); //dosya açılmassa exception throw gönderir

int chunk = ato(argv[2]);
ofstream ofs;
ostringstream ostr;
//ostr.fill('0');

while (ifs.get(c)) {
if (!ofs.is_open()) {
ostr << "parca" << setw(3) << file_count + 1 << ".par";
ofs.open(ostr.str(), ios::binary);
if (!ofs) {
cerr << ostr.str() << " dosya olusturulamadi\n";
return 1;
}
++file_count;
}

ofs.put(c);
++byte_count;
if (byte_count % chunk == 0) {
ofs.close();
ostr.str("");
}
}
cout << byte_count << " byte'lik " <<argv[1] << " isimli dosya " << chunk << 
" byte'lik " << file_count << " parcaya bolundu\n";
}

----------------------------------
//1.27 tekrar et

//dosya birleştirme kodunu yazıyoruz

//dbir veli.exe

int main(int argc, char **argv)
{
if (argc != 2) {
cerr << "kullanim: <dbir> <yeni dosya ismi>\n";
return 1;
}

auto ofs = create_binary_file(argv[1]);
int file_count{};
int byte_count{};

for (;;) {
ostringstream ostr;
ostr.fill('0');
ostr << "parca" << setw(3) << file_count + 1 << ".par";
ifstream ifs{ostr.str(), ios::binary };
if (!ifs) {
break;
}

char c;
while (ifs.get(c)) {
ofs.put(c);
++byte_count;
}
++file_count;
ifs.close();
if (remove(ostr.str().c_str())) {
cerr << "dosya silinemedi\n";
return 2;
}
}
cout << file_count << " adet dosya " << byte_count << " byte'lik " << argv[1] << 
" isimli dosya olarak birlestirildi\n";
}

--------------------------------

file pointer ile ilgili hizmet veren fonksiyonlar

fseek
rewind
ftell
fsetpos
fgetpos

-----------------

int main()
{
using namespace std;

ofstream ofs{ "necati.txt" };

ofs. //bunlara bak
}

----------

int main()
{
using namespace std;

fstream fs{ "necati.txt" };

fs. //bunlara bak
}

---------

int main()
{
using namespace std;

ifstream ofs{ "necati.txt" };

ofs.tellp;
}

--------

- Istream sınıfından kalıtım yoluyla elde edilen sınıflarda dosya konum göstericisini set eden funcların ismi seekg. Okuma amaçlı dosya konum göstericisinin konumunu seekg set ediyor.

- Ostreamden kalıtımal elde edilen sınıflarda ise dosya konum göstericisini konumlandıran funca seekp deniyor.2 Overlodu var ikisininde

---------

int main()
{
using namespace std;

ifstream ifs {"primesmillion.dat", ios::binary };

//ifs.seekg(10'000) //2 overloadu vardır

//ios::beg
//ios::cur
//ios::seekg()
}

----------

int main()
{
using namespace std;

istringstream iss{"necati ergin" };
//                 necatiergin //farkına bak
string str;

iss >> str;
//      çift tırnak içinde yazar (quoted)
cout << str << '\n';  
iss.seekg(0, ios::beg);
//iss.seekg(1, ios::cur);
//iss.seekg(-6, ios::cur);
//iss.seekg(-6, ios::end);

iss >> str;

cout << str << '\n';
}

-------------

//yazma tarafı içinde bunlar geçerlidir

int main()
{
using namespace std;

ostringstream oss{"furkan mert"};

cout << "[" << oss.str() << "]\n";
oss.seekp(3);
os.put('!');
cout << "[" << oss.str() << "]\n";
oss.seekp(0);
os.put('*');
cout << "[" << oss.str() << "]\n";
}

---------------

int main()
{
using namespace std;

auto ifs = open_binary_file("primesmillion.dat");

int n{};

std::cout << "kacinci asal sayi: ";
cin >> n;

ifs.seekg((n - 1) * sizeof(int), ios::beg);
int x;

ifs.read(reinterpret_cast<char*>(&x), sizeof(int));
cout << n << ". asal sayi " << x << "\n";
}

---------------

void print_file(const std::string& filename, int ntimes)
{
auto ifs = open_text_file(filename);

while (ntimes--) {
std::cout << ifs.rdbuf()
(void)getchar();
ifs.seekg(0);
}
}


int main()
{
using namespace std;

print_file("main.cpp", 5);
}

----------------

//ilginç bir özellik daha var 

read ve write dosyalarının geri dönüş değeri stream nesnesi olduğu için 
özellikle formatsız okumada kaç byte olduğunu bir şekilde bizim anlayabilmemiz lazım
bu yüzden gcount olan fonksiyon koymuşlar

//formatsız okuma işlemlerinden biri çağrıldığında okunan byte sayısı için sınıfın
gcount çağırırız

int main()
{
using namespace std;

auto ifs = open_binary_file("primesmillion.dat");

int n{};

std::cout << "kacinci asal sayi: ";
cin >> n;

ifs.seekg((n - 1) * sizeof(int), ios::beg);
int x;

ifs.read(reinterpret_cast<char*>(&x), sizeof(int));

cout << "okunana byte sayisi : " << ifsgcount() << '\n';

cout << n << ". asal sayi " << x << "\n";
}

--------------

int main()
{
using namespace std;

int *p = new int[20000];

auto ifs = open_binaary_file("primes10000.dat");
ifs.read(reinterpret_cast<char*>(p), sizeof(int) * 20000);

if (ifs) { //istedeğimiz kadar byte okuyamassa stream fail oluyor
std::cout << "stream hata durumunda degil\n";
}
else {
std::cout << "stream hata durumunda\n";
}

std::cout << "okunan byte sayisi: " << ifs.gcount() << "\n"; //dosyaya 10'000 tane asal sayı yazıldığı için 40'000 tane okunur
}

---------------

//bu özelliği anlaıp anlamadığını bilmek için aşağıdaki zor soru sorulur

//komut satırından çalışıtırlan filecopy isimli programı yazınız

//filecopy ahmet.exe mmehmet.exe //2 ayrı süürm şeklinde yaz bunu

1) byte byte oku byte byte yaz

//filecopy ali.exe veli.exe

int main(int argc, char **argv)
{
constexpr std::size_t buffersize{ 1024 };

if (argc != 3) {
std::cerr << "usage: <filecopy> <source file> <dest file>\n";
return 1;
}

auto ifs = open_binary_file(argv[1]);
auto ofs = create_binary_file(argv[2]);

unsigned char buf[buffersize];

//ifs.read isleviyle buffer'a yazip
//ofs.read isleviyle buffer'dan dosyaya aktat

}

--------------------

bufferdan bazı karakterleri okumadan geçmek istiyorum
burada ignore isimli fonksiyonu vardır

int main()
{
using namespace std;

cin.ignore(50, '\n') // 50'nin olduğu yere limit başlık dosyasini kullanarak ekleme yapabiliriz
}

----------------
#include <limits>

int main()
{
using namespace std;

cout << numeric_limits<int>::max() << "\n";
cout << numeric_limits<int>::min() << "\n";


}

----------------

//mesela 8 byte'lık en büyük tam sayı değerini kullanmamız gerekiyor

int main()
{
using namespace std;

constexpr auto n = numeric_limits<unsigned int>::max();


}

--------------

//newline' a kadar olan bütün karakterleri ignore etmek

int main()
{
using namespace std;

cin.ignore(numeric_limits<streamsize>::max(), '\n');

}

----------------

int main()
{
using namespace std;

istringstream iss {"x987324yz"};

int ival;

iss >> ival; //okuma yapmaz çünkü x okumaya uygun değil ancak x ignore etsek
}

-----------------

int main()
{
using namespace std;

istringstream iss {"x987324yz"};

int ival;

iss.ignore();
//iss.ignore(1);
iss >> ival;
}

------------------
//m karakteri görene kadar tüm karakterleri ignore etmesini isteyin

int main()
{
using namespace std;

istringstream iss {"metin98234"};

int ival;

iss.ignore(numeric_limits<streamsize>::max(), 'n');
int ival;
  
iss >> ival;

cout << "ival = " << ival << '\n';
}

----------------
//sürekli kişinin yaşını sorup yaş doğru olmassa dec formatta tekrar tekrar yaşını sorucam


// how old are you?
// ali //geçersiz ise
//ali is not a number
//how old are you? //tekrardan

//akım başarısız ise good state e gelmeli clear çağrılmalı

int main()
{
using namespace std;

int age{};

while (( cout << "how old are you ?") && !(cin >> age) {
cout << "your entry is not a number\n";
cin.clear();
cin.ignore(numeric_limts<streamsize>::max(), '\n');
}

cout << "your age is : "  << age << "\n";

}

----------------

int main()
{
using namespace std;

istringstream iss{
"761furkan mert\n"
"76431dgurkan yenil\n"
"32761mert sirsakaya\n"
"23269fbugrahnserttas\n" };

for (;;){
int ival{};
iss >> ival;

if (iss.eof() || iss.bad()) {
break;
}

if (iss.fail()) {
iss.clear();
iss.ignore(numeric_limits<streamsize>::max(), '\n');
}
else {
cout << ival << "\n";
}
}
}

////////////////////////////////////////////////////// 2. Ders ///////////////////////////////////////////

bir stream'in output stream'e tie(bağlanması) edilmesi

giriş akımını çıkış akımına tie edersek standart input üzerinde bir giriş işlemi yapıldığında
öncelikle onun bağlandığı output stream flush edilir


--------------------

tie
----

cin.tie() 
//2 overloadı var 
//1. overload hangi output stream'e tie edilmiş ise onun stream'i döndürür, tie edilmemişse nullptr döndürür

int main()
{
using namespace std;

if (auto osptr = cin.tie()) {
cout << "cin is tied. the address of the stream cin tied to is : " << osptr << '\n';
cout << "&cout = " << &cout << '\n';
}
else {
std::cout << "cin is not tied to any output stream\n";
}
}

---------------------

//2. overloadu

#include <fstream>

int main()
{
using namespace std;

auto ifs = open_text_file("main.cpp");

ifs.tie(&cout);
}

-----------------------

kime bağlıyorsak bağladığımız ostream (çıkış akımı) olmalı

-----------------------

int main()
{
using namespace std;

auto ifs = create_text_file("ali.txt");

ofs.tie();
}

=============================================================================
=============================================================================

labmda ile igilili konuşmadığımız kısımlara bakıyoruz

labmda init capture (c++14)
this capture

-----------------

int main()
{
using namespace std;

auto uptr = make_unique<string>("necati ergin");

//auto f = [uptr]() { //sentax hatası, copt capture çünkü
auto f = [&uptr]() {
cout << *uptr << '\n';
};

f();

cout << (uptr ? "dolu" : "bos") << '\n';
}

--------------------

int main()
{
using namespace std;

auto uptr = make_unique<string>("necati ergin");

auto upx = move(uptr);

cout << (uptr ? "dolu" : "bos") << '\n'; //bos olur uptr taşındı
}

---------------------

labmda ifadsinde öyle bir araç olsun ki  uniqe_ptr taşıma yapılsın

int main()
{
using namespace std;

int x = 46;

auto fn = [a = x] () {
return a * 5;
};
}

----------

auto fn = [x] () {
return x * 5; //aynı anlamda, ancak labmda init capture bize herhangi bir sayıyla init edilme şansıın veirir
};

-----------

int main()
{
using namespace std;

int x = 46;

auto fn = [a = x + 5]() {
cout << a << "\n";
};

fn();
}

------------

int main()
{
using namespace std;

int x = 46;

auto fn = [x = x + 5]() {
cout << x << "\n";
};

fn();
}

-----------
//bu özellikler aşağıdaki kodda işimize yarıycak

int main()
{
using namespace std;

auto uptr = make_unique<string>("necati ergin");

//auto f = [uptr]() { //sentax hatası, copt capture çünkü
auto f = [&uptr]() {
cout << *uptr << '\n';
};

f();

cout << (uptr ? "dolu" : "bos") << '\n';
}

------------

int main()
{
using namespace std;

int x = 5;

auto fn = [&x = x] {++x};

cout << "x = " << '\n'; //labmda çağrılmaz ondan değer değişliği olmaz
}

-----------

int main()
{
using namespace std;

int x = 5;

auto fn = [&x = x] {++x};

fn(); //şimdi çağrılır

cout << "x = " << '\n';

}

------------------

int main()
{
using namespace std;

int x = 5;

auto fn = [&x = x] {++x};

fn(); //3 kere çağrılır
fn();
fn();


cout << "x = " << '\n';

}

-------------

int main()
{
using namespace std;

int x = 5;

auto fn = [&x = x] {++x};

int x = 100;
fn(); 


cout << "x = " << '\n';

}

-----------

int main()
{
using namespace std;

int a[10]{};

auto fn = [a] {
std::cout << typeid(a).name() << '\n'; //sınıfın elemanı 10 elemanlı bir dizi olucaktır
};

f();
}

-----------

int main()
{
using namespace std;

int a[10]{};

auto fn = [a = a] {
std::cout << typeid(a).name() << '\n';  //pointer olur

f();
}

===================================

şimdiye kadar kullanıdığımız lambda ifadeler globaldı
 
class Nec {

public:
voif foo()
{
auto val = mx + my; //önce foo içinde araır sonra class içinde
//auto val = this->mx + this->my; //bu çirkiin bir kod
}

private:
int mx, my;
};

---------------

class Nec {

public:
voif foo()
{
int x = 5;

auto fn = [](int a) {return a * a;}; //herhangi  bir sentax hatasu olmaz
auto fn = [x](int a) {return a * a;};

}
private:
int mx, my;

};

--------------

class Nec {

public:
voif foo() //buranın gizli this pointerı vardır
{

auto fn = [x](int a) {
return a * (mx + my); //hata closure type'ın veri elemanıdır bu
};
}

private:
int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();
}

---------------

class Nec {

public:
voif foo() 
{
mx, my //burada kullansak bir problem olmaz

auto fn = [](int a) {
return a * (mx + my); 
}

private:
int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();
}

----------------
//Bunu yapmak için this capture edilmeli

class Nec {

public:
voif foo() 
{

auto fn = [this](int a) {
//auto fn = [&](int a) { //bu şekilde de olur
return a * (mx + my);
};
}

private:
int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();
}

---------------------

this copyalama veya ref ile capture edilebilir farkı yoktur

---------------------

capture etme yollarını anlatan tablo var onu inceliyoruz 

------------------------

class Nec {

public:
voif foo() 
{

auto fn = [this]() {
++mx;
++my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; // 11 yazar
cout << "mynec.mh = " << mynec.my << '\n'; // 21 yazar

}

---------------

*this yazarsak hata vericek 
mynec kendisi olmaz mynec kopyası çıkar biz o kopyanın mx ve my arttırmış oluruz

class Nec {

public:
voif foo() 
{

auto fn = [*this]() {
++mx;
++my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

--------------------

mutable yapmamız gerekir bu durumu düzeltmek için
default olarak const yazardır mutable sayesinde non-const yazar

class Nec {

public:
voif foo() 
{

auto fn = [*this]()mutable  {
++mx;
++my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; // 10 yazar
cout << "mynec.mh = " << mynec.my << '\n'; // 20 yazar
//nec'İn x ve my si değildir kopyasıdır artık
}

---------------
//Yukarıdaki kod ile ilgili

class Myclass {

public:
void bar();
};

class Nec {
public:
void foo() const
{
m.bar(); //hata olur
}
private:
Myclass m; //burada mutable kullanırsak düzelir
};

------------------
& //her şeyi kopyala demektir bu

class Nec {

public:
voif foo() 
{
int a = 67;
int b;
auto fn = [&]() {
return a + b + mx + my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

----------------

[&, this] ; //& ile farkı yok

------------------

class Nec {

public:
voif foo() 
{
int a = 67;
int b;
auto fn = [&, this]() {
return a + b + mx + my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

--------------

[&, *this] 

//*this capture edilir yine *this dışındakiler ref ile capture edilir
class Nec {

public:
voif foo() 
{
int a = 67;
int b;
auto fn = [&, *this]() { 
return a + b + mx + my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

--------------

[=], bu kaldırılacak riskten dolayı

class Nec {

public:
voif foo() 
{
int a = 67;
int b;
auto fn = [=]() { //her rşeyi kopyalama ile capture eder
return a + b + mx + my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

--------------

[=, this]

---------------

[=, *this]

-------------

=========================================================

#include <ratio>

buradaki bütün işlemler compile time'da yapılır


int main()
{
using namespace std;

ratio<5, 3> //5 bölü 3 demetir
}

--------------

int main()
{
using namespace std;

ratio<5>
ratio<5,1> //aynı anlamda

}

----------------

template <int NUM, int Den = 1>
class Ratio {

};

int main()
{
using namespace std;

ratio<2, 5> //2/5 
}

----------------

template <int NUM, int Den = 1>
class Ratio {
public:
constexpr static int num = NUM;
constexpr static int num = DEN;

};

int main()
{
using namespace std;

Ratio<2, 5>::num;
}

------------------

orjinali

int main()
{
using namespace std;

ratio<2, 3>::num; //compile time sabitidir,  2 
ratio<2, 3>::den; // 3 
}

--------------------

int main()
{
using namespace std;

ratio<5, 45>::num; //1
ratio<5, 45>::den; //9 
raito<12, -18>::num //-2
}

----------------------

int main()
{
using namespace std;

cout << (ratio<2, 5>::type).name()  << '\n';
} 

---------------------

meta compile time da tür hesaplamayı sağlar

int main()
{
using namespace std;

using rt = ratio_add<ratio<1, 3>, ratio<2,5>>type; //1/3 + 2/5

}

------------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_add<one_third, two_fifth>::type

}

------------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_multiply<ratio<2, 3>, ratio<3,2>>::den
ratio_divide

}

--------------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_equal<ratio<1, 3>, ratio<2, 6>::value //true çıkar

}

----------------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_less<ratio<86123, 98134>, ratio<87981, 99134>>::value //false olur value
ratio_less_v<ratio<86123, 98134>, ratio<87981, 99134>> //bu şekilde yapılabilir
}

----------------------

bazı kesirleri daha kolay kullanabilmek için ratio tür eş isimleri vermişler bazı değerlere

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

milli::num //1 
milli::den //1000

deci::
//cpp ref den devamına bak
}

----------------

deci
centi
milli

---------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_multiply<milli, kilo>
}

==========================================================

chrono kütüphanesi : tarih zaman ile ilgili yardım sağlar
------------------
minimal olarak bakıcağız çok büyük bir kütüphane


clock

time_point

duration

--------------------------.---------------------> //bu çizgi akan zaman olsun
                     //bu nokta ise akan zamandaki bir time point

//2 pointer birbirinden çıkınca süre elde edilir (duration)

//time point epok tak geçen 

time point'e duratiıın eklersek time point elde ederiz

2 time point toplanırsa anlamlı sonuç çıkmaz

-------------------

sıfır maaliyetli bir soyutlamadır bu kütüphane çok başarılıdır

--------------------

2345 saniye
int sec; //mantıklı değil

-----------
chorono kütphanesinin hepsi nested namespace içinde bunun adı chrono

int main()
{
using namespace std;

chrono::duration

}

---------------

//bu da olur

int main()
{
using namespace std::chrono;

duration 
}

-------------

int main()
{
namespace chr = std::chrono;

chr::duration

}

--------------
duration bir sınıf şablonu,  2 template parametresi var

using namaspace std;
using namaspace chrono;

int main()
{
duration;
std::chrono::namespace; //
}

----------------
//representation doğru seçmek gerkeir (int, double)

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<1, 1>> //süre birimi saniye int ile iafede ediyor
duration<int> //bununla aynı anlamda
duration<int, ratio<1, 1>> //bunlar aynı anlamda
}

--------------

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<1, 2>> //yarım saniye süresi

}

---------------
ms ifade eden bir duration türü oluştur

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<1, 1000>> //ms türü kaç ms olduğunda kaç değeri int
duration<double, ratio<1, 1000>>
//kısa olarak aşağıdaki yazılır
duration<int, milli>
}

------------
saatleri ifade etsek

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<3600>>


}

-------------

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<1, 60>

}

--------------
using namaspace std;
using namaspace chrono;

int main()
{
cout << typeid(seconds).name() << "\n";
}

--------

using namaspace std;
using namaspace chrono;

int main()
{
cout << typeid(milliseconds).name() << "\n";
}

--------------

using namaspace std;
using namaspace chrono;

int main()
{
cout << typeid(minutes).name() << "\n";
}

-------------

using HalfDay = std::chrono::duration<int, std::ration<12 * 60 * 60>>;

----------

int main()
{
milliseconds::rep //1. template 
milliseconds::period //2. template

}

----------

int main()
{
cout << typeid(milliseconds::rep).name //1. template 
cout << typeid(milliseconds::period).name //2. template

}

---------
//tam sayıdan duration a örtülü dönüşüm yok

int main()
{
duration<int> x(12);
seconds x {367};
x = 57; //hata
}

////////////////////////////////////////// 3. Ders //////////////////////////////////////

#include <chrono>

using namespace std;
using namespace std::chrono;
//üretimde bu kadar bol using bildirimi kullanmam diyor necati hoca

int main()
{
millliseconds ms = 54343; //hata ctor explicit
millliseconds ms1{54343}; //value init edersek hata olmaz

ms1.count()//sarmalanan değeri döndürür
auto val = ms1.count();

}

-------------------
//duration işlemleri ile neler yapılabilir

using namespace std;
using namespace std::chrono;

int main()
{
auto dr = milliseconds{456} + nanoseconds{6'543'129} + seconds{2}

cout << dr.count() << "\n";
}

--------------------
// int, double gibi türlerden duratian'a örtülü dönüşüm yok

using namespace std;
using namespace std::chrono;

int main()
{
milliseconds ms{4343};

ms = 432; //hata
int ival = ms; //hata
}

---------------

önemli bir kural : daha ince türden daha kalın türe örtülü dönüşüm yok

using namespace std;
using namespace std::chrono;

int main()
{
milliseconds ms{4343};
microseconds us{4'513'981};

us = ms; //legal
ms = us; //hata 

//örtülü dönüşüm yapabilriiz
}

----------------

using namespace std;
using namespace std::chrono;

using halfsec = duration<double, ratio<1, 2>>;

int main()
{
milliseconds ms{ 42323 };
microseconds us{4'322'323};

halfsec hs = ms;
}

-----------------

eğer temsil türü tam sayı ise daha ince'den kabaya dönüşüm yok
eğer represantatiton türü gerçek sayı türü ise her türlü dönüşüm var

----------------

using namespace std;
using namespace std::chrono;

using halfsec = duration<double, ratio<1, 2>>;

struct Data {
int mx;
};

int main()
{
Data mydata;
//Data mydata{}; //bu şekilde ub olmaz value init edildiğinde ilk olarak sıfır ile init edilir  
cout << mydata.mx << '\n'; //tanımısz davranış
}

----------------

template <typename Rep, typename Per>
struct Duration {

Rep count()const
{
return val;
}
Rep val;
};

int main()
{
milliseconds ms;
//milliseconds ms{}; //Bu şekilde yaparsak değişir


cout << ms.count() << '\n';  //ub 
}

----------------

yapılan en büyük hatalardan biri

duration nesnesi default init edersek intermit value'da olması

---------------

duration değeri bir stream'e yazdırılabilir mi?
//c++20 ile c++17 arasında büyük fark var

using namespace std;
using namespace std::chrono;

int main()
{
cout << milliseconds {345} << '\n'; // cpp 20'ye kadar hatalıydı
}


---------------
//cpp 20 öncesi ise bu şkeilde olur

using namespace std;
using namespace std::chrono;

int main()
{
milliseconds ms{345}; 

cout << ms.count() << "ms"; 
}

==================================================================

araya konu alıyoruz

UDL (user defined literals)
----------------------------

aslında operator overloading'in başka bir biçimidir.

823ms

operator""ms(823)

bazı yerlerde sabit gibi kullanılan değelerin kullanılma imkanını veriyor

---------------

using namespace std;
using namespace std::chrono;

int main()
{
auto dur = 345ms; //legal
constexpr auto dur1 = 345ms; //legal
constexpr auto dur2 = operator""ms(345); //legal, ismi ms olan fonksiyona gönderiyoruz

}

----------------

using namespace std;
using namespace std::chrono;

int main()
{
auto dur = 345ms;
constexpr auto dur1 = 345ms;
constexpr auto dur2 = operator""ms(345);

}

------------------


int main()
{
using namespace std::literals; 
using namespace std::chrono_literals; //bunlar görünür olmalı
//ancak bunlar inline namepsace olduğu için aşağıdaki yeterli

using namespace std::chrono;

567ms + 3457us + 6767ns //aslında bunlar constexpr fonksiyonlar ben bunlara sırasıyla 567 değerlerini geçmiş oldum
}

--------------------

using namespace std;

int main()
{
operator""s("alican", 6)
//ikisi arasında fark yok
"alican"s
}

-----------------------

//keyfi parametre yapamıyoruz bunları

operator""_x(long long double)
operator""_y(unsigned long long)
operator""_z(char)
operator""_z(const char*, size_t);

//bu listeyi daha sonra görüceğiz

-----------------------

bu user defined literaller 
cooked ya da uncooke olabiliyor

cooked: ben bu karakterleri göndermiyorum bu değeri gönderiyorum

int main()
{
using namespace std::chrono;

operator""s
567s
"mustafa"s //direk argüman olarak gönderiyorum cooked

678768x //elimizce sadece bir yazı var ondan elde ediceksek uncooked 
}

-----------------------

int main()
{
using namespace std::chrono;

78787kg; //gönül isterdi ki böyle sabitlerde oluşturalım fakat bu yasaklanmış
67867_kg //ancak bu şekilde olabilir
}

----------------------
!! programcının tanımladığı literal operatorler _ ile başlamalı
-----------------------

literal operatorlerimizi oluşturuyoruz
---------------------------------------

constexpr double operator""_m(long double val)
{
return static_cast<double>(val);
}

int main()
{
4.5_m //geçerli, ifadenin türü double, constant expression
constexpr auto x = 4.5_m; //Hata olmaz

constexpr double y = operator""_m(4.576);
}

------------------------
constexpr double operator""_m(long double val)
{
return static_cast<double>(val);
}

constexpr double operator""_cm(long double val)
{
return static_cast<doble>(val / 100);
}

constexpr double operator""_mm(long double val)
{
return static_cast<doble>(val / 1000);
}

constexpr double operator""_km(long double val)
{
return static_cast<doble>(val * 1000);
}

int main()
{
constexpr auto distance = 3.5_m + 876.45_cm + 1221.322_mm + 0.033232_km

cout << distance << " metre\n";
}

-----------------
#include <array>

constexpr std::size_t operator""_KB(unsigned long long size)
{
return static_cast<std::size_t(size * 1'024);
}

constexpr std::size_t operator""_MB(unsigned long long size)
{
return static_cast<std::size_t(size * 1'024 * 1'024);
}

constexpr std::size_t operator""_GB(unsigned long long size)
{
return static_cast<std::size_t(size * 1'024 * 1'024 * 1'024);
}

int main()
{
std::array<char, 12_KB> buf{}; //12kb lık buffer
std::array<char, 1_MB> buf1{}; //1MB lık buffer

}


---------------------

ilginç bir cooked yapısı daha var

using salise = std::chrono::duration<long long, std::ratio<1, 60>>;

contexpr salise operator""_sls(unsigned long long val)
{
return salise{val};
}

int main()
{
using namespace std::chrono;

234_sls
}

----------------------

std::string operator""_str(const char* p, std::size_t n)
{
std::cout << "p adresindeki yazi: " << p << "\n";
std::cout << "n = " << n << '\n';

return "";
}

int main()
{
using namespace std::chrono;

auto s = "gurkan"_str;

}

------------------

std::string operator""_str(const char* p, std::size_t)
{
return std::string{ p };
}

int main()
{
using namespace std::chrono;

"gurkan"_str;
}

---------------

std::string operator""_s2(const char* p, std::size_t)
{
return std::string{ p } + p;
}

std::string operator""_s3(const char* p, std::size_t)
{
return std::string{ p } + p + p;
}

int main()
{
using namespace std::chrono;

cout << "ali"_s2 << "\n";
cout << "ali"_s3 << "\n";

}

----------------------

#include "date.h"

Date operator""_dt(const char *p, std::size_t)
{
return Date{p};
}

int main()
{
using namespace std;

cout << "21-05-1992"_dt + 56 << '\n';
}

-----------------

constexpr int operator""_i(char c)
{
return c;
}

int main()
{
using namespace std;

cout << 'A' << "\n"; //bunun türü char
cout << 'A'_i << "\n"; //bunun türü int

}

---------------------

uncooked mantığına bakıyoruz
----------------------------

void operator""_x(const char* p, size_t);
void operator""_y(const char* p);

int main()
{
"alican"_x;

65423_y; //ikisi aynı anlamdadır
operator""_y("32223"); //ikisi aynı anlamdadır, derleyici bu hale dönüştürür
}

----------------

void operator""_y(const char* p)
{
for (int i = 0; p[i] != '\0'; ++i) {
std::cout << p[i] << '\n';
}
}

int main()
{
654435_y;
//operator""_y("87887");
}

----------------

unsigned int operator""_b(const char* p)
{
unsigned result{};

using namespace std::literals;

while (*p) {
char digit = *p;
if (digit != '1'&& digit != '0') {
throw std::runtime_error{"invalid character : "s + digit}
}
result = result * 2 + (digit - '0');
++p;
}
return result;
}

int main()
{
using namespace std;

try
{
auto val = 100203010_b;
cout << val << "\n";
}
catch(const std::exception& e)
{
    std::cerr << e.what() << '\n';
}


}

-------------------
geri dönüş değeri operatorde olabilir

#include <iomanip>

void operator""pr(const char* p)
{
std::cout << std::quoted(p) << '\n';
}

int main()
{
6786.89_pr;
43432_pr;

operator""_pr("898997");
}

------------------

neden chrono kütüphanesinde duration türü var çünkü ana amaç sn, ms, doğrudan primitif(tam sayı, gerçek sayı)
türler ile ifade etmmek yerine onun kendisini bir tür yapmaktır

------------------
//Bazı yasaklamalar yapmak istiyorum bunun için ctor explicit yapılabilir

class Kilogram {
public:
explicit Kilogram(double val);

private:
double mwieght;
};

void foo(Kilogram);

int main()
{
Kilogram x = 5.4332; //explicit yaparak burayı sentax hatası yaptık
Kilogram x(3.2233); //

}

----------------
//aşağıdaki yöntem kullanılır

class Kilogram {
public:
class prevent_usage {};
constexpr Kilogram(prevent_usage, double val) : mweight{val} {}

friend constexpr Kilogram operator+(const Kilogram& x, const Kilogram& y)
{
return Kilogram{Kilogram::prevent_usage{}, x.mweight + y.mweight};
}

private:
double mweight;
};

constexpr Kilogram operator""_kg(long double x)
{
return Kilogram{Kilogram::prevent_usage{}, static_cast<double>(x) };
}

constexpr Kilogram operator""_gr(long double x)
{
return Kilogram{Kilogram::prevent_usage{}, static_cast<double>(x / 1000.) };
}

constexpr Kilogram operator""_mg(long double x)
{
return Kilogram{Kilogram::prevent_usage{}, static_cast<double>(x / 1000. / 1000.) };
}


int main()
{
constexpr auto weight = 4.5_kg + 1234.87_gr + 365'332.55 _mg

}

----------------------

//chrono kütüphanesi bu dönüşümleri hallediyor
int main()
{
using namespace std::chrono;

35s + 3567ms
}

//bu tarz işlemlerde veri kaybını önlemek için tür dönüştürme kullanılır

------------------

int main()
{
using namespace std::chrono;

auto ms = 67767ms;

second s = ms; //hata, bu hatayı düzeltmenin yolları

seconds s(ms.count() / 1000);

cout << s << "\n";
}

--------------
//duration cast
int main()
{
using namespace std::chrono;

auto ms = 67767ms;

auto sec = duration_cast<seconds>(ms);

cout << sec.count() << " saniye\n";
cout << sec << " saniye\n"; //c++20
}

--------------
//chrono kütüphanesi kullanarak süreyi saat,saniye, ms, olarak yazdırılması isteniyor

using namespace std;
using namespace std::chrono;

int main()
{
long long val;
std::cout << "milisaniye olarak degeri girin : ";
//bu degeri sn ms saat olarak yadırın
cin >> val;

miliseconds ms{ val };
hours hrs = duration_cast<hours>(ms);
minutes mins = duration_cast<minutes>(ms % 1h);
seconds sec = duration_cast<seconds>(ms % 1min);
milliseconds msx(ms % 1s);

if (hrs.count())
cout << hrs.count() << " saat \n";

if (mins.count())
cout << mins.count() << " dakika\n";

if (sec.count())
cout << sec.count() << " saniye\n";
}

if (msx.count())
cout << msx.count() << " mili saniye\n";
}

}

----------------------

using namespace std;
using namespace std::chrono;

int main()
{
auto ms = 678'678ms;

cout << duration_cast<seconds>(ms) << "\n";
cout << floor<seconds>(ms) << "\n";
cout << ceil<seconds>(ms) << "\n";
cout << round<seconds>(ms) << "\n";
}

-------------------

time point : bir saatein ebokuyla iliştirilenmiş duration ifade ediyor
//önemli bir kod


template <typename Rep, typename Period>
std::ostream& operator<<(std::ostream& os, const std::chrono::duration<Rep, Period>& dur)
{
return os << dur.count() << " * ("" << Period::num << " / " << Period::den << ")";
}

using tensec = std::chrono::duration<int, std::ratio<10>>;
using halfsec = std::chrono::duration<int, std::ratio<1, 2>>;

int main()
{
using namespace std;
using namespace std::chrono;

cout << 34.54ms;
cout << 3454ms;

cout << tensec{ 6512 } << "\n";
}

--------------------

template <typename Rep, typename Period>
std::ostream& operator<<(std::ostream& os, const std::chrono::duration<Rep, Period>& dur)
{
return os << dur.count() << " * ("" << Period::num << " / " << Period::den << ")";
}

using tensec = std::chrono::duration<int, std::ratio<10>>;
using halfsec = std::chrono::duration<int, std::ratio<1, 2>>;

int main()
{
using namespace std;
using namespace std::chrono;

milliseconds ms{ 4544 };

cout << ms << "\n";
ms += 12min;
cout << ms << "\n";
}

---------------------------------------

time_point bakıyoruz

int main()
{
using namespace std;
using namespace std::chrono;

System_clock : Ayarlanabilir saat yani ayarlanabilir.Sistem saati değişince system clockta ona göre değer verecek.Gerçek dakika saniye gün işlemleri bununla yapılıyor.
Steady_clock : Ayarlanamayan saat.Sistem saati değiştirsekte bu değişmeyecek.Monotonik saat.Kullanım amacı süre ölçmek
High_resolution_clock : Aslında yukarıdakilerden birinin eş ismi

//cpp 23 öncesinde sadece 3 tane saat türü var
}

---------------------

int main()
{
using namespace std;
using namespace std::chrono;

//system_clock::time_point

time_point<system_clock, system_clock::duration>
time_point<system_clock> //aynı anlamda


}

-------------------

int main()
{
using namespace std;
using namespace std::chrono;

is_same_v<system_clock::time_point, time_pint<system_clock> //true olucak
}

-----------------

time_point ile neler yapabilirim

saatin now değerini çağırmak

using namespace std;
using namespace std::chrono;

int main()
{
auto tp1 = system_clock::now();
auto tp2 = system_clock::now();

tp2 - tp1 //bir duration elde edilir

}

----------------------
//saatlerin durationlarının ne olduğunu yazdırıyoruz

using namespace std;
using namespace std::chrono;

int main()
{
cout << typeid(system_clock::time_point).name() << "\n";
cout << typeid(high_resolution_clock::time_point).name() << "\n";
cout << typeid(steady_clock::time_point).name() << "\n";

}

-------------------------

using namespace std;
using namespace std::chrono;

int main()
{
cout << typeid(system_clock::time_point).name() << "\n";

system_clock::duration
system_clock::time_point
system_clock::period
system_clock::rep


}

-------------------
//stady olmaması saatin ayarlanabilir olmaması demektir
//yani aynı count değerini birkaç kez alabiliriz

using namespace std;
using namespace std::chrono;

int main()
{
stady_clock::is_steady //true olur
}

-----------------------

mülakatların temel ihtiyaç kodlarından biridir ==> süre ölçümü

----------------------
//bir kaç kez yazmak gerekiyor 

std::vector<size_t> get_soreted_vector(std::size_t n)
{
std::vector<size_t> vec(n);

std::generate_n(vec.begin(), n, rand);
std::sort(vec.begin(), vec.end());

return vec;
}

int main()
{
using namespace std;
using namespace std::chrono;


auto tp_start = steady_clock::now();

auto vec = get_sorted_vector(2'450'000); //bu işlem kaç saniye sürecek onu ölçüceğiz

auto tp_end = steady_clock::now();

cout << duration_cast<milliseconds>(tp_end - tp_start).count() << " milisaniye\n";

//cout << duration<double, milli>(tp_end - tp_start).count() << " saniye\n";
//cout << duration<double, micro>(tp_end - tp_start).count() << " saniye\n";

cout << "vec.size() = " << vec.size() << '\n';
}

----------------

std::vector<size_t> get_soreted_vector(std::size_t n)
{
std::vector<size_t> vec(n);

std::generate_n(vec.begin(), n, rand);
std::sort(vec.begin(), vec.end());

return vec;
}

int main()
{
using namespace std;
using namespace std::chrono;

auto tp = system_clock::now();

time_t ct_time = system_clock::to_time_t(tp);

cout << ctime(&ct_time) << "\n"; //time kütüphanesi ile yapılacak işlemleri burada yapabiliriz
}

--------------------

from_time_t : time_t time pointe dönüşebilir

----------------------

std::vector<size_t> get_soreted_vector(std::size_t n)
{
std::vector<size_t> vec(n);

std::generate_n(vec.begin(), n, rand);
std::sort(vec.begin(), vec.end());

return vec;
}

int main()
{
using namespace std;
using namespace std::chrono;

auto tp = system_clock::now();

cout << duration_cast<int, ratio<60 * 60 *24>(tp.time_since_epoch().count() << "\n";

}

------------------------

std::vector<size_t> get_soreted_vector(std::size_t n)
{
std::vector<size_t> vec(n);

std::generate_n(vec.begin(), n, rand);
std::sort(vec.begin(), vec.end());

return vec;
}

int main()
{
using namespace std;
using namespace std::chrono;

auto tp = system_clock::now()

cout << tp.time_since_epoch().count() << "\n";

cout << duration_cast<seconds(tp.time_since_epoch()).count() << "\n" //duration'dan geçen saniye sayısını elde ederiz
cout << duration_cast<int, ratio(60 * 60 *24>>>(tp.time_since_epoch()).count() << "\n"; //epochtan geçen süreri gün olarak elde etmiş oldum

}


------------------------

time_since_epoch duration ölçmez duration'ı time point durationa dönüştürür


