////////////////////////////////////////////////////// 1. Ders ///////////////////////////////////////////



en çok yapılan hatalar:
-----------------------

-değişkenleri const yap

eğer değişken değeri hesaplama sonucu ortaya çıkıyorsa aşağıdaki şekilde yapılabilir

//IIFE
int main()
{
using namespace std;

int a = 5;
int b = 6;
int c = 9;

const auto ival = [&]() {
auto x = a * b + c;
if (x > 100)
x += 5;
else 
x -= 5;

return x - a - b;
}();
}

-------------------

void func(std::vector<std::string> svec) //copy elision olmassa copy ctor çağrılır bu yapıda, bu da çok maaliyetli bir durumdur
{

}

//onun yerine const ve ref yap

void func(const std::vector<std::string> &svec)
{

}

-------------------
//ref gerektirmeyen durumlar

-içerde kopyasını çıkartıcaksak
-ctor aldığı sınıf nesnesi ile veri elemanın init yapıyorsa

class Frk {

public:
Frk(std::vector<std::string> vec) : mvec(std::move(vec)) {}
private:
std::vector<std::string> mvec

}


-------------------

out parametrelerde kaçının 

void func(std::vector<std::string>&); //böyle değil
std::vector<std::string> func(); //Böyle yap


---------------------

her execption yaklamaya çalışma

exception yakalıycaksan handler et, programın  akışını oradan devam ettirme

---------------------

tür eş ismi ve namespace alias kodda kullanmak önemlidir

yoksa aşağıdaki şekilde çirkin kodlar olur

vector<vector<cc::neco<int>>::iterator //bunu kimse anlamaz, onun yerine bunun kulllanımına dair tür eş ismi verirsek ortalığı daha rahatlatmış oluruz

-----------------------

uzun fonksiyonlar yazmak sakıncalı

fonksiyon uzunluğu 20-25 satıdan uzun olmasın,

farklı sorumluluları aynı koda yüklemeyin

-----

void do_something()
{
if (expr) { //kodu okuyan bu expr bilmek zorunda değildir

}
}

//onun yerine aşağıdaki uygulanabilir

if (is_not_valid_state())
do_this;

------------------------

ananim namespace kullan

//bugra.cpp

namespace {
int foo(int);
int g = 46;
class Helper {

};
}

============================================

--------------

string_view ve regex mülakatlara girmeden bilinmesi gerekn konular necati hoca sölüyor

---------------


dosya işlemlerine devam...

--------------

std::ifstream open_binary_file(const std::string& filename)
{
std::ifstream ifs{ filename, std::ios::binary};
if (!ifs) {
throw std::runtime_error{ filename + "dosyasi acilamiyor!\n" };
}
return ifs;
}

std::ifstream create_binary_file(const std::string& filename)
{
std::ifstream ofs{ filename, std::ios::binary};
if (!ifs) {
throw std::runtime_error{ filename + "dosyasi olusturulamiyor!\n" };
}
return ifs;
}

--------------

#include "nutility.h"
#include <fstream>

int main()
{
using namespace std;

auto ofs = create_binary_file("primes10000.dat"); //dosya binary modda açmak için yapılır
constexpr size_t n = 10'000u;
int x{};
int prime_count{};

auto ofs = create_binary_file("primes10000.dat");

while (prime_count < n) {
if (is_prime(x)) {
ofs.write(reinterpret_cast<char*>(& x), sizeof(int));
++prime_count;
}
++x;
}

// ofs.close(); //istediğimiz zaman dosyayı kapatabiliriz
// ofs.open("ali.txt"); //sonrasında başka bir dosya da açabiliriz
// { } kullanarak dosyanın daha erkende kapanmasını sağlayabiliriz
}

----------------

void func()
{
//code
//code

//statement1
//statement2

//sadece ben statement 1 ve statement 2 yürütülürken hayatta olan bir nesne istiyorum (kritik bölgeyi daraltma)

}


----------

#include <mutex>

std::mutex mtx;

void func()
{
//code
//code

lock_guard lock{ mtx }; //aşağıdaki kodlar kilit altında
//statement1
//statement2
//sadece ben statement 1 ve statement 2 yürütülürken hayatta olan bir nesne istiyorum (kritik bölgeyi daraltma)

}

-----------

include <mutex>

std::mutex mtx;

void func()
{
//code
//code
//code

{
lock_guard lock{ mtx };
//statement1
//statement1
}

//statement1
//statement2
//statement3
}

-------------------------

//10 000  tane asal sayısı okuyan program

int main()
{
using namespace std;

auto ifs = open_binary_file("primes10000.dat");

int x{};

while (ifs.read(reinterpret_cat<char*>(&x), sizeof(x))) {
cout << x << "\n";
}

----------------

int main()
{
using namespace std;

auto ifs = open_binary_file("primes10000.dat");

vector<int> ivec(10000);

//öyle bir kod yazki vector nesnesi ilk1 10'000 asal sayıyı tutsun

ifs.read(reinterpret_cast<char*>(ivec.data()), 10'000 - sizeof(int));

for (const auto val : ivec) {
cout < val;
(void)getchar();
}
}

----------------

//c kursunda yazılan bir kodu c++ dilinde yazıyoruz

//komut satirindan calistirilacak

//dbol ali.exe 1000 //ali.exe böler

//17500 byte
//parca001.par 1000
//parca017.par 1000
//parca018.par 500


//dbir veli.exe //veli.exe bölme

-----------------------------

//saat 1.12 de hızlı tekrar et
#include <cstdlib>

//komut satırında çalıştırabilmke için main'in parametre değişkenkerine sahip olması gerekiyor

//dbol ali.exe 1000

int main(int argc, char* argv[])
{
using namespace std;

if (argc != 3) {
cerr << "kullanim: <dbol> <dosya ismi> <byte sayisi>\n";
return 1;
}

char c;
int file_count{};
int byte_count{};

auto ifs = open_binary_file(argv[1]); //dosya açılmassa exception throw gönderir

int chunk = ato(argv[2]);
ofstream ofs;
ostringstream ostr;
//ostr.fill('0');

while (ifs.get(c)) {
if (!ofs.is_open()) {
ostr << "parca" << setw(3) << file_count + 1 << ".par";
ofs.open(ostr.str(), ios::binary);
if (!ofs) {
cerr << ostr.str() << " dosya olusturulamadi\n";
return 1;
}
++file_count;
}

ofs.put(c);
++byte_count;
if (byte_count % chunk == 0) {
ofs.close();
ostr.str("");
}
}
cout << byte_count << " byte'lik " <<argv[1] << " isimli dosya " << chunk << 
" byte'lik " << file_count << " parcaya bolundu\n";
}

----------------------------------
//1.27 tekrar et

//dosya birleştirme kodunu yazıyoruz

//dbir veli.exe

int main(int argc, char **argv)
{
if (argc != 2) {
cerr << "kullanim: <dbir> <yeni dosya ismi>\n";
return 1;
}

auto ofs = create_binary_file(argv[1]);
int file_count{};
int byte_count{};

for (;;) {
ostringstream ostr;
ostr.fill('0');
ostr << "parca" << setw(3) << file_count + 1 << ".par";
ifstream ifs{ostr.str(), ios::binary };
if (!ifs) {
break;
}

char c;
while (ifs.get(c)) {
ofs.put(c);
++byte_count;
}
++file_count;
ifs.close();
if (remove(ostr.str().c_str())) {
cerr << "dosya silinemedi\n";
return 2;
}
}
cout << file_count << " adet dosya " << byte_count << " byte'lik " << argv[1] << 
" isimli dosya olarak birlestirildi\n";
}

--------------------------------

file pointer ile ilgili hizmet veren fonksiyonlar

fseek
rewind
ftell
fsetpos
fgetpos

-----------------

int main()
{
using namespace std;

ofstream ofs{ "necati.txt" };

ofs. //bunlara bak
}

----------

int main()
{
using namespace std;

fstream fs{ "necati.txt" };

fs. //bunlara bak
}

---------

int main()
{
using namespace std;

ifstream ofs{ "necati.txt" };

ofs.tellp;
}

--------

okuma tarafı için konumlandırma taradında seekg
okuma tarafı için konumlandırma taradında seekp

---------

int main()
{
using namespace std;

ifstream ifs {"primesmillion.dat", ios::binary };

//ifs.seekg(10'000) //2 overloadu vardır

//ios::beg
//ios::cur
//ios::seekg()
}

----------

int main()
{
using namespace std;

istringstream iss{"necati ergin" };
//                 necatiergin //farkına bak
string str;

iss >> str;
//      çift tırnak içinde yazar (quoted)
cout << str << '\n';  
iss.seekg(0, ios::beg);
//iss.seekg(1, ios::cur);
//iss.seekg(-6, ios::cur);
//iss.seekg(-6, ios::end);

iss >> str;

cout << str << '\n';
}

-------------

//yazma tarafı içinde bunlar geçerlidir

int main()
{
using namespace std;

ostringstream oss{"furkan mert"};

cout << "[" << oss.str() << "]\n";
oss.seekp(3);
os.put('!');
cout << "[" << oss.str() << "]\n";
oss.seekp(0);
os.put('*');
cout << "[" << oss.str() << "]\n";
}

---------------

int main()
{
using namespace std;

auto ifs = open_binary_file("primesmillion.dat");

int n{};

std::cout << "kacinci asal sayi: ";
cin >> n;

ifs.seekg((n - 1) * sizeof(int), ios::beg);
int x;

ifs.read(reinterpret_cast<char*>(&x), sizeof(int));
cout << n << ". asal sayi " << x << "\n";
}

---------------

void print_file(const std::string& filename, int ntimes)
{
auto ifs = open_text_file(filename);

while (ntimes--) {
std::cout << ifs.rdbuf()
(void)getchar();
ifs.seekg(0);
}
}


int main()
{
using namespace std;

print_file("main.cpp", 5);
}

----------------

//ilginç bir özellik daha var 

read ve write dosyalarının geri dönüş değeri stream nesnesi olduğu için 
özellikle formatsız okumada kaç byte olduğunu bir şekilde bizim anlayabilmemiz lazım
bu yüzden gcount olan fonksiyon koymuşlar

//formatsız okuma işlemlerinden biri çağrıldığında okunan byte sayısı için sınıfın
gcount çağırırız

int main()
{
using namespace std;

auto ifs = open_binary_file("primesmillion.dat");

int n{};

std::cout << "kacinci asal sayi: ";
cin >> n;

ifs.seekg((n - 1) * sizeof(int), ios::beg);
int x;

ifs.read(reinterpret_cast<char*>(&x), sizeof(int));

cout << "okunana byte sayisi : " << ifsgcount() << '\n';

cout << n << ". asal sayi " << x << "\n";
}

--------------

int main()
{
using namespace std;

int *p = new int[20000];

auto ifs = open_binaary_file("primes10000.dat");
ifs.read(reinterpret_cast<char*>(p), sizeof(int) * 20000);

if (ifs) { //istedeğimiz kadar byte okuyamassa stream fail oluyor
std::cout << "stream hata durumunda degil\n";
}
else {
std::cout << "stream hata durumunda\n";
}

std::cout << "okunan byte sayisi: " << ifs.gcount() << "\n"; //dosyaya 10'000 tane asal sayı yazıldığı için 40'000 tane okunur
}

---------------

//bu özelliği anlaıp anlamadığını bilmek için aşağıdaki zor soru sorulur

//komut satırından çalışıtırlan filecopy isimli programı yazınız

//filecopy ahmet.exe mmehmet.exe //2 ayrı süürm şeklinde yaz bunu

1) byte byte oku byte byte yaz

//filecopy ali.exe veli.exe

int main(int argc, char **argv)
{
constexpr std::size_t buffersize{ 1024 };

if (argc != 3) {
std::cerr << "usage: <filecopy> <source file> <dest file>\n";
return 1;
}

auto ifs = open_binary_file(argv[1]);
auto ofs = create_binary_file(argv[2]);

unsigned char buf[buffersize];

//ifs.read isleviyle buffer'a yazip
//ofs.read isleviyle buffer'dan dosyaya aktat

}

--------------------

bufferdan bazı karakterleri okumadan geçmek istiyorum
burada ignore isimli fonksiyonu vardır

int main()
{
using namespace std;

cin.ignore(50, '\n') // 50'nin olduğu yere limit başlık dosyasini kullanarak ekleme yapabiliriz
}

----------------
#include <limits>

int main()
{
using namespace std;

cout << numeric_limits<int>::max() << "\n";
cout << numeric_limits<int>::min() << "\n";


}

----------------

//mesela 8 byte'lık en büyük tam sayı değerini kullanmamız gerekiyor

int main()
{
using namespace std;

constexpr auto n = numeric_limits<unsigned int>::max();


}

--------------

//newline' a kadar olan bütün karakterleri ignore etmek

int main()
{
using namespace std;

cin.ignore(numeric_limits<streamsize>::max(), '\n');

}

----------------

int main()
{
using namespace std;

istringstream iss {"x987324yz"};

int ival;

iss >> ival; //okuma yapmaz çünkü x okumaya uygun değil ancak x ignore etsek
}

-----------------

int main()
{
using namespace std;

istringstream iss {"x987324yz"};

int ival;

iss.ignore();
//iss.ignore(1);
iss >> ival;
}

------------------
//m karakteri görene kadar tüm karakterleri ignore etmesini isteyin

int main()
{
using namespace std;

istringstream iss {"metin98234"};

int ival;

iss.ignore(numeric_limits<streamsize>::max(), 'n');
int ival;
  
iss >> ival;

cout << "ival = " << ival << '\n';
}

----------------
//sürekli kişinin yaşını sorup yaş doğru olmassa dec formatta tekrar tekrar yaşını sorucam


// how old are you?
// ali //geçersiz ise
//ali is not a number
//how old are you? //tekrardan

//akım başarısız ise good state e gelmeli clear çağrılmalı

int main()
{
using namespace std;

int age{};

while (( cout << "how old are you ?") && !(cin >> age) {
cout << "your entry is not a number\n";
cin.clear();
cin.ignore(numeric_limts<streamsize>::max(), '\n');
}

cout << "your age is : "  << age << "\n";

}

----------------

int main()
{
using namespace std;

istringstream iss{
"761furkan mert\n"
"76431dgurkan yenil\n"
"32761mert sirsakaya\n"
"23269fbugrahnserttas\n" };

for (;;){
int ival{};
iss >> ival;

if (iss.eof() || iss.bad()) {
break;
}

if (iss.fail()) {
iss.clear();
iss.ignore(numeric_limits<streamsize>::max(), '\n');
}
else {
cout << ival << "\n";
}
}
}

////////////////////////////////////////////////////// 2. Ders ///////////////////////////////////////////

bir stream'in output stream'e tie(bağlanması) edilmesi

giriş akımını çıkış akımına tie edersek standart input üzerinde bir giriş işlemi yapıldığında
öncelikle onun bağlandığı output stream flush edilir


--------------------

tie
----

cin.tie() 
//2 overloadı var 
//1. overload hangi output stream'e tie edilmiş ise onun stream'i döndürür, tie edilmemişse nullptr döndürür

int main()
{
using namespace std;

if (auto osptr = cin.tie()) {
cout << "cin is tied. the address of the stream cin tied to is : " << osptr << '\n';
cout << "&cout = " << &cout << '\n';
}
else {
std::cout << "cin is not tied to any output stream\n";
}
}

---------------------

//2. overloadu

#include <fstream>

int main()
{
using namespace std;

auto ifs = open_text_file("main.cpp");

ifs.tie(&cout);
}

-----------------------

kime bağlıyorsak bağladığımız ostream (çıkış akımı) olmalı

-----------------------

int main()
{
using namespace std;

auto ifs = create_text_file("ali.txt");

ofs.tie();
}

=============================================================================
=============================================================================

labmda ile igilili konuşmadığımız kısımlara bakıyoruz

labmda init capture (c++14)
this capture

-----------------

int main()
{
using namespace std;

auto uptr = make_unique<string>("necati ergin");

//auto f = [uptr]() { //sentax hatası, copt capture çünkü
auto f = [&uptr]() {
cout << *uptr << '\n';
};

f();

cout << (uptr ? "dolu" : "bos") << '\n';
}

--------------------

int main()
{
using namespace std;

auto uptr = make_unique<string>("necati ergin");

auto upx = move(uptr);

cout << (uptr ? "dolu" : "bos") << '\n'; //bos olur uptr taşındı
}

---------------------

labmda ifadsinde öyle bir araç olsun ki  uniqe_ptr taşıma yapılsın

int main()
{
using namespace std;

int x = 46;

auto fn = [a = x] () {
return a * 5;
};
}

----------

auto fn = [x] () {
return x * 5; //aynı anlamda, ancak labmda init capture bize herhangi bir sayıyla init edilme şansıın veirir
};

-----------

int main()
{
using namespace std;

int x = 46;

auto fn = [a = x + 5]() {
cout << a << "\n";
};

fn();
}

------------

int main()
{
using namespace std;

int x = 46;

auto fn = [x = x + 5]() {
cout << x << "\n";
};

fn();
}

-----------
//bu özellikler aşağıdaki kodda işimize yarıycak

int main()
{
using namespace std;

auto uptr = make_unique<string>("necati ergin");

//auto f = [uptr]() { //sentax hatası, copt capture çünkü
auto f = [&uptr]() {
cout << *uptr << '\n';
};

f();

cout << (uptr ? "dolu" : "bos") << '\n';
}

------------

int main()
{
using namespace std;

int x = 5;

auto fn = [&x = x] {++x};

cout << "x = " << '\n'; //labmda çağrılmaz ondan değer değişliği olmaz
}

-----------

int main()
{
using namespace std;

int x = 5;

auto fn = [&x = x] {++x};

fn(); //şimdi çağrılır

cout << "x = " << '\n';

}

------------------

int main()
{
using namespace std;

int x = 5;

auto fn = [&x = x] {++x};

fn(); //3 kere çağrılır
fn();
fn();


cout << "x = " << '\n';

}

-------------

int main()
{
using namespace std;

int x = 5;

auto fn = [&x = x] {++x};

int x = 100;
fn(); 


cout << "x = " << '\n';

}

-----------

int main()
{
using namespace std;

int a[10]{};

auto fn = [a] {
std::cout << typeid(a).name() << '\n'; //sınıfın elemanı 10 elemanlı bir dizi olucaktır
};

f();
}

-----------

int main()
{
using namespace std;

int a[10]{};

auto fn = [a = a] {
std::cout << typeid(a).name() << '\n';  //pointer olur

f();
}

===================================

şimdiye kadar kullanıdığımız lambda ifadeler globaldı
 
class Nec {

public:
voif foo()
{
auto val = mx + my; //önce foo içinde araır sonra class içinde
//auto val = this->mx + this->my; //bu çirkiin bir kod
}

private:
int mx, my;
};

---------------

class Nec {

public:
voif foo()
{
int x = 5;

auto fn = [](int a) {return a * a;}; //herhangi  bir sentax hatasu olmaz
auto fn = [x](int a) {return a * a;};

}
private:
int mx, my;

};

--------------

class Nec {

public:
voif foo() //buranın gizli this pointerı vardır
{

auto fn = [x](int a) {
return a * (mx + my); //hata closure type'ın veri elemanıdır bu
};
}

private:
int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();
}

---------------

class Nec {

public:
voif foo() 
{
mx, my //burada kullansak bir problem olmaz

auto fn = [](int a) {
return a * (mx + my); 
}

private:
int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();
}

----------------
//Bunu yapmak için this capture edilmeli

class Nec {

public:
voif foo() 
{

auto fn = [this](int a) {
//auto fn = [&](int a) { //bu şekilde de olur
return a * (mx + my);
};
}

private:
int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();
}

---------------------

this copyalama veya ref ile capture edilebilir farkı yoktur

---------------------

capture etme yollarını anlatan tablo var onu inceliyoruz 

------------------------

class Nec {

public:
voif foo() 
{

auto fn = [this]() {
++mx;
++my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; // 11 yazar
cout << "mynec.mh = " << mynec.my << '\n'; // 21 yazar

}

---------------

*this yazarsak hata vericek 
mynec kendisi olmaz mynec kopyası çıkar biz o kopyanın mx ve my arttırmış oluruz

class Nec {

public:
voif foo() 
{

auto fn = [*this]() {
++mx;
++my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

--------------------

mutable yapmamız gerekir bu durumu düzeltmek için
default olarak const yazardır mutable sayesinde non-const yazar

class Nec {

public:
voif foo() 
{

auto fn = [*this]()mutable  {
++mx;
++my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; // 10 yazar
cout << "mynec.mh = " << mynec.my << '\n'; // 20 yazar
//nec'İn x ve my si değildir kopyasıdır artık
}

---------------
//Yukarıdaki kod ile ilgili

class Myclass {

public:
void bar();
};

class Nec {
public:
void foo() const
{
m.bar(); //hata olur
}
private:
Myclass m; //burada mutable kullanırsak düzelir
};

------------------
& //her şeyi kopyala demektir bu

class Nec {

public:
voif foo() 
{
int a = 67;
int b;
auto fn = [&]() {
return a + b + mx + my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

----------------

[&, this] ; //& ile farkı yok

------------------

class Nec {

public:
voif foo() 
{
int a = 67;
int b;
auto fn = [&, this]() {
return a + b + mx + my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

--------------

[&, *this] 

//*this capture edilir yine *this dışındakiler ref ile capture edilir
class Nec {

public:
voif foo() 
{
int a = 67;
int b;
auto fn = [&, *this]() { 
return a + b + mx + my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

--------------

[=], bu kaldırılacak riskten dolayı

class Nec {

public:
voif foo() 
{
int a = 67;
int b;
auto fn = [=]() { //her rşeyi kopyalama ile capture eder
return a + b + mx + my;
};
fn();
}

int mx{10}, my{20};
};

int main()
{
Necn mynec;
mynec.foo();

cout << "mynec.mx = " << mynec.mx << '\n'; 
cout << "mynec.mh = " << mynec.my << '\n'; 

}

--------------

[=, this]

---------------

[=, *this]

-------------

=========================================================

#include <ratio>

buradaki bütün işlemler compile time'da yapılır


int main()
{
using namespace std;

ratio<5, 3> //5 bölü 3 demetir
}

--------------

int main()
{
using namespace std;

ratio<5>
ratio<5,1> //aynı anlamda

}

----------------

template <int NUM, int Den = 1>
class Ratio {

};

int main()
{
using namespace std;

ratio<2, 5> //2/5 
}

----------------

template <int NUM, int Den = 1>
class Ratio {
public:
constexpr static int num = NUM;
constexpr static int num = DEN;

};

int main()
{
using namespace std;

Ratio<2, 5>::num;
}

------------------

orjinali

int main()
{
using namespace std;

ratio<2, 3>::num; //compile time sabitidir,  2 
ratio<2, 3>::den; // 3 
}

--------------------

int main()
{
using namespace std;

ratio<5, 45>::num; //1
ratio<5, 45>::den; //9 
raito<12, -18>::num //-2
}

----------------------

int main()
{
using namespace std;

cout << (ratio<2, 5>::type).name()  << '\n';
} 

---------------------

meta compile time da tür hesaplamayı sağlar

int main()
{
using namespace std;

using rt = ratio_add<ratio<1, 3>, ratio<2,5>>type; //1/3 + 2/5

}

------------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_add<one_third, two_fifth>::type

}

------------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_multiply<ratio<2, 3>, ratio<3,2>>::den
ratio_divide

}

--------------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_equal<ratio<1, 3>, ratio<2, 6>::value //true çıkar

}

----------------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_less<ratio<86123, 98134>, ratio<87981, 99134>>::value //false olur value
ratio_less_v<ratio<86123, 98134>, ratio<87981, 99134>> //bu şekilde yapılabilir
}

----------------------

bazı kesirleri daha kolay kullanabilmek için ratio tür eş isimleri vermişler bazı değerlere

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

milli::num //1 
milli::den //1000

deci::
//cpp ref den devamına bak
}

----------------

deci
centi
milli

---------------

using one_third = std::ratio<1, 3>;
using two_fifth = std::ratio<2, 5>;

int main()
{
using namespace std;

ratio_multiply<milli, kilo>
}

==========================================================

chrono kütüphanesi : tarih zaman ile ilgili yardım sağlar
------------------
minimal olarak bakıcağız çok büyük bir kütüphane


clock

time_point

duration

--------------------------.---------------------> //bu çizgi akan zaman olsun
                     //bu nokta ise akan zamandaki bir time point

//2 pointer birbirinden çıkınca süre elde edilir (duration)

//time point epok tak geçen 

time point'e duratiıın eklersek time point elde ederiz

2 time point toplanırsa anlamlı sonuç çıkmaz

-------------------

sıfır maaliyetli bir soyutlamadır bu kütüphane çok başarılıdır

--------------------

2345 saniye
int sec; //mantıklı değil

-----------
chorono kütphanesinin hepsi nested namespace içinde bunun adı chrono

int main()
{
using namespace std;

chrono::duration

}

---------------

//bu da olur

int main()
{
using namespace std::chrono;

duration 
}

-------------

int main()
{
namespace chr = std::chrono;

chr::duration

}

--------------
duration bir sınıf şablonu,  2 template parametresi var

using namaspace std;
using namaspace chrono;

int main()
{
duration;
std::chrono::namespace; //
}

----------------
//representation doğru seçmek gerkeir (int, double)

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<1, 1>> //süre birimi saniye int ile iafede ediyor
duration<int> //bununla aynı anlamda
duration<int, ratio<1, 1>> //bunlar aynı anlamda
}

--------------

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<1, 2>> //yarım saniye süresi

}

---------------
ms ifade eden bir duration türü oluştur

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<1, 1000>> //ms türü kaç ms olduğunda kaç değeri int
duration<double, ratio<1, 1000>>
//kısa olarak aşağıdaki yazılır
duration<int, milli>
}

------------
saatleri ifade etsek

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<3600>>


}

-------------

using namaspace std;
using namaspace chrono;

int main()
{
duration<int, ratio<1, 60>

}

--------------
using namaspace std;
using namaspace chrono;

int main()
{
cout << typeid(seconds).name() << "\n";
}

--------




