/////////////////////////////////////////////////////////////////////////////////1. Ders///////////////////////////////////////////

C in C++

undefined behavior
unspecidied behavior
  implementation defined

==================================

static typeing : koda bakarak veri türü anlaşılır
dinamik typeing : verilerin ne olduğu run time sırasında anlaşılıyor

====================================
C ve C++ arasındaki temel farklılıklar :

implicit int (gizli int): 
C dilinde artık kullanılmaz C++ dilinde sentax hatası verir

func(int x)
{
return x + 5;
}

-------------

old-style function definitons: C'nin eski kodlarında kullanılıyor c++'da geçerli değil

func(a,b,c)
double a,b,c;
{
return a + b + c;
}

-------------
implicit function declaration:

int main
{
func(1,3,5); // c dilinde legal c++'da error
}

-------------
C dilinde aşağıdaki farklılık gösterir ancak c++'da parantez içini boş bırakmak ile
bırakmamak arasında fark yoktur.

int foo();
int bar(void);

int main(void)
{
foo(12,56,67);
foo(12,56,67);
}

!! implicit int, implicit function declaration ve void içini boş
bırakmak C++'da yok

-----------

int foo()
{
printf("merhaba"); 
//c++'da geri dönüş değeri bildirmek zorundayız
}

-----------

equality operators: == !=
relational operator: < <= > >=

==========================================

Tür dönüşümleri:

!! C++ da Pointer türlerinden tam sayı türlerine, tam sayı türlerinden pointer türlerine dönüşüm yok

int main(void)
{
in x = 10;
int * p = x;

}

-------------

!! aritmetik türlerinden pointer türlerine örtülü dönüşüm yok
!! pointer  türlerinden aritmetik türlerine tür dönüşüm yok
!! farklı pointer türlerine arasında dönüşüm yok

int main()
{
int x = 10;
char * p = &x;
}

-----------

int main()
{
int x = 10;
void * vptr = &x;

int * p = vptr;
char * = malloc(1024); //c++ da error
}

-------
öyle bir pointer değişken tanımlaki tür dönüştürme operatörü kullanmadan kendi
nesnesini tutsun
int main()
{
void * vp = &vp; //c++ da sentax hatası değildir
}

////////////////////////////////////////////////////////////2. Ders/////////////////////////////////////////7

int main(void)
{
int x; //default initialzing olur

!! ilk değerini sabit nesnelerden almış nesneler sabit ifadesi gereken yerde kullanılıyor
const int x = 10;
int a[x];//legal

switch (foo()){
case x; //legal
}
}

-------------

const int x = 10; //c dilinde external linkage, C++ dilinde içi bağlantı olur

-------------

int main()
{
int x = 10;
int * const p = &x;
//top level const, const pointer to int, right const olarak adlandırılabilinir
}

-------------

int main()
{
int x = 10;
int y = 34;

const int * p = &x; //ikisi arasıda fark yoktur 
int const *p = &x;
}


---------------
!! mülakat sorusu
typedef int * IPTR;
int main()
{
int x = 10;
const IPTR p = &x;

//hangisi olucak
int * const p = &x; //bu olur
const int * p = &x; 
}

----

int main(void)
{
int x = 10;

cont int * const ptr = &x;
//const pointer to const int
}

---------

int main()
{
int a[5] = { 1,2,3,5,4};
int(*p)[5] = &a;
*p //a dizisinin kendisidir
}


-------

int main()
{
char * p = "furkan"; //c'de hata yok
}

"furkan" ==> c de char dizi
"furkan" ==> c++ de const char dizi

--------

!! const char diziden char diyize dönüşüm c++ dilinde yoktur

----------

int main(void)
{
char * p = "furkan"; //c++ dlinde illegal
const char * p = "furkan"; //c++ dilinde legal
}

---------------

struct Data {
int a,b,c;
};

enum Color {Blue, Black, Purple};

int main()
{
Data mydata;//C dilinde illegal c++ dilinde bu şekilde kullanılır
Color mycolor
}

---------

for (int i = 0; i < 10; ++i){
int i = 34; //c++ dilinde hata
}//i'nin scopu c dilinde olduğu gibi for parantezinde değil burada biter


=====================================================================================================
CPP

initializng:

int main()
{
int x(10); //direct initializng
int x{10}; //uniform init, brace init
int x{}; //value init, 0 ile başlar
int x; //default init
int x = 10; //copy init
}

Neden uniform initializng vardır?
1. uniform
2. narrowing conversion
3. most vexing parse

!! küme parantezi ile ilk değer verdiğimiz zaman narrowing conversion sentex hatasına düşer

int main(void)
{
double dval{4.436};
int ival{dval};
}

most vexing parse : hem fonksiyon bildirimi hemde değişken tanımlama var ise fonksiyon bildirini öncelik olur

------------------
aynı anlamdadır

void foo(int[]);
void foo(*p);

void func(int(*)(int));
void func(int(int));
---------------------

nullptr: bir pointerın türünü null pointer yapıcak isek kullanılır

-keyworddür
-türü nullptr_t
-ilk değer ve atama yapılabilinir.
-pointer olmayan bir değişkene atanamaz

int * p = nullptr; //bunu kullan
int * p = 0; //bunu kullanma

//////////////////////////////////////////////////3. Ders////////////////////////////////////////








